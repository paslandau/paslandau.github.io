<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="Create a VM on Google Cloud Platform deploy and run dockerized PHP applications via docker compose.">
            <meta name="author" content="Pascal Landau">
        <title>Deploy dockerized PHP Apps on a GCP VM [Tutorial Part 8] | pascallandau.com</title>
    <meta name="google-site-verification" content="fcW8afndMqg-HUmdh_fIAbz81qMkxVJA-Hogrg3UYEw"/>

    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link href="/css/clean-blog.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/css/main.css">
    <!-- highlight.js -->
    <link rel="stylesheet" href="/css/default.min.css">
    <!-- RSS Feed -->
    <link rel="canonical" href="https://www.pascallandau.com/blog/deploy-docker-compose-php-gcp-poc/"/>
        <link rel="alternate" type="application/rss+xml" title="pascallandau.com" href="https://www.pascallandau.com/feed.xml"/>
    <link rel="alternate" type="application/rss+xml" title="pascallandau.com - Finance related articles" href="https://www.pascallandau.com/feed-finance.xml"/>
    <!-- Custom Fonts -->
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || [];
            w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            });
            var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : '';
            j.async = true;
            j.src =
                'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-5B9NRTM');</script>
    <!-- End Google Tag Manager -->
</head>

<body>
<!-- Google Tag Manager (noscript) -->
<noscript>
    <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5B9NRTM"
            height="0" width="0" style="display:none;visibility:hidden"></iframe>
</noscript>
<!-- End Google Tag Manager (noscript) -->
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse"
                    data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">pascallandau.com</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/">Home</a>
                </li>
                <li>
                    <a href="/about/">About</a>
                </li>
                <li>
                    <a href="/blog/">Blog</a>
                </li>
                <li>
                    <a href="/blog/#newsletter">Newsletter</a>
                </li>
                <li>
                    <a href="/bigquery-snippets/">BigQuery Snippets</a>
                </li>
                <li>
                    <a href="/docker-php-tutorial/">Docker PHP Tutorial</a>
                </li>
                <li>
                    <a href="/personal-finance/">Personal Finance</a>
                </li>



            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

<!-- Page Header -->
<!-- Set your background image for this header on the line below. -->
<header class="intro-header" style="background: #000
        ">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Deploy dockerized PHP Apps on a GCP VM</h1>
                                            <h2 class="subheading">- via docker compose as a POC </h2>
                                                                <span class="meta">
                            <span style="display:block; margin:0;">
                                Posted by <a href="#">Pascal Landau</a> on 2022-05-18 10:00:00
                            </span>
                            <span style="display:block;">
                                <a href="https://twitter.com/PascalLandau">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-twitter fa-stack-1x"></i>
                                    </span>
                                </a>
                                <a href="https://www.linkedin.com/in/pascallandau">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-linkedin fa-stack-1x"></i>
                                    </span>
                                </a>
                                <a href="https://github.com/paslandau/">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-github fa-stack-1x"></i>
                                    </span>
                                </a>
                                <a href="https://www.youtube.com/channel/UC8hVNCGAtz1DvOOpSQ3Nfzw">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-youtube fa-stack-1x"></i>
                                    </span>
                                </a>
                            </span>
                        </span>
                                    </div>
            </div>
        </div>
    </div>
</header>

<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p><strong>TODO</strong></p>
<ul>
<li>
<p>split article in GCP only and production only</p>
</li>
<li>
<p>add info, that each user via IAP has sudo access by default</p>
<ul>
<li>find docu reference</li>
<li>double check the tutorial where a user is used</li>
</ul>
</li>
<li>
<p>update php-base Dockerfile</p>
<ul>
<li>fix for the git issue ==&gt; add to the git secret tutorial</li>
</ul>
</li>
<li>
<p>backport the git fix to part 6 and 7</p>
</li>
</ul>
<p><strong>TODO</strong> globally replace all IP addresses of the VM. Canonical one is 35.192.212.130
Others: 35.239.69.58, 34.136.107.232</p>
<p>In the eighth part of this tutorial series on developing PHP on Docker we will <strong>manually create
a VM on GCP (Google Cloud Platform)</strong> as a &quot;production&quot; environment to <strong>deploy our dockerized PHP
application</strong> there and <strong>run it via <code>docker compose</code> as a proof of concept</strong>.</p>
<p><strong>TODO: Add intro video</strong></p>
<p><strong>Add sectino on &quot;why only a POC&quot;</strong></p>
<ul>
<li>docker compose shold not be used in production, especially true for data stores like mysql and
redis</li>
<li>permissions are far too wide</li>
<li>using a Debian base image instead of a COS image </li>
</ul>
<p>All code samples are publicly available in my
<a href="https://github.com/paslandau/docker-php-tutorial">Docker PHP Tutorial repository on github</a>.<br />
You find the branch for this tutorial at
<a href="https://github.com/paslandau/docker-php-tutorial/tree/part-8-deploy-docker-compose-php-gcp-poc">part-8-deploy-docker-compose-php-gcp-poc</a>.</p>
<!-- generated -->
<p><a id='published-parts-of-the-docker-php-tutorial'> </a></p>
<!-- /generated -->
<h2>Published parts of the Docker PHP Tutorial</h2>
<ul>
<li><a href="/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/">Setting up PHP, PHP-FPM and NGINX for local development on Docker</a>
(2018-07-08)</li>
<li><a href="/blog/setup-phpstorm-with-xdebug-on-docker/">Setting up PhpStorm with Xdebug for local development on Docker</a>
(2018-08-06)</li>
<li><a href="/blog/structuring-the-docker-setup-for-php-projects/">Structuring the Docker setup for PHP Projects</a>
(2019-05-20)</li>
<li><a href="/blog/docker-from-scratch-for-php-applications-in-2022/">Docker from scratch for PHP 8.1 Applications in 2022</a>
(2022-03-21)</li>
<li><a href="/blog/phpstorm-docker-xdebug-3-php-8-1-in-2022/">PhpStorm, Docker and Xdebug 3 on PHP 8.1 in 2022</a>
(2022-03-22)</li>
<li><a href="/blog/run-laravel-9-docker-in-2022/">Run Laravel 9 on Docker in 2022</a>
(2022-03-23)</li>
<li><a href="/blog/php-qa-tools-make-docker/">Set up PHP QA tools and control them via make</a>
(2022-04-25)</li>
<li><a href="/blog/git-secret-encrypt-repository-docker/">Use git-secret to encrypt secrets in the repository</a>
(2022-04-25)</li>
<li><a href="/blog/ci-pipeline-docker-php-gitlab-github/">Create a CI pipeline for dockerized PHP Apps</a>
(2022-04-25)</li>
<li><a href="/blog/deploy-docker-compose-php-gcp-poc/">Deploy dockerized PHP Apps on a GCP VM</a>
(2022-04-25)</li>
</ul>
<p>If you want to follow along, please subscribe to the <a href="/feed.xml">RSS feed</a>
or <a href="#newsletter">via email</a>
to get automatic notifications when the next part comes out :)</p>
<!-- generated -->
<p><a id='table-of-contents'> </a></p>
<!-- /generated -->
<h2>Table of contents</h2>
<!-- toc -->
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#gcp">GCP</a>
<ul>
<li><a href="#setup-a-gcp-project">Setup a GCP project</a></li>
<li><a href="#create-a-service-account">Create a service account</a>
<ul>
<li><a href="#create-service-account-key-file">Create service account key file</a></li>
<li><a href="#configure-iam-permissions">Configure IAM permissions</a></li>
</ul></li>
<li><a href="#setup-the-gcloud-cli-tool">Setup the <code>gcloud</code> CLI tool</a></li>
<li><a href="#setup-the-container-registry">Setup the Container Registry</a>
<ul>
<li><a href="#authenticate-docker">Authenticate docker</a></li>
<li><a href="#pushing-images-to-the-registry">Pushing images to the registry</a></li>
<li><a href="#images-are-stored-in-google-cloud-storage-buckets">Images are stored in Google Cloud Storage buckets</a></li>
<li><a href="#pulling-images-from-the-registry">Pulling images from the registry</a></li>
</ul></li>
<li><a href="#setup-the-secret-manager">Setup the Secret Manager</a>
<ul>
<li><a href="#create-a-secret-via-the-ui">Create a secret via the UI</a></li>
<li><a href="#view-a-secret-via-the-ui">View a secret via the UI</a></li>
<li><a href="#retrieve-a-secret-via-the-gcloud-cli">Retrieve a secret via the <code>gcloud</code> cli</a></li>
<li><a href="#add-the-secret-gpg-key-and-password">Add the secret <code>gpg</code> key and password</a></li>
</ul></li>
<li><a href="#gcp-vms-compute-instances">GCP VMs: Compute Instances </a>
<ul>
<li><a href="#create-a-vm">Create a VM</a>
<ul>
<li><a href="#general-vm-settings">General VM settings</a></li>
<li><a href="#the-role-of-the-service-account">The role of the service account</a></li>
<li><a href="#adding-a-public-ssh-key">Adding a public SSH key</a></li>
<li><a href="#define-preemptibility">Define Preemptibility</a></li>
<li><a href="#the-actual-vm-creation">The actual VM creation</a></li>
</ul></li>
<li><a href="#log-into-a-vm">Log into a VM</a>
<ul>
<li><a href="#login-via-ssh-from-the-gcp-ui">Login via SSH from the GCP UI</a></li>
<li><a href="#login-via-ssh-with-your-own-key-from-your-host-machine">Login via SSH with your own key from your host machine</a></li>
<li><a href="#login-using-the-identity-aware-proxy-iap-concept">Login using the Identity-Aware Proxy (IAP) concept</a>
<ul>
<li><a href="#additional-notes-on-iap">Additional notes on IAP</a></li>
</ul></li>
</ul></li>
<li><a href="#run-docker-containers">Run <code>docker</code> containers</a>
<ul>
<li><a href="#installing-docker-and-docker-compose">Installing <code>docker</code> and <code>docker compose</code></a></li>
<li><a href="#authenticate-docker-via-gcloud">Authenticate docker via <code>gcloud</code></a></li>
<li><a href="#pulling-the-nginx-image">Pulling the <code>nginx</code> image</a></li>
<li><a href="#start-the-nginx-container">Start the <code>nginx</code> container</a>
<ul>
<li><a href="#make-an-http-request">Make an HTTP request</a></li>
</ul></li>
<li><a href="#get-the-secret-gpg-key-and-password-from-the-secret-manager">Get the secret <code>gpg</code> key and password from the Secret Manager</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#codebase-changes">Codebase changes</a>
<ul>
<li><a href="#restructure-the-codebase">Restructure the codebase</a>
<ul>
<li><a href="#the-build-directory">The <code>.build</code> directory</a></li>
<li><a href="#the-secrets-directory">The <code>.secrets</code> directory</a></li>
<li><a href="#the-tutorial-directory">The <code>.tutorial</code> directory</a></li>
<li><a href="#the-infrastructure-directory">The <code>.infrastructure</code> directory</a></li>
</ul></li>
<li><a href="#add-a-gpg-key-for-production">Add a <code>gpg</code> key for production</a></li>
<li><a href="#show-the-build-info">Show the <code>build-info</code></a></li>
<li><a href="#optimize-gitignore">Optimize <code>.gitignore</code></a></li>
</ul></li>
<li><a href="#docker-changes">Docker changes</a>
<ul>
<li><a href="#updating-the-docker-compose-yml-configuration-files">Updating the <code>docker-compose.yml</code> configuration files</a>
<ul>
<li><a href="#docker-compose-local-ci-prod-yml"><code>docker-compose.local.ci.prod.yml</code></a></li>
<li><a href="#docker-compose-local-prod-yml"><code>docker-compose.local.prod.yml</code></a></li>
<li><a href="#docker-compose-prod-yml"><code>docker-compose.prod.yml</code></a></li>
</ul></li>
<li><a href="#build-target-prod">Build target: <code>prod</code></a>
<ul>
<li><a href="#adjust-the-dockerignore-file">Adjust the <code>.dockerignore</code> file</a></li>
<li><a href="#build-stage-prod-in-the-php-base-image">Build stage <code>prod</code> in the <code>php-base</code> image</a>
<ul>
<li><a href="#env-based-branching"><code>ENV</code> based branching</a></li>
<li><a href="#avoid-composer-dev-dependencies">Avoid composer dev dependencies</a></li>
<li><a href="#remove-unnecessary-directories">Remove unnecessary directories</a></li>
<li><a href="#remove-secrets-for-other-environments">Remove secrets for other environments</a></li>
<li><a href="#decrypt-the-secrets-via-entrypoint">Decrypt the secrets via <code>ENTRYPOINT</code></a></li>
<li><a href="#copy-codebase-and-build-info-file">Copy codebase and <code>build-info</code> file</a></li>
</ul></li>
<li><a href="#build-stage-prod-in-the-remaining-images">Build stage <code>prod</code> in the remaining images</a></li>
</ul></li>
</ul></li>
<li><a href="#makefile-changes">Makefile changes</a>
<ul>
<li><a href="#adding-gcp-values-to-make-variables-env">Adding GCP values to <code>.make/variables.env</code></a></li>
<li><a href="#env-based-docker-compose-config">ENV based <code>docker compose</code> config</a></li>
<li><a href="#changes-to-the-git-secret-recipes">Changes to the <code>git-secret</code> recipes</a></li>
<li><a href="#additional-docker-recipes">Additional <code>docker</code> recipes</a></li>
<li><a href="#gcp-recipes">GCP recipes</a></li>
<li><a href="#infrastructure-recipes">Infrastructure recipes</a></li>
<li><a href="#deployment-recipes">Deployment recipes</a></li>
</ul></li>
<li><a href="#deployment-workflow">Deployment workflow</a>
<ul>
<li><a href="#the-deploy-target">The <code>deploy</code> target</a></li>
<li><a href="#avoiding-code-drift">Avoiding code drift</a></li>
<li><a href="#the-build-info-file">The <code>build-info</code> file</a></li>
<li><a href="#build-and-push-the-docker-images">Build and push the <code>docker</code> images</a></li>
<li><a href="#create-the-deployment-archive">Create the deployment archive</a></li>
<li><a href="#deployment-commands-on-the-vm">Deployment commands on the VM</a>
<ul>
<li><a href="#the-deploy-sh-script">The <code>deploy.sh</code> script</a></li>
</ul></li>
</ul></li>
<li><a href="#wrapping-up">Wrapping up</a></li>
</ul>
<!-- /toc -->
<!-- generated -->
<p><a id='introduction'> </a></p>
<!-- /generated -->
<h2>Introduction</h2>
<!-- generated -->
<p><a id='gcp'> </a></p>
<!-- /generated -->
<h2>GCP</h2>
<p>We will use <strong>GCP (Google Cloud Platform)</strong> to provide all the <strong>infrastructure required to run our
dockerized PHP application</strong>. For now, that's </p>
<ul>
<li>a <a href="#setup-the-container-registry">private Container Registry</a> to store our docker
images and </li>
<li>a <a href="#create-a-vm">VM to deploy them to</a></li>
</ul>
<p>In the process, we'll also learn about
<a href="#setup-a-gcp-project">GCP projects</a> as our own &quot;space&quot;
in GCP and <a href="#create-a-service-account">service accounts</a> a way communicate programmatically.</p>
<p><strong>CAUTION:</strong> Following the steps outlined in this tutorial <strong>will incur costs</strong>, because we will
create &quot;real&quot; infrastructure. It won't be much and it will very likely be covered by the free 300$
grant that you get when trying out GCP (or the general unlimited
<a href="https://cloud.google.com/free/docs/gcp-free-tier">GCP Free Tier</a>). </p>
<p>But you should still know about that upfront and <strong>make sure to shut everything down / delete
everything</strong> in case you're trying it out yourself.</p>
<p><strong>TODO add image of my costs</strong></p>
<!-- generated -->
<p><a id='setup-a-gcp-project'> </a></p>
<!-- /generated -->
<h3>Setup a GCP project</h3>
<p>On GCP, resources are organized under so called
<a href="https://cloud.google.com/resource-manager/docs/creating-managing-projects">projects</a>. We can
create a project via the <a href="https://console.cloud.google.com/projectcreate">Create Project UI</a>:</p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gpc-create-new-project.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gpc-create-new-project.PNG" alt="Create a new GCP project" /></a></p>
<p>The <strong>project ID</strong> must be a globally unique string and I have chosen <code>pl-dofroscra-p</code> for this
tutorial (<code>pl</code> =&gt; Pascal Landau; <code>dofroscra</code> =&gt; Docker From Scratch; <code>p</code> =&gt; production).</p>
<!-- generated -->
<p><a id='create-a-service-account'> </a></p>
<!-- /generated -->
<h3>Create a service account</h3>
<p>As a next step, we need a
<a href="https://cloud.google.com/iam/docs/service-accounts">service account</a>
that we can <strong>use to make API requests</strong>, because we don't want to use our &quot;personal GCP account&quot;.
Service accounts are created via the
<a href="https://console.cloud.google.com/iam-admin/serviceaccounts/create">IAM &amp; Admin &gt; Service Accounts UI</a>:</p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gpc-create-new-service-account.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gpc-create-new-service-account.PNG" alt="Create a new GCP service account" /></a></p>
<!-- generated -->
<p><a id='create-service-account-key-file'> </a></p>
<!-- /generated -->
<h4>Create service account key file</h4>
<p>In order to <strong>use the account programmatically</strong>, we also need to
<a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating">create a key file</a>
by choosing the &quot;Manage Keys&quot; option of the corresponding service account. </p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gpc-create-service-account-key-file.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gpc-create-service-account-key-file.PNG" alt="Create a new key file for a GCP service account UI" /></a></p>
<p>This will open up a UI at</p>
<pre><code class="language-text">https://console.cloud.google.com/iam-admin/serviceaccounts/details/$serviceAccountId/keys</code></pre>
<p>where <code>$serviceAccountId</code> is the id of the service account, e.g. <code>109548647107864470967</code>. To
create a key:</p>
<ul>
<li>click <code>"ADD KEY"</code> and select <code>"Create new key"</code> from the drop down menu
<ul>
<li>This will bring up a modal window to choose the key type. </li>
</ul></li>
<li>select the recommended JSON type and click <code>"Create"</code>. 
<ul>
<li>GCP will then <strong>generate a new key pair</strong>, store the public key and offer the private key file as
download. </li>
</ul></li>
<li>download the file and make sure to treat it like any other private key (ssh, gpg, ...)
i.e. <strong>never share it publicly</strong>!</li>
</ul>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-create-service-account-key-file.gif"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-create-service-account-key-file.gif" alt="Create a new key file for a GCP service account" /></a></p>
<p>We will <strong>store this file in the root of the codebase</strong> at <code>gcp-service-account-key.json</code> and add it
to the <code>.gitignore</code> file. </p>
<p>FYI: You can find the <strong>email address of the service account</strong> directly in the key file:</p>
<pre><code class="language-text">$ grep "email" ./gcp-service-account-key.json
  "client_email": "docker-php-tutorial-deployment@pl-dofroscra-p.iam.gserviceaccount.com",</code></pre>
<!-- generated -->
<p><a id='configure-iam-permissions'> </a></p>
<!-- /generated -->
<h4>Configure IAM permissions</h4>
<p><strong>IAM</strong> stands for <a href="https://cloud.google.com/iam/docs#docs">Identity and Access Management (IAM)</a>
and is used for <strong>managing permissions on GCP</strong>. The
<a href="https://cloud.google.com/iam/docs/understanding-roles">two core concepts are &quot;permissions&quot; and &quot;roles&quot;</a>:</p>
<ul>
<li><strong>permissions</strong> are fine grained for particular actions, e.g. <code>storage.buckets.create</code> to &quot;Create
Cloud Storage buckets&quot;</li>
<li><strong>roles</strong> combine a selection of permissions, e.g. the <code>Cloud Storage Admin</code> role has
permissions like
<ul>
<li><code>storage.buckets.create</code></li>
<li><code>storage.buckets.get</code></li>
<li>etc.</li>
</ul></li>
<li>roles are assigned to <strong>users</strong> (or service accounts)</li>
</ul>
<p>You can find a full overview of all permissions in the
<a href="https://cloud.google.com/iam/docs/permissions-reference">Permissions Reference</a> and all roles
under
<a href="https://cloud.google.com/iam/docs/understanding-roles#predefined">Understanding roles &gt; Predefined roles</a>.</p>
<p>For this tutorial, we'll assign the following roles to the service account &quot;user&quot;
<code>docker-php-tutorial-deployment@pl-dofroscra-p.iam.gserviceaccount.com</code>:</p>
<ul>
<li><code>Storage Admin</code> 
<ul>
<li>required to <a href="#pushing-images-to-the-registry">create the GCP bucket for the registry</a> and to
<a href="#pulling-images-from-the-registry">pull the images on the VM</a> </li>
</ul></li>
<li><code>Secret Manager Admin</code>
<ul>
<li>required <a href="#get-the-secret-gpg-key-and-password-from-the-secret-manager">retrieve secrets from the Secret Manager</a></li>
</ul></li>
<li><code>Compute Admin</code>, <code>Service Account User</code> and <code>IAP-secured Tunnel User</code>
<ul>
<li>are necessary for <a href="#additional-notes-on-iap">logging into a VM via IAP</a>.</li>
</ul></li>
</ul>
<p>Roles can be assigned through the
<a href="https://console.cloud.google.com/iam-admin/iam">Cloud Console IAM UI</a> by editing the
corresponding user.</p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-iam-permissions.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-iam-permissions.PNG" alt="Managing IAM permissions" /></a></p>
<p><strong>Caution:</strong> It might take some time (usually a couple of seconds) until the changes in the IAM
permissions take effect.</p>
<!-- generated -->
<p><a id='setup-the-gcloud-cli-tool'> </a></p>
<!-- /generated -->
<h3>Setup the <code>gcloud</code> CLI tool</h3>
<p>The <a href="https://cloud.google.com/sdk/gcloud">CLI tool for GCP is called <code>gcloud</code></a> and is
<a href="https://cloud.google.com/sdk/docs/install">available for all operation systems</a>.</p>
<p>In this tutorial we are using version <code>380.0.0</code> <strong>installed natively on Windows</strong> via the
<a href="https://dl.google.com/dl/cloudsdk/channels/rapid/GoogleCloudSDKInstaller.exe">GoogleCloudSDKInstaller.exe</a>
using the &quot;Bundled Python&quot; option.</p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcloud-installation-options.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcloud-installation-options.PNG" alt="Install `gcloud` on Windows" /></a></p>
<p>FYI: As described under
<a href="https://cloud.google.com/sdk/docs/uninstall-cloud-sdk">Uninstalling the Google Cloud CLI</a>
you can find the installation and config directories via</p>
<pre><code class="language-text"># installation directory
$ gcloud info --format='value(installation.sdk_root)'
C:\Users\Pascal\AppData\Local\Google\Cloud SDK\google-cloud-sdk

# config directory
$ gcloud info --format='value(config.paths.global_config_dir)'
C:\Users\Pascal\AppData\Roaming\gcloud</code></pre>
<p>I will <em>not</em> use my personal Google account to run <code>gcloud</code> commands, thus I'm <em>not</em> using the
&quot;usual&quot; initialization process
<a href="https://cloud.google.com/sdk/docs/initializing">by running <code>gcloud init</code></a>. Instead I will use
the <a href="#create-a-service-account">service account that we created previously</a> and activate it as
described under
<a href="https://cloud.google.com/sdk/gcloud/reference/auth/activate-service-account">gcloud auth activate-service-account</a>
via</p>
<pre><code class="language-bash">gcloud auth activate-service-account docker-php-tutorial-deployment@pl-dofroscra-p.iam.gserviceaccount.com --key-file=./gcp-service-account-key.json --project=pl-dofroscra-p</code></pre>
<p>Output</p>
<pre><code class="language-text">$ gcloud auth activate-service-account docker-php-tutorial-deployment@pl-dofroscra-p.iam.gserviceaccount.com --key-file=./gcp-service-account-key.json --project=pl-dofroscra-p
Activated service account credentials for: [docker-php-tutorial-deployment@pl-dofroscra-p.iam.gserviceaccount.com]</code></pre>
<!-- generated -->
<p><a id='setup-the-container-registry'> </a></p>
<!-- /generated -->
<h3>Setup the Container Registry</h3>
<p>Since we will use <code>docker compose</code> to run our PHP application, we need to <strong>make our docker images
available</strong> in a
<a href="https://www.redhat.com/en/topics/cloud-native-apps/what-is-a-container-registry">Container Registry</a>.
Luckily, <a href="https://cloud.google.com/container-registry">GCP offers a Container Registry product</a>
that gives us a <strong>ready-to-use private registry as part of a GCP project</strong>. Before we can use it,
the corresponding
<a href="https://console.cloud.google.com/marketplace/product/google/containerregistry.googleapis.com">Google Container Registry API must be enabled</a>:</p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-enable-container-registry-api.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-enable-container-registry-api.PNG" alt="Enable the GCP Container Registry API" /></a></p>
<p>You find the <strong>Container Registry</strong> in the Cloud Console UI under
<a href="https://console.cloud.google.com/gcr">Container Registry</a>.</p>
<!-- generated -->
<p><a id='authenticate-docker'> </a></p>
<!-- /generated -->
<h4>Authenticate docker</h4>
<p>Since the Container Registry is private, we <strong>need to authenticate before we can push our
docker images</strong>. The available authentication methods are described in the
[GCP docu &quot;Container Registry Authentication methods&quot;]. For pushing images from our local host
system, we will use <strong>the service account key file</strong> that we
<a href="#create-service-account-key-file">created previously</a> and run the command shown in the
<a href="https://cloud.google.com/container-registry/docs/advanced-authentication#json-key">&quot;JSON key file&quot; section</a>
of the the docu.</p>
<pre><code class="language-bash">key=./gcp-service-account-key.json
cat "$key" | docker login -u _json_key --password-stdin https://gcr.io</code></pre>
<p>A successful authentication looks as follows:</p>
<pre><code class="language-text">$ cat "$key" | docker login -u _json_key --password-stdin https://gcr.io
Login Succeeded

Logging in with your password grants your terminal complete access to your account.
For better security, log in with a limited-privilege personal access token. Learn more at https://docs.docker.com/go/access-tokens/</code></pre>
<p>So what exactly &quot;happens&quot; when we run this command? According to the
<a href="https://docs.docker.com/engine/reference/commandline/login/"><code>docker login</code>documentation</a></p>
<blockquote>
<p>When you log in, the command stores credentials in <code>$HOME/.docker/config.json</code>
on Linux or <code>%USERPROFILE%/.docker/config.json</code> on Windows
[...]</p>
<p>The Docker Engine can keep user credentials in an external credentials store,
such as the native keychain of the operating system.
[...]</p>
<p>You need to specify the credentials store in
<code>$HOME/.docker/config.json</code> to tell the docker engine to use it.
[...]</p>
<p>By default, Docker looks for the native binary on each of the platforms,
i.e. “osxkeychain” on macOS, “wincred” on windows, and “pass” on Linux.</p>
</blockquote>
<p>In other words: I <strong>won't be able to see the content of the service account key file in &quot;plain
text&quot;</strong> anywhere but docker will utilize the OS specific tools to store them securely. After I ran
the <code>docker login</code> command on Windows, I found the following content in <code>~/.docker/config.json</code>:</p>
<pre><code class="language-text">$ cat ~/.docker/config.json
{
        "auths": {
                "gcr.io": {}
        },
        "credsStore": "desktop"
}</code></pre>
<p>FYI: <code>"desktop"</code> seems to be a
<a href="https://forums.docker.com/t/docker-windows-desktop-credentials-location/107251">wrapper for the Wincred executable</a>.</p>
<!-- generated -->
<p><a id='pushing-images-to-the-registry'> </a></p>
<!-- /generated -->
<h4>Pushing images to the registry</h4>
<p>In order to push an image to a registry, <strong>the image name must be prefixed with the corresponding
registry</strong>. This was quite confusing to me, because I would have expected to be able to run
something like this:</p>
<pre><code class="language-bash">$ docker push dofroscra/nginx-local --registry=gcr.io

unknown flag: --registry
See 'docker push --help'.</code></pre>
<p>But nope, there is no such <code>--registry</code> option. Even worse: <strong>Omitting it would cause a push to
<code>docker.io</code></strong>, the &quot;default&quot; registry:</p>
<pre><code class="language-text">$ docker push dofroscra/nginx-local
Using default tag: latest
The push refers to repository [docker.io/dofroscra/nginx-local]</code></pre>
<p>According to
<a href="https://cloud.google.com/container-registry/docs/pushing-and-pulling">the GCP docs on Pushing and pulling images</a>,
the following steps are necessary to push an image to a GCP registry:</p>
<blockquote>
<ul>
<li><strong>Tag</strong> the image with its target path in Container Registry, including the gcr.io registry
host and the project ID my-project</li>
<li><strong>Push</strong> the image to the registry</li>
</ul>
</blockquote>
<p>In our case <strong>the target path to our Container Registry</strong> is</p>
<pre><code class="language-text">gcr.io/pl-dofroscra-p</code></pre>
<p>as <code>pl-dofroscra-p</code> is the <a href="#setup-a-gcp-project">id of the GCP project we created previously</a>.</p>
<p>The <strong>full image name</strong> becomes</p>
<pre><code class="language-text">gcr.io/pl-dofroscra-p/dofroscra/nginx-local </code></pre>
<p>To actually push the <code>dofroscra/nginx-local</code> image, we must first <strong>&quot;add another name&quot;</strong> to it via
<a href="https://docs.docker.com/engine/reference/commandline/tag/"><code>docker tag</code></a> </p>
<pre><code class="language-text">$ docker tag dofroscra/nginx-local gcr.io/pl-dofroscra-p/dofroscra/nginx-local

$ docker image ls
REPOSITORY                                    TAG                IMAGE ID       CREATED          SIZE
dofroscra/nginx-local                         latest             ba7a2c5faf0d   15 minutes ago   23.5MB
gcr.io/pl-dofroscra-p/dofroscra/nginx-local   latest             ba7a2c5faf0d   15 minutes ago   23.5MB</code></pre>
<p>and <strong>push that name afterwards</strong></p>
<pre><code class="language-text">$ docker push gcr.io/pl-dofroscra-p/dofroscra/nginx-local
Using default tag: latest
The push refers to repository [gcr.io/pl-dofroscra-p/dofroscra/nginx-local]
134174afa9ad: Preparing
cb7b4430c52d: Preparing
419df8b60032: Preparing
0e835d02c1b5: Preparing
5ee3266a70bd: Preparing
3f87f0a06073: Preparing
1c9c1e42aafa: Preparing
8d3ac3489996: Preparing
8d3ac3489996: Waiting
3f87f0a06073: Waiting
1c9c1e42aafa: Waiting
cb7b4430c52d: Pushed
134174afa9ad: Pushed
419df8b60032: Pushed
5ee3266a70bd: Pushed
0e835d02c1b5: Pushed
8d3ac3489996: Layer already exists
3f87f0a06073: Pushed
1c9c1e42aafa: Pushed
latest: digest: sha256:0740591fb686227d8cdf4e42b784f634cbaf9f5caa6ee478e3bcc24aeef75d7f size: 1982</code></pre>
<p>You can then find the image in the
<a href="https://console.cloud.google.com/gcr?project=pl-dofroscra-p">UI of the Container Registry</a>:</p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-container-registry-image-example.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-container-registry-image-example.PNG" alt="Example of a pushed image in the Container Registry" /></a></p>
<p>Don't worry: We won't have to do the tagging every time before a push, because we will
<a href="#use-the-correct-image-names">set up <code>make</code> to use the correct name automatically</a> when building
the images.</p>
<!-- generated -->
<p><a id='images-are-stored-in-google-cloud-storage-buckets'> </a></p>
<!-- /generated -->
<h4>Images are stored in Google Cloud Storage buckets</h4>
<p>We <a href="#configure-iam-permissions">assigned the <code>Storage Admin</code> role to the service account previously</a>
that contains the <code>storage.buckets.create</code> permission. If we wouldn't have done that, the
following error would have occured:</p>
<pre><code class="language-text">denied: Token exchange failed for project 'pl-dofroscra-p'. Caller does not have permission 'storage.buckets.create'. To configure permissions, follow instructions at: https://cloud.google.com/container-registry/docs/access-control</code></pre>
<p>The Container Registry tries to <strong>store the docker images in a Google Cloud Storage bucket</strong> that
is created on the fly when the <strong>very first image is pushed</strong>, see
<a href="https://cloud.google.com/container-registry/docs/pushing-and-pulling#add-registry">the GCP docs on &quot;Adding a registry&quot;</a>:</p>
<blockquote>
<p>The first image push to a hostname triggers creation of the registry in a project
and the corresponding Cloud Storage storage bucket.
This initial push requires project-wide permissions to create storage buckets.</p>
</blockquote>
<p>You can find the bucket, that in my case is named <code>artifacts.pl-dofroscra-p.appspot.com</code>
in the <a href="https://console.cloud.google.com/storage">Cloud Storage UI</a>:</p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-cloud-storage-registry-images.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-cloud-storage-registry-images.PNG" alt="GCP Container Registry image location on Cloud Storage" /></a></p>
<p><strong>CAUTION</strong>: Make sure to <strong>delete this bucket once you are done with the tutorial</strong> - otherwise
<a href="https://cloud.google.com/storage/pricing">storage costs</a> will incur.</p>
<!-- generated -->
<p><a id='pulling-images-from-the-registry'> </a></p>
<!-- /generated -->
<h4>Pulling images from the registry</h4>
<p>According to the
<a href="https://cloud.google.com/container-registry/docs/pushing-and-pulling#pulling_images_from_a_registry">GCP docs to pull an image from the Container Registry</a>
we <a href="#authenticate-docker">need to be authenticated</a> with a user that
has the permissions of the
<a href="https://cloud.google.com/storage/docs/access-control/iam-roles#standard-roles"><code>Storage Object Viewer</code></a>
role to access the &quot;raw&quot; images. FYI: The <code>Storage Admin</code> role that we assigned previously has all
the permissions of the <code>Storage Object Viewer</code> role.</p>
<p>Then use the <strong>fully qualified image name</strong> as before:</p>
<pre><code class="language-bash">docker pull gcr.io/pl-dofroscra-p/dofroscra/nginx-local</code></pre>
<p>Output if the image is cached</p>
<pre><code class="language-text">$ docker pull gcr.io/pl-dofroscra-p/dofroscra/nginx-local
Using default tag: latest
latest: Pulling from pl-dofroscra-p/dofroscra/nginx-local
Digest: sha256:0740591fb686227d8cdf4e42b784f634cbaf9f5caa6ee478e3bcc24aeef75d7f
Status: Image is up to date for gcr.io/pl-dofroscra-p/dofroscra/nginx-local:latest
gcr.io/pl-dofroscra-p/dofroscra/nginx-local:latest</code></pre>
<p>or if doesn't exist</p>
<pre><code class="language-text">docker pull gcr.io/pl-dofroscra-p/dofroscra/nginx-local
Using default tag: latest
latest: Pulling from pl-dofroscra-p/dofroscra/nginx-local
59bf1c3509f3: Pull complete 
f3322597df46: Pull complete 
d09cf91cabdc: Pull complete 
3a97535ac2ef: Pull complete 
919ade35f869: Pull complete 
40e5d2fe5bcd: Pull complete 
c72acb0c83a5: Pull complete 
d6baa2bee4a5: Pull complete 
Digest: sha256:0740591fb686227d8cdf4e42b784f634cbaf9f5caa6ee478e3bcc24aeef75d7f
Status: Downloaded newer image for gcr.io/pl-dofroscra-p/dofroscra/nginx-local:latest
gcr.io/pl-dofroscra-p/dofroscra/nginx-local:latest</code></pre>
<!-- generated -->
<p><a id='setup-the-secret-manager'> </a></p>
<!-- /generated -->
<h3>Setup the Secret Manager</h3>
<p>Even though
<a href="/blog/git-secret-encrypt-repository-docker/">we use <code>git secret</code> to manage our secrets</a>, <strong>we
still need the <code>gpg</code> secret key</strong> for decryption. This key is &quot;a secret in itself&quot; and we will use
the <a href="https://cloud.google.com/secret-manager/docs">GCP Secret Manager</a> to store it and retrieve
it later from a VM. </p>
<p><strong>TODO: add link to &quot;retrieve from VM&quot;</strong></p>
<p>It can be managed from the <a href="https://console.cloud.google.com/security/secret-manager">Security &gt; Secret Manager UI</a>
once we have
<a href="https://console.cloud.google.com/marketplace/product/google/secretmanager.googleapis.com">enabled the Secret Manager API</a></p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-enable-secret-manager-api.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-enable-secret-manager-api.PNG" alt="Enable the GCP Secret Manager API" /></a></p>
<!-- generated -->
<p><a id='create-a-secret-via-the-ui'> </a></p>
<!-- /generated -->
<h4>Create a secret via the UI</h4>
<p>To create a secret:</p>
<ul>
<li>navigate to the <a href="https://console.cloud.google.com/security/secret-manager">Secret Manager UI</a>
and click the <code>"+ CREATE SECRET"</code> button</li>
<li>enter the <strong>secret name</strong> and <strong>secret value</strong> in the form (we can ignore the other advanced
settings like &quot;Replication policy&quot; and &quot;Encryption&quot; for now)
<ul>
<li>FYI: the secret name can only contain English letters (A-Z), numbers (0-9), dashes (-), and
underscores (_)</li>
</ul></li>
<li>click the &quot;CREATE SECRET&quot; button</li>
</ul>
<p>The following gif shows the creation of a secret named <code>my_secret_key</code> with the value
<code>my_secret_value</code>.</p>
<p><strong>TODO insert gif to create the secret</strong></p>
<!-- generated -->
<p><a id='view-a-secret-via-the-ui'> </a></p>
<!-- /generated -->
<h4>View a secret via the UI</h4>
<p>The <a href="https://console.cloud.google.com/security/secret-manager">Security &gt; Secret Manager UI</a>
lists all existing secrets. Clicking on a secret will lead you to the <strong>Secret Detail UI</strong> at the URL</p>
<pre><code class="language-text">https://console.cloud.google.com/security/secret-manager/secret/$secretName/versions</code></pre>
<p>e.g. for secret name <code>my_secret_key</code>:</p>
<pre><code class="language-text">https://console.cloud.google.com/security/secret-manager/secret/my_secret_key/versions</code></pre>
<p>The UI shows all <a href="https://cloud.google.com/secret-manager/docs/managing-secret-versions">versions of the secret</a>,
though we currently only have one. To view the actual secret value, click on the three dots in
the &quot;Actions&quot; column and select &quot;View secret value&quot;.</p>
<p><strong>TODO insert gif to view the secret</strong></p>
<!-- generated -->
<p><a id='retrieve-a-secret-via-the-gcloud-cli'> </a></p>
<!-- /generated -->
<h4>Retrieve a secret via the <code>gcloud</code> cli</h4>
<p>To retrieve a secret with a Service Account via the <code>gcloud</code> cli, it needs the permission
<code>secretmanager.versions.access</code>, that is part of the
<a href="https://cloud.google.com/iam/docs/understanding-roles#secret-manager-roles"><code>Secret Manager Secret Accessor</code></a>
role (as well as the <code>Secret Manager Admin</code> role). Let's first show all available secrets via</p>
<pre><code class="language-bash">gcloud secrets list</code></pre>
<pre><code class="language-text">$ gcloud secrets list
NAME           CREATED              REPLICATION_POLICY  LOCATIONS
my_secret_key  2022-05-15T05:38:11  automatic           -</code></pre>
<p>To &quot;see&quot; the value of <code>my_secret_key</code>, we must also define the corresponding version. All
versions can be listed via</p>
<pre><code class="language-bash">gcloud secrets versions list my_secret_key</code></pre>
<pre><code class="language-text">$ gcloud secrets versions list my_secret_key
NAME  STATE    CREATED              DESTROYED
1     enabled  2022-05-15T05:38:13  -</code></pre>
<p>The actual secret value for version <code>1</code> of <code>my_secret_key</code> is accessed via</p>
<pre><code class="language-bash">gcloud secrets versions access 1 --secret=my_secret_key</code></pre>
<pre><code class="language-text">$ gcloud secrets versions access 1 --secret=my_secret_key
my_secret_value</code></pre>
<!-- generated -->
<p><a id='add-the-secret-gpg-key-and-password'> </a></p>
<!-- /generated -->
<h4>Add the secret <code>gpg</code> key and password</h4>
<p>We have already
<a href="/blog/git-secret-encrypt-repository-docker/#create-gpg-key-pair">created another <code>gpg</code> key pair</a>
and
<a href="/blog/git-secret-encrypt-repository-docker/#adding-listing-and-removing-users">added the corresponding email to git secret</a>
when we set up the CI pipelines (see section
<a href="/blog/ci-pipeline-docker-php-gitlab-github/#add-a-password-protected-secret-gpg-key">Add a password-protected secret gpg key</a>)
and will do the same once more for the production environment via</p>
<pre><code class="language-bash">name="Production Deployment"
email="production@example.com"
passphrase=87654321
secret=.tutorial/secret-production-protected.gpg.example
public=.dev/gpg-keys/production-public.gpg
# export key pair
gpg --batch --gen-key &lt;&lt;EOF
Key-Type: 1
Key-Length: 2048
Subkey-Type: 1
Subkey-Length: 2048
Name-Real: $name
Name-Email: $email
Expire-Date: 0
Passphrase: $passphrase
EOF

# export the private key
gpg --output $secret --pinentry-mode=loopback --passphrase  "$passphrase" --armor --export-secret-key $email

# export the public key
gpg --armor --export $email &gt; $public</code></pre>
<p>You can find the secret key in the codebase at <code>.tutorial/secret-production-protected.gpg.example</code>
and the public key at <code>.dev/gpg-keys/production-public.gpg</code>.</p>
<p>I have also added the secret <code>gpg</code> key and password as secrets to the secret manager</p>
<p><strong>TODO insert screenshot</strong></p>
<!-- generated -->
<p><a id='gcp-vms-compute-instances'> </a></p>
<!-- /generated -->
<h3>GCP VMs: Compute Instances</h3>
<p>To run our application, <strong>we need a VM with a public IP address</strong> so that it can be reached from the
internet. VMs on GCP are called <a href="https://cloud.google.com/compute">Compute Instances</a> and can be
managed from the <a href="https://console.cloud.google.com/compute">Compute Instance UI</a> - though we
must first
<a href="https://console.cloud.google.com/marketplace/product/google/compute.googleapis.com">activate the Compute Instance API</a>.</p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-enable-compute-instance-api.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-enable-compute-instance-api.PNG" alt="Enable the GCP Compute Instance API" /></a></p>
<!-- generated -->
<p><a id='create-a-vm'> </a></p>
<!-- /generated -->
<h4>Create a VM</h4>
<p>We can simply create a new instance from the
<a href="https://console.cloud.google.com/compute/instancesAdd">Create an instance UI</a>.</p>
<!-- generated -->
<p><a id='general-vm-settings'> </a></p>
<!-- /generated -->
<h5>General VM settings</h5>
<p>We'll use the following settings:</p>
<ul>
<li>Name: <code>dofroscra-test</code> </li>
<li>Region <code>us-central1 (Iowa)</code> and Zone <code>us-central1-a</code></li>
<li>Machine family: <code>General Purpose &gt; E2 &gt; e2-micro (2 vCPU, 1 GB memory)</code> </li>
<li>Boot Disk: Debian GNU/Linux 10 (buster); 10 GB</li>
<li>Identity and API access: Choose the &quot;Docker PHP Tutorial deployment account&quot; service account
<a href="#create-a-service-account">that we created previously</a> </li>
<li>Firewall: Allow HTTP and HTTPS traffic</li>
</ul>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-instance-settings.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-instance-settings.PNG" alt="GCP instance settings" /></a></p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-instance-settings-service-account-firewall.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-instance-settings-service-account-firewall.PNG" alt="Additional GCP instance settings" /></a></p>
<!-- generated -->
<p><a id='the-role-of-the-service-account'> </a></p>
<!-- /generated -->
<h5>The role of the service account</h5>
<p>The <strong>service account</strong> that we have chosen in the previous step <strong>will be attached to the
Compute Instance</strong>. I.e. it will be available on the instance and <strong>we will have access to the
account when we log into the instance</strong>. Conveniently,
<a href="https://cloud.google.com/sdk/docs/install-sdk#installing_the_latest_version">the<code>gloud</code> cli is pre-installed on every compute instance</a>:</p>
<blockquote>
<p>If you're using an instance on Compute Engine, the gcloud CLI is installed by default.</p>
</blockquote>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcloud-cli-preinstalled-compute-instance.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcloud-cli-preinstalled-compute-instance.PNG" alt="The`gloud` cli is pre-installed on every compute instance" /></a></p>
<p>The exact rules for <strong>what the service account can do</strong> are described in the
<a href="https://cloud.google.com/compute/docs/access/service-accounts">Compute Engine docs for &quot;Service accounts&quot;</a>.
In short: The possible actions will be constrained by the
<a href="https://cloud.google.com/compute/docs/access/service-accounts#usingroles">IAM permissions of the service account</a> and the
<a href="https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam">Access scopes of the compute instance</a>
which are set as outlined in the
<a href="https://cloud.google.com/compute/docs/access/service-accounts#default_scopes">&quot;Default scopes&quot; section</a>.
Just take this and an aside, we won't have to modify anything here.</p>
<p>We will use the service account later,
<a href="#pulling-the-nginx-image">when we log into the compute instance and run <code>docker pull</code> from there</a>
to pull images from the registry.</p>
<!-- generated -->
<p><a id='adding-a-public-ssh-key'> </a></p>
<!-- /generated -->
<h5>Adding a public SSH key</h5>
<p>In addition, I <strong>added my own public <code>ssh</code> key</strong></p>
<pre><code class="language-text">ssh-rsa AAAAB3NzaC1yc2....6row== pascal.landau@MY_LAPTOP</code></pre>
<p><strong>CAUTION</strong>: The <strong>username</strong> for this key will be defined <strong>at the end of the key</strong>! E.g. in the
example above, the username would be <code>pascal.landau</code>. This is important for
<a href="#login-via-ssh-with-your-own-key-from-your-host-machine">logging in later via SSH from your local machine</a>.</p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-instance-settings-ssh-key.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-instance-settings-ssh-key.PNG" alt="Add SSH key to GCP instance settings" /></a></p>
<!-- generated -->
<p><a id='define-preemptibility'> </a></p>
<!-- /generated -->
<h5>Define Preemptibility</h5>
<p>We will make the instance <a href="https://cloud.google.com/compute/docs/instances/preemptible">preemptible</a>,
this makes it <strong>much cheaper</strong> but GCP &quot;might&quot; <strong>terminate the instance randomly</strong> if the
capacity is needed somewhere else (and definitely after 24 hours). This is completely fine for our
test use case. The final costs are ~2$ per month for this instance.</p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-instance-settings-preemptibility.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-instance-settings-preemptibility.PNG" alt="Set instance preemptibility" /></a></p>
<!-- generated -->
<p><a id='the-actual-vm-creation'> </a></p>
<!-- /generated -->
<h5>The actual VM creation</h5>
<p>Finally, click the <code>"Create"</code> button at the bottom of the page</p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-instance-settings-create.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-instance-settings-create.PNG" alt="Create the GCP instance" /></a></p>
<p>Once the instance is created, you can see it in the
<a href="https://console.cloud.google.com/compute/instances">Compute Instances &gt; VM instances UI</a></p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-instance-overview.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-instance-overview.PNG" alt="Compute instance overview" /></a></p>
<p>Next to the instance name <code>dofroscra-test</code> we can see the external IP address <code>35.192.212.130</code>
Opening it in a browser via <code>http://35.192.212.130/</code> won't show anything though, because we
didn't deploy the application yet.</p>
<p><strong>CAUTION</strong>: Make sure to <strong>shutdown and remove this instance by the end of the tutorial</strong> - otherwise
<a href="https://cloud.google.com/compute/all-pricing">compute costs</a> will incur.</p>
<!-- generated -->
<p><a id='log-into-a-vm'> </a></p>
<!-- /generated -->
<h4>Log into a VM</h4>
<p>There are multiple ways <strong>to log into the VM / Compute Instance</strong> outlined in
<a href="https://cloud.google.com/compute/docs/instances/connecting-advanced">Connecting to Linux VMs using advanced methods</a>.</p>
<p>I'm going to describe three of them:</p>
<ul>
<li><a href="#login-via-ssh-from-the-gcp-ui">Login via SSH from the GCP UI</a></li>
<li><a href="#login-via-ssh-with-your-own-key-from-your-host-machine">Login via SSH with your own key from your host machine</a></li>
<li><a href="#login-using-the-identity-aware-proxy-iap-concept">Login using the Identity-Aware Proxy (IAP) concept</a></li>
</ul>
<!-- generated -->
<p><a id='login-via-ssh-from-the-gcp-ui'> </a></p>
<!-- /generated -->
<h5>Login via SSH from the GCP UI</h5>
<p>Probably the easiest way to log in: Simply <strong>click the <code>"SSH"</code> button</strong> in the
<a href="https://console.cloud.google.com/compute/instances">Compute Instances &gt; VM instances UI</a> <strong>next
to the instance you want to log in</strong>. This will <strong>create a web shell</strong> that uses an ephemeral SSH key
according to the <a href="https://cloud.google.com/compute/docs/instances/connecting-to-instance#connect_to_vms">GCP documentation: Connect to Linux VMs &gt; Connect to VMs</a></p>
<blockquote>
<p>When you connect to VMs using the Cloud Console, Compute Engine creates an ephemeral SSH key for you.</p>
</blockquote>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-ssh-login-web-shell.gif"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-ssh-login-web-shell.gif" alt="Connect via Cloud Console UI" /></a></p>
<!-- generated -->
<p><a id='login-via-ssh-with-your-own-key-from-your-host-machine'> </a></p>
<!-- /generated -->
<h5>Login via SSH with your own key from your host machine</h5>
<p>This method is probably closest to what you are used to from working with &quot;other&quot; VMs. In this
case, <strong>the instance has to be publicly available</strong> (i.e. reachable &quot;from the internet&quot;) and
<strong>expose a port for SSH connections</strong> (usually <code>22</code>). In addition, your public SSH key needs to be
deployed.</p>
<p>All of those requirements are true
<a href="#create-a-vm">for the Compute Instance that we just created</a>:</p>
<ul>
<li>the public ip address is <code>35.192.212.130</code></li>
<li>port <code>22</code> is open by default via the <code>default-allow-ssh</code> firewall rule, see
<a href="https://geekflare.com/gcp-firewall-configuration/">How to Configure Firewall Rules in Google Cloud Platform</a>
and the <a href="https://cloud.google.com/compute/docs/troubleshooting/troubleshooting-ssh">official documentation on Troubleshooting SSH</a>
<blockquote>
<p>By default, Compute Engine VMs allow SSH access on port 22.</p>
</blockquote></li>
<li>we <a href="#adding-a-public-ssh-key">added our public SSH key</a> using <code>pascal.landau</code> as the username</li>
</ul>
<p>So we can now simply login via </p>
<pre><code class="language-bash">ssh pascal.landau@35.192.212.130</code></pre>
<p>or if you need to specify the location of the private key via the <code>-i</code> option</p>
<pre><code class="language-bash">ssh -i ~/.ssh/id_rsa pascal.landau@35.192.212.130</code></pre>
<pre><code class="language-text">$ ssh pascal.landau@35.192.212.130
Linux dofroscra-test 4.19.0-20-cloud-amd64 #1 SMP Debian 4.19.235-1 (2022-03-17) x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Sun Apr 10 16:21:00 2022 from 54.74.228.207
pascal.landau@dofroscra-test:~$</code></pre>
<!-- generated -->
<p><a id='login-using-the-identity-aware-proxy-iap-concept'> </a></p>
<!-- /generated -->
<h5>Login using the Identity-Aware Proxy (IAP) concept</h5>
<p>To <strong>login via IAP</strong> we need the <a href="#setup-the-gcloud-cli-tool"><code>gcloud</code> CLI</a> that will <strong>use API
requests (via HTTPS) under the hood to authenticate our Google</strong> user and then proxy the
requests to the VM via
<a href="https://cloud.google.com/iap/docs/concepts-overview">GCP's Identity-Aware Proxy (IAP)</a>
as described in
<a href="https://cloud.google.com/compute/docs/instances/connecting-advanced#cloud_iap">Connecting through Identity-Aware Proxy (IAP) for TCP</a>
and in more detail under
<a href="https://cloud.google.com/iap/docs/using-tcp-forwarding#tunneling_ssh_connections">Using IAP for TCP forwarding &gt; Tunneling SSH connections</a>.</p>
<p>The corresponding command is</p>
<pre><code class="language-bash">gcloud compute ssh dofroscra-test --zone us-central1-a --tunnel-through-iap</code></pre>
<p>(Note the
<a href="https://cloud.google.com/sdk/gcloud/reference/compute/ssh#--tunnel-through-iap">--tunnel-through-iap</a>
flag)</p>
<p>Output</p>
<pre><code class="language-text">$ gcloud compute ssh dofroscra-test --zone us-central1-a --tunnel-through-iap
WARNING: The private SSH key file for gcloud does not exist.
WARNING: The public SSH key file for gcloud does not exist.
WARNING: The PuTTY PPK SSH key file for gcloud does not exist.
WARNING: You do not have an SSH key for gcloud.
WARNING: SSH keygen will be executed to generate a key.
Updating project ssh metadata...
..............................................Updated [https://www.googleapis.com/compute/v1/projects/pl-dofroscra-p].
.done.
Waiting for SSH key to propagate.</code></pre>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-ssh-login-iap.gif"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-ssh-login-iap.gif" alt="Connect via IAP" /></a></p>
<p>Under the hood, this command will <strong>automatically create an SSH key pair</strong> on your local machine under
<code>~/.ssh/</code> named <code>google_compute_engine</code> (unless they already exist) and upload the public key
to the instance.</p>
<pre><code class="language-text">$ ls -l ~/.ssh/ | grep google_compute_engine
-rw-r--r-- 1 Pascal 197121 1675 Apr 11 09:25 google_compute_engine
-rw-r--r-- 1 Pascal 197121 1456 Apr 11 09:25 google_compute_engine.ppk
-rw-r--r-- 1 Pascal 197121  420 Apr 11 09:25 google_compute_engine.pub</code></pre>
<p>It also opens a <a href="https://www.putty.org/"><code>Putty</code> session</a> logged in the instance:</p>
<pre><code class="language-text">Using username "Pascal".
Authenticating with public key "LAPTOP-0DNL2Q02\Pascal@LAPTOP-0DNL2Q02"
Linux dofroscra-test 4.19.0-20-cloud-amd64 #1 SMP Debian 4.19.235-1 (2022-03-17) x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Mon Apr 11 07:22:32 2022 from 54.74.228.207
Pascal@dofroscra-test:~$</code></pre>
<p><strong>Caution</strong>: The <code>Putty</code> session will be closed automatically when you abort the original
<code>gcloud compute ssh</code> command!</p>
<!-- generated -->
<p><a id='additional-notes-on-iap'> </a></p>
<!-- /generated -->
<h6>Additional notes on IAP</h6>
<p>In order to <strong>enable SSH connections via IAP</strong>, our service account needs the following
<a href="#configure-iam-permissions">IAM roles</a>:</p>
<ul>
<li><a href="https://cloud.google.com/compute/docs/access/iam#compute.instanceAdmin.v1"><code>roles/compute.instanceAdmin.v1</code></a>, role: <code>Compute Admin</code></li>
<li><a href="https://cloud.google.com/compute/docs/access/iam#the_serviceaccountuser_role"><code>roles/iam.serviceAccountUser</code></a>, role: <code>Service Account User</code></li>
<li><a href="https://cloud.google.com/iam/docs/understanding-roles#cloud-iap-roles"><code>roles/iap.tunnelResourceAccessor</code></a>, role: <code>IAP-secured Tunnel User</code></li>
</ul>
<p>Otherwise you might run into a couple of errors like:</p>
<pre><code class="language-text">ERROR: (gcloud.compute.ssh) Could not fetch resource:
 - Required 'compute.instances.get' permission for 'projects/pl-dofroscra-p/zones/us-central1-a/instances/dofroscra-test'</code></pre>
<p>(<code>roles/compute.instanceAdmin.v1</code> missing)</p>
<pre><code class="language-text">ERROR: (gcloud.compute.ssh) Could not add SSH key to instance metadata:
 - The user does not have access to service account 'docker-php-tutorial-deployment@pl-dofroscra-p.iam.gserviceaccount.com'.  User: 'docker-php-tutorial-deployment@pl-dofroscra-p.iam.gserviceaccount.com'.  Ask a project owner to grant you the iam.serviceAccountUser role on the service account</code></pre>
<p>(<a href="https://cloud.google.com/compute/docs/access/iam#the_serviceaccountuser_role"><code>roles/iam.serviceAccountUser</code> missing</a>)</p>
<pre><code class="language-text">Remote side unexpectedly closed connection</code></pre>
<p>(<code>roles/iap.tunnelResourceAccessor</code> missing)</p>
<p>The general &quot;flow&quot; looks likes this</p>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-iap-concept.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-iap-concept.PNG" alt="Connection flow when using Identity-Aware Proxy (IAP)" /></a></p>
<p>Using IAP might look overly complicated at first, but it offers <strong>a number of benefits</strong>:</p>
<ul>
<li>we can leverage <strong>Google's authentication system</strong> and the powerful
<a href="#configure-iam-permissions">IAM permission management</a> to manage permissions - no more need
to deploy custom SSH keys to the VMs</li>
<li>we <strong>don't need a public IP address</strong> any longer - this is nice, because only the <code>nginx</code>
container should be accessible publicly</li>
</ul>
<!-- generated -->
<p><a id='run-docker-containers'> </a></p>
<!-- /generated -->
<h4>Run <code>docker</code> containers</h4>
<p>The final goal of this tutorial is <strong>running the whole application via <code>docker compose</code></strong> -
essentially the same way as we do locally (though the codebase will live in the images instead
of being shared with the host). But as a first step let's start with the <code>nginx</code> image that
we <a href="#pushing-images-to-the-registry">pushed previously</a> to get a feeling for the necessary steps.</p>
<!-- generated -->
<p><a id='installing-docker-and-docker-compose'> </a></p>
<!-- /generated -->
<h5>Installing <code>docker</code> and <code>docker compose</code></h5>
<p>Since we <a href="#general-vm-settings">created the VM with a Debian OS</a>, we'll follow the
<a href="https://docs.docker.com/engine/install/debian/">official Debian installation instructions for Docker Engine</a>
and run the following commands while we are logged into the VM:</p>
<pre><code class="language-bash"># install required tools
sudo apt-get update -yq &amp;&amp; apt-get install -yq \
     ca-certificates \
     curl \
     gnupg \
     lsb-release

# add Docker’s official GPG key
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# set up the stable repository
echo \
 "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \
 $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null

# install Docker Engine
sudo apt-get update -yq &amp;&amp; sudo apt-get install -yq \ 
     docker-ce \ 
     docker-ce-cli \ 
     containerd.io \ 
     docker-compose-plugin</code></pre>
<p>Afterwards we check via </p>
<pre><code class="language-bash">docker --version
docker compose version</code></pre>
<p>if <code>docker</code> and <code>docker compose</code> are available</p>
<pre><code class="language-text">$ docker --version
Docker version 20.10.15, build fd82621

$ docker compose version
Docker Compose version v2.5.0</code></pre>
<!-- generated -->
<p><a id='authenticate-docker-via-gcloud'> </a></p>
<!-- /generated -->
<h5>Authenticate docker via <code>gcloud</code></h5>
<p>I recommend running the commands as <code>root</code> via</p>
<pre><code class="language-bash">sudo -i</code></pre>
<pre><code class="language-text">pascal_landau@dofroscra-test:~$ sudo -i
root@dofroscra-test:~# </code></pre>
<p>Otherwise, we might run into docker permission errors like</p>
<pre><code class="language-text">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post "http://%2Fvar%2Frun%2Fdocker.sock/v1.24/images/create?fromImage=...": dial unix /var/run/docker.sock: connect: permission denied</code></pre>
<p>(FYI: As an alternative we could also add the user to the <code>docker</code> group)</p>
<p>We'll start by authenticating docker via the
<a href="#the-role-of-the-service-account">pre-installed <code>gcloud</code> cli and the attached service account</a>
as described in the
<a href="https://cloud.google.com/container-registry/docs/advanced-authentication#gcloud-helper">GCP docs for the Container Registry Authentication methods under section &quot;gcloud credential helper&quot;</a></p>
<pre><code class="language-bash">gcloud auth configure-docker --quiet</code></pre>
<pre><code class="language-text">Adding credentials for all GCR repositories.
WARNING: A long list of credential helpers may cause delays running 'docker build'. We recommend passing the registry name to configure only the registry you are using.
Docker configuration file updated.</code></pre>
<p>This creates the file <code>/root/.docker/config.json</code> that we already encountered when we
<a href="#authenticate-docker">authenticated docker locally to push images</a>.
In this case it has the following content</p>
<pre><code class="language-text">$cat /root/.docker/config.json
{
  "credHelpers": {
    "gcr.io": "gcloud",
    "us.gcr.io": "gcloud",
    "eu.gcr.io": "gcloud",
    "asia.gcr.io": "gcloud",
    "staging-k8s.gcr.io": "gcloud",
    "marketplace.gcr.io": "gcloud"
  }
}</code></pre>
<p>The <a href="https://docs.docker.com/engine/reference/commandline/login/#credential-helpers"><code>creadHelpers</code> are described in the <code>docker login</code> docs</a></p>
<blockquote>
<p>Credential helpers are similar to the credential store above, but act as the <strong>designated
programs to handle credentials</strong> for specific registries. The <strong>default credential store</strong>
(credsStore or the config file itself) <strong>will not be used</strong> for operations concerning
credentials of the specified registries.</p>
</blockquote>
<p>In other words: </p>
<ul>
<li>we are using <code>gcr.io</code> as registry</li>
<li>this registry is defined to use the credential helper <code>gcloud</code></li>
<li>i.e. it will use the pre-initialized <code>gcloud</code> cli for authentication</li>
</ul>
<!-- generated -->
<p><a id='pulling-the-nginx-image'> </a></p>
<!-- /generated -->
<h5>Pulling the <code>nginx</code> image</h5>
<p>Once we are authenticated, we can simply run <code>docker pull</code> with the full image name to retrieve the
<code>nginx</code> image that we <a href="#pushing-images-to-the-registry">pushed previously</a></p>
<pre><code class="language-bash">docker pull gcr.io/pl-dofroscra-p/dofroscra/nginx-local</code></pre>
<pre><code class="language-text">$ docker pull gcr.io/pl-dofroscra-p/dofroscra/nginx-local
Using default tag: latest
latest: Pulling from pl-dofroscra-p/dofroscra/nginx-local
59bf1c3509f3: Pull complete 
f3322597df46: Pull complete 
d09cf91cabdc: Pull complete 
3a97535ac2ef: Pull complete 
919ade35f869: Pull complete 
40e5d2fe5bcd: Pull complete 
c72acb0c83a5: Pull complete 
d6baa2bee4a5: Pull complete 
Digest: sha256:0740591fb686227d8cdf4e42b784f634cbaf9f5caa6ee478e3bcc24aeef75d7f
Status: Downloaded newer image for gcr.io/pl-dofroscra-p/dofroscra/nginx-local:latest
gcr.io/pl-dofroscra-p/dofroscra/nginx-local:latest</code></pre>
<p>If we wouldn't have been authenticated, we would run into the following error</p>
<pre><code class="language-text">$ docker pull gcr.io/pl-dofroscra-p/dofroscra/nginx-local
Using default tag: latest
Error response from daemon: unauthorized: You don't have the needed permissions to perform this operation, and you may have invalid credentials. To authenticate your request, follow the steps in: https://cloud.google.com/container-registry/docs/advanced-authentication</code></pre>
<!-- generated -->
<p><a id='start-the-nginx-container'> </a></p>
<!-- /generated -->
<h5>Start the <code>nginx</code> container</h5>
<p>For now we will simply run the <code>nginx</code> container via <code>docker run</code></p>
<pre><code class="language-bash">docker run --name nginx -p 80:80 --add-host=php-fpm:127.0.0.1 --rm -d gcr.io/pl-dofroscra-p/dofroscra/nginx-local:latest</code></pre>
<p>We</p>
<ul>
<li><strong>give it the name <code>nginx</code></strong> so we can easily reference it later via <code>--name nginx</code></li>
<li><strong>map port <code>80</code> from the host to port <code>80</code> of the container</strong> so that HTTP requests to the
VM are handled via the container via <code>-p 80:80</code>,
see <a href="https://docs.docker.com/engine/reference/commandline/run/#publish-or-expose-port--p---expose">Docker docs on &quot;Publish or expose port (-p, --expose)&quot;</a></li>
<li><strong>add a hosts entry for <code>php-fpm</code></strong> via <code>--add-host=php-fpm:127.0.0.1</code>
(see <a href="https://docs.docker.com/engine/reference/commandline/run/#add-entries-to-container-hosts-file---add-host">Docker docs on  &quot;Add entries to container hosts file (--add-host)&quot;</a>),<br />
because we defined <code>php-fpm</code> as a backend to handle PHP requests. But
<ul>
<li>there is no <code>php-fpm</code> container yet (we only pulled <code>nginx</code> for now)</li>
<li>we don't use <code>docker compose</code>, i.e. the host name <code>php-fpm</code> doesn't resolve to anything
(see <a href="https://www.pascallandau.com/blog/structuring-the-docker-setup-for-php-projects/#nginx">the configuration of the <code>nginx</code> service</a>)
<blockquote>
<p>php-fpm will resolve to the php-fpm container, because we use php-fpm as the service name in the
docker-compose file, so it will be
<a href="https://docs.docker.com/compose/compose-file/#aliases">automatically used as the hostname</a></p>
</blockquote></li>
</ul></li>
<li>make it <strong>run in the background</strong> via <code>-d</code> (<code>--detach</code>) and **remove it after shutdown
automatically via <code>-rm</code> (<code>--remove</code>)</li>
</ul>
<p>Output</p>
<pre><code class="language-text">root@dofroscra-test:~# docker run -p 80:80 --add-host=php-fpm:127.0.0.1 -d --name nginx gcr.io/pl-dofroscra-p/dofroscra/nginx-local:latest
dd49bedad97c06f698d06a140c5091c04ad81b2f75632e222927e7f71cf28c18

root@dofroscra-test:~# docker logs nginx
/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf
10-listen-on-ipv6-by-default.sh: info: /etc/nginx/conf.d/default.conf differs from the packaged version
/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh
/docker-entrypoint.sh: Configuration complete; ready for start up
2022/05/08 12:01:43 [notice] 1#1: using the "epoll" event method
2022/05/08 12:01:43 [notice] 1#1: nginx/1.21.5
2022/05/08 12:01:43 [notice] 1#1: built by gcc 10.3.1 20211027 (Alpine 10.3.1_git20211027) 
2022/05/08 12:01:43 [notice] 1#1: OS: Linux 4.19.0-20-cloud-amd64
2022/05/08 12:01:43 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576
2022/05/08 12:01:43 [notice] 1#1: start worker processes
2022/05/08 12:01:43 [notice] 1#1: start worker process 30
2022/05/08 12:01:43 [notice] 1#1: start worker process 31</code></pre>
<p>FYI: Without <code>--add-host=php-fpm:127.0.0.1</code>, we'd run into the following error and
wouldn't be able to start the container.</p>
<pre><code class="language-text">2022/05/08 11:59:53 [emerg] 1#1: host not found in upstream "php-fpm" in /etc/nginx/conf.d/default.conf:18
nginx: [emerg] host not found in upstream "php-fpm" in /etc/nginx/conf.d/default.conf:18</code></pre>
<!-- generated -->
<p><a id='make-an-http-request'> </a></p>
<!-- /generated -->
<h6>Make an HTTP request</h6>
<p>Technically, we're <strong>all set to serve HTTP requests</strong> via <code>http://35.239.69.58/</code>: The request will
be answered by the <code>nginx</code> container - though <strong>it will show an error</strong>, because <code>nginx</code> will
forward the request to the <code>php-fpm</code> backend which currently isn't a <code>php-fpm</code> service at all:</p>
<pre><code class="language-text">$ curl http://35.239.69.58/
&lt;html&gt;
&lt;head&gt;&lt;title&gt;502 Bad Gateway&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;center&gt;&lt;h1&gt;502 Bad Gateway&lt;/h1&gt;&lt;/center&gt;
&lt;hr&gt;&lt;center&gt;nginx/1.21.5&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>I would really like to see a successful response - just to <strong>ensure that the <code>nginx</code> container
setup is working as expected</strong>. The easiest way to achieve that is <strong>putting a file in the
root directory</strong> as defined by the <code>nginx</code> config, because it will <strong>serve any files that are
located in the file system of the nginx container directly</strong> (instead of passing the request to
the <code>php-fpm</code> backend).</p>
<p>I've added comments to the corresponding places of the <code>nginx</code> config file:</p>
<pre><code># File: .docker/images/nginx/conf.d/default.conf

server {
    listen 80 default_server;

    # Note: __NGINX_ROOT was replaced by /var/www/app/public in the .docker/images/nginx/Dockerfile
    root mkdir -p /var/www/app/public

    # If a file exists serve it directly - otherwise append ".php" and ...
    location / {
        try_files $uri $uri/ /index.php$is_args$args;
    }

    # ... pass the request to php-fpm
    location ~ \.php$ {
        fastcgi_pass php-fpm:9000;
        # ...
    }
}</code></pre>
<p>In order to create a file, I'll</p>
<ul>
<li>log into the container
<pre><code class="language-bash">docker exec -it nginx sh</code></pre></li>
<li>create the <code>/var/www/app/public</code> directory
<pre><code class="language-bash">mkdir -p /var/www/app/public</code></pre></li>
<li>create a <code>foo.txt</code> file 
<pre><code>echo "Hello world" &gt; /var/www/app/public/foo.txt</code></pre></li>
</ul>
<pre><code class="language-text">$ docker exec -it nginx sh

/ # mkdir -p /var/www/app/public
/ # echo "Hello world" &gt; /var/www/app/public/foo.txt</code></pre>
<p>Requesting <code>http://35.239.69.58/foo.txt</code> now yields a successful response</p>
<pre><code class="language-text">$ curl http://35.239.69.58/foo.txt
Hello world</code></pre>
<p><a href="/img/deploy-docker-compose-php-gcp-poc/gcp-nginx-successful-request.PNG"><img src="/img/deploy-docker-compose-php-gcp-poc/gcp-nginx-successful-request.PNG" alt="Successful response from the nginx container " /></a></p>
<!-- generated -->
<p><a id='get-the-secret-gpg-key-and-password-from-the-secret-manager'> </a></p>
<!-- /generated -->
<h5>Get the secret <code>gpg</code> key and password from the Secret Manager</h5>
<p>We will need the secret <code>gpg</code> key and its password to decrypt the secrets in the <code>php</code> containers.
We have already <a href="#add-the-secret-gpg-key-and-password">added the them previously</a> and can now
retrieve them as explained under section
<a href="#retrieve-a-secret-via-the-gcloud-cli">Retrieve a secret via the <code>gcloud</code> cli</a> via</p>
<pre><code class="language-bash">gcloud secrets versions access 1 --secret=GPG_KEY &gt; secret.gpg

GPG_PASSWORD=$(gcloud secrets versions access 1 --secret=GPG_PASSWORD)</code></pre>
<pre><code class="language-text">$ gcloud secrets versions access 1 --secret=GPG_KEY &gt; secret.gpg
$ head secret.gpg
-----BEGIN PGP PRIVATE KEY BLOCK-----

lQPGBGKA1psBCACq5zYDT587CVZEIWXbUplfAGQZOQJALmzErYpTp0jt+rp4vJhR
U5xahy3pqCq81Cnny5YME50ybB3pW/WcHxWLBDo+he8PKeLbp6wFFjJns+3u4opH
9gFMElyHpzTGiDQYfx/CgY2hKz7GSqpjmnOaKxYvGv0EsbZczyHY1WIN/YFzb0tI
tY7J4zTSH05I+aazRdHyn28QcCRcIT9+4q+5Vk8gz8mmgoqVpyeNgQcqJjcd03iP
WUZd1vZCumOvdG5PZNlc/wPFhqLDmYyLmJ7pt5bWIgty9BjYK8Z2NOdUaekqVEJ+
r29HbzwgFLLE2gd52f07h2y2YgMdWdz4FDxVABEBAAH+BwMC9veBYT2oigXxExLl
7fZKVjw02lEr1NpYd5X1ge9WPU/1qumATJWounzciiETpsYGsbPd9zFRJP4E3JZl
sFSh4p0/kXYTuenYD8wgGkeYyN4lm53IHfqSn2z9JMW5Kz9XEODtKJl8fjcn9Zeb

$ GPG_PASSWORD=$(gcloud secrets versions access 1 --secret=GPG_PASSWORD)
$ echo $GPG_PASSWORD
87654321</code></pre>
<!-- generated -->
<p><a id='codebase-changes'> </a></p>
<!-- /generated -->
<h2>Codebase changes</h2>
<!-- generated -->
<p><a id='restructure-the-codebase'> </a></p>
<!-- /generated -->
<h3>Restructure the codebase</h3>
<!-- generated -->
<p><a id='the-build-directory'> </a></p>
<!-- /generated -->
<h4>The <code>.build</code> directory</h4>
<p>We already know this directory from the previous tutorial where we used it as a temporary directory
<a href="/blog/ci-pipeline-docker-php-gitlab-github/#create-a-junit-report-from-phpunit">to collect build artifacts from the CI pipeline</a>.
Now, we will make use of it again as a temporary directory to</p>
<ul>
<li>prepare <a href="#create-the-deployment-archive">the creation of the deployment archive</a></li>
<li>create a <a href="#the-build-info-file"><code>build-info</code> file</a> to pass it to the <code>docker</code> daemon in the build context</li>
</ul>
<p>The files in the directory are ignored via <code>.gitignore</code> as they are only temporarily required</p>
<pre><code class="language-gitignore"># File: .gitignore

.build/*</code></pre>
<p>However, since the <code>build-info</code> file must be passed to docker, we will have a slight deviation
between the <code>.gitignore</code> and the <code>.dockerignore</code> file.</p>
<pre><code class="language-dockerignore"># File: .dockerignore

.build/*

# kept files
!.build/build-info</code></pre>
<p>I'm mentioning this here specifically, because we usually
<a href="/blog/ci-pipeline-docker-php-gitlab-github/#dockerignore">strive for a parity between <code>.gitignore</code> and <code>.dockerignore</code></a>.</p>
<!-- generated -->
<p><a id='the-secrets-directory'> </a></p>
<!-- /generated -->
<h4>The <code>.secrets</code> directory</h4>
<p>Since we will store <em>all</em> secrets for <em>all</em> environments in the codebase, <strong>we will organize them
by environment</strong> as subdirectories in a new <code>.secrets</code> directory:</p>
<pre><code class="language-text">.secrets/
├── ci
│     └── ci-secret.txt.secret
├── prod
│     ├── app.env.secret
│     └── docker.env.secret
└── shared
    └── passwords.txt.secret</code></pre>
<p>This will also make it easier to
<a href="#remove-secrets-for-other-environments">pick the correct files per environment when building the docker image</a>
and
<a href="#decrypt-the-secrets-via-entrypoint">select them for decryption in the <code>ENTRYPOINT</code></a>.</p>
<p>The <code>.secrets/shared/</code> directory contains all secret files that are required by <em>all</em>
environments, whereas <code>.secrets/ci/</code> contains only <code>ci</code> secrets and <code>.secrets/prod/</code> contains only
<code>prod</code> secrets, respectively.</p>
<p>In our codebase there are already <strong>two files that contain actual secrets</strong>: The <code>.env</code> file and
the <code>.docker/.env</code> file. Both of them contain the credentials for <code>mysql</code> and <code>redis</code>, and the
<code>.env</code> file also contains the <code>APP_KEY</code> that
<a href="https://tighten.com/blog/app-key-and-you/">is used by Laravel to encrypt cookies</a></p>
<blockquote>
<p>Laravel uses the [<code>APP_KEY</code>] for all encrypted cookies, including the session cookie, before
handing them off to the user's browser, and it uses it to decrypt cookies read from the browser.</p>
</blockquote>
<pre><code class="language-dotenv"># File: .env

APP_KEY=base64:C8X1hLE2bpok8OS+bJ1cTB9wNASJNRLibqUrDq2ls4Q=
DB_PASSWORD=production_secret_mysql_root_password
REDIS_PASSWORD=production_secret_redis_password</code></pre>
<pre><code class="language-dotenv"># File: .docker/.env

MYSQL_PASSWORD=production_secret
MYSQL_ROOT_PASSWORD=production_secret_mysql_root_password
REDIS_PASSWORD=production_secret_redis_password</code></pre>
<p>I have created the encrypted <code>.secret</code> files by moving the unencrypted files to the <code>.secrets/</code>
directory and made sure to add them to the <code>.gitignore</code> file with the rules</p>
<pre><code class="language-gitignore"># ...

.secrets/*/*
!**/*.secret</code></pre>
<p>Then I ran</p>
<pre><code class="language-bash">make secret-add FILES=".secrets/*/*"

make secret-encrypt</code></pre>
<pre><code class="language-text">$ make secret-add FILES=".secrets/*/*"
"C:/Program Files/Git/mingw64/bin/make" -s git-secret ARGS="add .secrets/*/*"
git-secret: 4 item(s) added.

$ make secret-encrypt
"C:/Program Files/Git/mingw64/bin/make" -s git-secret ARGS="hide"
git-secret: done. 4 of 4 files are hidden.</code></pre>
<!-- generated -->
<p><a id='the-tutorial-directory'> </a></p>
<!-- /generated -->
<h4>The <code>.tutorial</code> directory</h4>
<p>I have mentioned before, that
<a href="/blog/git-secret-encrypt-repository-docker/#introduction">I would normally not store secret <code>gpg</code> keys in the repository</a>,
but I'm still doing it in this tutorial so that it's easier to follow along. To make clear
which files are affected by this &quot;exception to the rule&quot;, I have moved them in a dedicated
<code>.tutorial</code> directory:</p>
<pre><code class="language-text">.tutorial/
├── secret-ci-protected.gpg.example
├── secret-production-protected.gpg.example
└── secret.gpg.example</code></pre>
<!-- generated -->
<p><a id='the-infrastructure-directory'> </a></p>
<!-- /generated -->
<h4>The <code>.infrastructure</code> directory</h4>
<p>The <code>.infrastructure</code> contains all files that are used to manage the infrastructure and
deployments. For now, that's only two files:</p>
<pre><code class="language-text">.infrastructure/
├── deploy.sh
└── provision.sh</code></pre>
<ul>
<li><code>deploy.sh</code> is a script to <strong>perform all necessary deployment steps on the VM</strong> and is explained
in more detail in section <a href="#deployment-commands-on-the-vm">Deployment commands on the VM</a></li>
<li><code>provision.sh</code> is a script to <strong>install <code>docker</code> and <code>docker compose</code> on the VM</strong> and contains
the commands that are explained in section <a href="#installing-docker-and-docker-compose">Installing <code>docker</code> and <code>docker compose</code></a></li>
</ul>
<!-- generated -->
<p><a id='add-a-gpg-key-for-production'> </a></p>
<!-- /generated -->
<h3>Add a <code>gpg</code> key for production</h3>
<p>We have created a new <code>gpg</code> key pair for the <code>prod</code> environment
when <a href="#add-a-gpg-key-for-production">setting up the VM on GCP</a>. The secret key is located
at <code>.tutorial/secret-production-protected.gpg.example</code> and the public key at
<code>.dev/gpg-keys/production-public.gpg</code>.</p>
<!-- generated -->
<p><a id='show-the-build-info'> </a></p>
<!-- /generated -->
<h3>Show the <code>build-info</code></h3>
<p>As part of the deployment, we generate a <a href="#the-build-info-file"><code>build-info</code> file</a> that allows
us to understand &quot;which version of the codebase lives inside a container&quot;. This file is located
at the root of the repository and we expose it as the web route <code>/info</code> (via the <code>php-fpm</code>
container) and as the command <code>info</code> (via the <code>application</code> container).</p>
<p><strong>routes/web.php</strong></p>
<pre><code class="language-php"># ...

Route::get('/info', function () {
    $info = file_get_contents(__DIR__."/../build-info");
    return new \Illuminate\Http\Response($info, 200, ["Content-type" =&gt; "text/plain"]);
});</code></pre>
<p>Show via <code>curl http://localhost/info</code></p>
<p><strong>routes/console.php</strong></p>
<pre><code class="language-php"># ...

Artisan::command('info', function () {
    $info = file_get_contents(__DIR__."/../build-info");
    $this-&gt;line($info);
})-&gt;purpose('Display build information about the codebase');</code></pre>
<p>Show via <code>php artisan info</code></p>
<!-- generated -->
<p><a id='optimize-gitignore'> </a></p>
<!-- /generated -->
<h3>Optimize <code>.gitignore</code></h3>
<p>Laravel uses multiple <code>.gitignore</code> files to retain a directory structure, because
<a href="https://stackoverflow.com/a/115992/413531">empty directories cannot be added to git</a>.
<a href="https://stackoverflow.com/a/53208503/413531">This is a valid strategy</a>, but it makes
<a href="https://stackoverflow.com/a/29695734/413531">understanding &quot;what is actually ignored&quot; more complex</a>.</p>
<p>In addition, it makes it harder to
<a href="/blog/ci-pipeline-docker-php-gitlab-github/#dockerignore">keep <code>.gitignore</code> and <code>.dockerignore</code> in sync</a>,
because we can't simply &quot;copy the contents of the <code>./.gitignore</code>&quot; any longer as it might not
contain all rules. </p>
<p>Thus, I have identified all directory-specific <code>.gitignore</code> files via</p>
<pre><code class="language-bash">find . -path ./vendor -prune -o -name .gitignore -print</code></pre>
<pre><code class="language-text">find . -path ./vendor -prune -o -name .gitignore -print
./.gitignore
./bootstrap/cache/.gitignore
./database/.gitignore
./storage/app/.gitignore
./storage/app/public/.gitignore
./storage/framework/.gitignore
./storage/framework/cache/.gitignore
./storage/framework/cache/data/.gitignore
./storage/framework/sessions/.gitignore
./storage/framework/testing/.gitignore
./storage/framework/views/.gitignore
./storage/logs/.gitignore</code></pre>
<p>Before we add them to the <code>.gitignore</code> file, it is important to understand
<a href="https://git-scm.com/docs/gitignore#_pattern_format">how <code>git</code> handles the <code>gitignore</code> file</a></p>
<blockquote>
<p>An optional prefix &quot;<code>!</code>&quot; which negates the pattern; any matching file excluded by a previous
pattern will become included again. It is not possible to re-include a file if a parent
directory of that file is excluded. Git doesn’t list excluded directories for performance
reasons, so any patterns on contained files have no effect, no matter where they are defined.</p>
</blockquote>
<p>In other words: Consider the following structure</p>
<pre><code class="language-text">storage/
└── app
    ├── .gitignore
    └── public
        └── .gitignore</code></pre>
<p>We might be tempted to write the rules as</p>
<pre><code class="language-gitignore">storage/app/*
!storage/app/.gitignore
!storage/app/public/.gitignore</code></pre>
<p>But that won't work as expected:
<code>storage/app/*</code> ignores &quot;everything&quot; in the <code>storage/app/</code> directory, so that <code>git</code> wouldn't even
look into the <code>storage/app/public/</code> directory and thus wouldn't find the
<code>storage/app/public/.gitignore</code> file! In consequence, the rule <code>!storage/app/public/.gitignore</code>
doesn't have any affect and the file would <em>not</em> be added to the git repository.</p>
<p>Instead, I need to allow the <code>public</code> directory explicitly by adding the rule
<code>!storage/app/public/</code> and ignore all files in it apart from the <code>.gitignore</code> file via
<code>storage/app/public/*</code>. So we are essentially saying:</p>
<ul>
<li>ignore all files in the <code>storage/app/</code> directory</li>
<li>but NOT the <code>storage/app/public/</code> directory ITSELF</li>
<li>though do still ignore all files IN the <code>storage/app/public/</code> directory</li>
<li>but NOT the <code>storage/app/public/.gitignore</code> file</li>
</ul>
<pre><code class="language-gitignore"># ignore all files in the storage/app/ directory
storage/app/*
!storage/app/.gitignore
# but NOT the storage/app/public/ directory ITSELF
!storage/app/public/
# do still ignore all files IN storage/app/public/
storage/app/public/*
# but NOT the storage/app/public/.gitignore file
!storage/app/public/.gitignore</code></pre>
<p>We can simplify the rules a little more via <code>!**.gitignore</code>, i.e. <em>all</em> <code>gitignore</code> files in any
directory should be included</p>
<pre><code class="language-gitignore">storage/app/*
!storage/app/public/
storage/app/public/*

!**.gitignore</code></pre>
<p>So the final rules for all directory-specific <code>.gitignore</code> files become</p>
<pre><code>bootstrap/cache/*
database/*
storage/app/*
!storage/app/public/
storage/app/public/*
storage/framework/*
!storage/framework/cache/
storage/framework/cache/*
!storage/framework/cache/data/
storage/framework/cache/data/*
!storage/framework/sessions/
storage/framework/sessions/*
!storage/framework/testing/
storage/framework/testing/*
!storage/framework/views/
storage/framework/views/*
!storage/framework/logs/
storage/framework/logs/*

!**.gitignore</code></pre>
<p><strong>Caution</strong>: If Laravel changes the rules for their directory-specific <code>.gitignore</code> files, we
must adjust our rules as well! Luckily this usually only happens on major version upgrades, though.</p>
<p>The full <code>.gitignore</code> file becomes</p>
<pre><code class="language-gitignore">**/*.env*
!.env.example
!.make/variables.env
.idea
.phpunit.result.cache
vendor/
secret.gpg
.gitsecret/keys/random_seed
.gitsecret/keys/pubring.kbx~
.secrets/*/*
!**/*.secret
gcp-service-account-key.json

# =&gt; directory-specific .gitignore files by Laravel
bootstrap/cache/*
database/*
storage/app/*
!storage/app/public/
storage/app/public/*
storage/framework/*
!storage/framework/cache/
storage/framework/cache/*
!storage/framework/cache/data/
storage/framework/cache/data/*
!storage/framework/sessions/
storage/framework/sessions/*
!storage/framework/testing/
storage/framework/testing/*
!storage/framework/views/
storage/framework/views/*
!storage/framework/logs/
storage/framework/logs/*

# =&gt; directory-specific .gitignore files from us
.build/*

# =&gt; keep ALL .gitignore files
!**.gitignore</code></pre>
<p>It will be <a href="#adjust-the-dockerignore-file">&quot;synced&quot; later with the <code>.dockerignore</code> file</a>.</p>
<!-- generated -->
<p><a id='docker-changes'> </a></p>
<!-- /generated -->
<h2>Docker changes</h2>
<p>For this tutorial we will use <code>docker compose</code> to <strong>build the containers</strong> as well as to
<strong>run them &quot;in production&quot;</strong>, i.e. on the GCP VM. The <code>docker compose</code> configuration will
essentially be a combination of the <code>local</code> and <code>ci</code> config from the previous tutorials:</p>
<ul>
<li>We will need all the services that
<a href="/blog/docker-from-scratch-for-php-applications-in-2022/#docker">we already know from the <strong><code>local</code> environment</strong></a>,
i.e.
<ul>
<li><code>nginx</code></li>
<li><code>mysql</code></li>
<li><code>redis</code></li>
<li><code>php-worker</code></li>
<li><code>php-fpm</code></li>
<li><code>application</code>
<a href="/img/docker-from-scratch-for-php-applications-in-2022/docker-images.PNG"><img src="/img/docker-from-scratch-for-php-applications-in-2022/docker-images.PNG" alt="Docker images" title="Docker images" /></a></li>
</ul></li>
<li>The codebase will be baked into the image and we will <strong>bind mount a <code>gpg</code> secret key</strong> at
runtime to decrypt the secrets - exactly
<a href="/blog/ci-pipeline-docker-php-gitlab-github/#docker-compose-ci-yml">as we did in the previous tutorial with the <strong><code>ci</code> environment</strong></a>
<a href="/img/ci-pipeline-docker-php-gitlab-github/codebase-in-docker-image-share-secret-key.PNG"><img src="/img/ci-pipeline-docker-php-gitlab-github/codebase-in-docker-image-share-secret-key.PNG" alt="Add the codebase in the docker image and share a secret key file" /></a></li>
</ul>
<p>In the previous tutorial we have used the environment (<code>ci</code>) to
<a href="/blog/ci-pipeline-docker-php-gitlab-github/#compose-file-updates">identify the necessary <code>docker-compose.yml</code> configuration files</a>
and also
<a href="/blog/ci-pipeline-docker-php-gitlab-github/#build-target-ci">as a new build target in the <code>Dockerfiles</code></a>.
We'll stick to this process and <strong>add yet another environment called <code>prod</code></strong>.</p>
<!-- generated -->
<p><a id='updating-the-docker-compose-yml-configuration-files'> </a></p>
<!-- /generated -->
<h3>A <code>.env</code> file for <code>prod</code></h3>
<p>For our <code>local</code> and <code>ci</code> environments we didn't really care about the <code>.env</code> file that we used for
<code>docker compose</code> and have simply <strong>added a ready-to-use template at <code>.docker/.env.example</code> that is
NOT ignored by <code>git</code></strong>. Even though the file contains credentials, e.g. for <code>mysql</code> and <code>redis</code>,
it's okay if those are &quot;exposed&quot; in the repository, <strong>because we won't store any production data
in those databases</strong> in <code>local</code> and <code>ci</code>.</p>
<p>For <code>prod</code> however, the situation is different: We certainly do NOT want to expose the
credentials. Luckily we already have <a href="/blog/git-secret-encrypt-repository-docker/"><code>git secret</code> set up</a>
and thus could simply
<a href="#the-secrets-directory">add an encrypted template file at <code>.secrets/prod/docker.env</code></a>. We will
later
<a href="#create-the-deployment-archive">decrypt the file and add it to the deployment archive</a>
to transfer it to the VM
<a href="#deployment-commands-on-the-vm">in order to start the docker setup there</a>.</p>
<h3>Updating the <code>docker-compose.yml</code> configuration files</h3>
<p>We will use the same technique as before to &quot;assemble&quot; our <code>docker compose</code> configuration, i.e.
we use <strong>multiple compose files with environment specific settings</strong>. For <code>prod</code>, we use the files</p>
<ul>
<li><a href="#docker-compose-local-ci-prod-yml"><code>docker-compose.local.ci.prod.yml</code></a>
<ul>
<li>config settings for <em>all</em> environments</li>
</ul></li>
<li><a href="#docker-compose-local-prod-yml"><code>docker-compose.local.prod.yml</code></a>
<ul>
<li>config settings only for <code>local</code> and <code>prod</code></li>
</ul></li>
<li><a href="#docker-compose-prod-yml"><code>docker-compose.prod.yml</code></a>
<ul>
<li>config settings only for <code>prod</code></li>
</ul></li>
</ul>
<p>The assembling is once again <a href="#env-based-docker-compose-config">performed via Makefile</a>.</p>
<!-- generated -->
<p><a id='docker-compose-local-ci-prod-yml'> </a></p>
<!-- /generated -->
<h4><code>docker-compose.local.ci.prod.yml</code></h4>
<p>This file was simply renamed from file <code>docker-compose.local.ci.yml</code>. It contains </p>
<ul>
<li>
<p><code>network</code> and <code>volume</code> definitions</p>
<pre><code class="language-yaml">networks:
  network:
    driver: ${NETWORKS_DRIVER?}

volumes:
  mysql:
    name: mysql-${ENV?}
    driver: ${VOLUMES_DRIVER?}
  redis:
    name: redis-${ENV?}
    driver: ${VOLUMES_DRIVER?}</code></pre>
</li>
<li>the build instructions for the <code>application</code> service
<pre><code class="language-yaml">application:
  image: ${DOCKER_REGISTRY?}/${DOCKER_NAMESPACE?}/application-${ENV?}:${TAG?}
  build:
    context: ../
    dockerfile: ./images/php/application/Dockerfile
    target: ${ENV?}
    args:
      - BASE_IMAGE=${DOCKER_REGISTRY?}/${DOCKER_NAMESPACE?}/php-base-${ENV?}:${TAG?}
      - ENV=${ENV?}</code></pre></li>
<li>
<p>the configuration for the <code>mysql</code> and <code>redis</code> services</p>
<pre><code class="language-yaml">mysql:
  image: mysql:${MYSQL_VERSION?}
  platform: linux/amd64
  environment:
    - MYSQL_DATABASE=${MYSQL_DATABASE:-application_db}
    - MYSQL_USER=${MYSQL_USER:-application_user}
    - MYSQL_PASSWORD=${MYSQL_PASSWORD?}
    - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD?}
    - TZ=${TIMEZONE:-UTC}
  networks:
    - network
  healthcheck:
    test: mysqladmin ping -h 127.0.0.1 -u $$MYSQL_USER --password=$$MYSQL_PASSWORD
    timeout: 1s
    retries: 30
    interval: 2s

redis:
  image: redis:${REDIS_VERSION?}
  command: &gt;
    --requirepass ${REDIS_PASSWORD?}
  networks:
    - network</code></pre>
</li>
</ul>
<!-- generated -->
<p><a id='docker-compose-local-prod-yml'> </a></p>
<!-- /generated -->
<h4><code>docker-compose.local.prod.yml</code></h4>
<p>This file is based on the
<a href="/blog/ci-pipeline-docker-php-gitlab-github/#docker-compose-local-yml"><code>docker-compose.local.yml</code> of the previous tutorial</a>
<strong>without any settings for local development</strong>. It contains</p>
<ul>
<li>
<p>build instructions for the <code>php-fpm</code>, <code>php-worker</code> and <code>nginx</code> services (because
<a href="/blog/ci-pipeline-docker-php-gitlab-github/#docker-changes">we didn't need those in the configuration for the <code>ci</code> environment</a>)</p>
<pre><code class="language-yaml">php-fpm:
  image: ${DOCKER_REGISTRY?}/${DOCKER_NAMESPACE?}/php-fpm-${ENV?}:${TAG?}
  build:
    context: ../
    dockerfile: ./images/php/fpm/Dockerfile
    target: ${ENV?}
    args:
      - BASE_IMAGE=${DOCKER_REGISTRY?}/${DOCKER_NAMESPACE?}/php-base-${ENV?}:${TAG?}
      - TARGET_PHP_VERSION=${PHP_VERSION?}

php-worker:
  image: ${DOCKER_REGISTRY?}/${DOCKER_NAMESPACE?}/php-worker-${ENV?}:${TAG?}
  build:
    context: ../
    dockerfile: ./images/php/worker/Dockerfile
    target: ${ENV?}
    args:
      - BASE_IMAGE=${DOCKER_REGISTRY?}/${DOCKER_NAMESPACE?}/php-base-${ENV?}:${TAG?}
      - PHP_WORKER_PROCESS_NUMBER=${PHP_WORKER_PROCESS_NUMBER:-4}

nginx:
  image: ${DOCKER_REGISTRY?}/${DOCKER_NAMESPACE?}/nginx-${ENV?}:${TAG?}
  build:
    context: ../
    dockerfile: ./images/nginx/Dockerfile
    target: ${ENV?}
    args:
      - NGINX_VERSION=${NGINX_VERSION?}
      - APP_CODE_PATH=${APP_CODE_PATH_CONTAINER?}
  ports:
    - "${NGINX_HOST_HTTP_PORT:-80}:80"
    - "${NGINX_HOST_HTTPS_PORT:-443}:443"</code></pre>
</li>
<li>port forwarding for the <code>nginx</code> service, because we want to forward incoming requests on the
VM to the <code>nginx</code> docker container
<pre><code class="language-yaml">nginx:
  ports:
    - "${NGINX_HOST_HTTP_PORT:-80}:80"
    - "${NGINX_HOST_HTTPS_PORT:-443}:443"</code></pre></li>
<li>
<p>volume configuration for the <code>mysql</code> and <code>redis</code> services</p>
<pre><code class="language-yaml">mysql:
  volumes:
    - mysql:/var/lib/mysql

redis:
  volumes:
    - redis:/data</code></pre>
</li>
</ul>
<p>The following settings are <strong>only retained in <code>docker-compose.local.yml</code></strong></p>
<ul>
<li>bind mount of the codebase
<pre><code class="language-yaml">application|php-fpm|php-worker|nginx:
  volumes:
    - ${APP_CODE_PATH_HOST?}:${APP_CODE_PATH_CONTAINER?}</code></pre></li>
<li>
<p>port sharing with the host system (excluding nginx ports)</p>
<pre><code class="language-yaml">application:
  ports:
    - "${APPLICATION_SSH_HOST_PORT:-2222}:22"

mysql:
  ports:
    - "${MYSQL_HOST_PORT:-3306}:6379"

redis:
  ports:
    - "${REDIS_HOST_PORT:-6379}:6379"</code></pre>
</li>
<li>any settings for local dev tools for all php images (<code>application</code>, <code>php-fpm</code>, <code>php-worker</code>)
<pre><code class="language-yaml">application|php-fpm|php-worker:
  environment:
    - PHP_IDE_CONFIG=${PHP_IDE_CONFIG?}
  cap_add:
    - "SYS_PTRACE"
  security_opt:
    - "seccomp=unconfined"
  extra_hosts:
    host.docker.internal:host-gateway  </code></pre></li>
</ul>
<!-- generated -->
<p><a id='docker-compose-prod-yml'> </a></p>
<!-- /generated -->
<h4><code>docker-compose.prod.yml</code></h4>
<p>In this file, </p>
<ul>
<li>we bind-mount the secret gpg key into all <code>php</code> services
(<a href="/blog/ci-pipeline-docker-php-gitlab-github/#docker-compose-ci-yml">as we did in the previous tutorial for the <code>docker-compose.ci.yml</code> file</a>)
<pre><code class="language-yaml">  volumes:
    - ${APP_CODE_PATH_HOST?}/secret.gpg:${APP_CODE_PATH_CONTAINER?}/secret.gpg:ro</code></pre></li>
<li>we <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/#env_file">provide an <code>env</code> file</a>
for all <code>php</code> services
<pre><code class="language-yaml">  env_file:
    - ../../compose-secrets.env</code></pre>
<p>The <code>env</code> file is used to pass the <code>GPG_PASSWORD</code> as environment variable to the containers.
This is required to decrypt the secrets on container start. See section
<a href="#decrypt-the-secrets-via-entrypoint">Decrypt the secrets via <code>ENTRYPOINT</code></a> for a more in-depth
explanation.</p></li>
</ul>
<!-- generated -->
<p><a id='build-target-prod'> </a></p>
<!-- /generated -->
<h3>Build target: <code>prod</code></h3>
<p>For building the images for the <code>prod</code> environment, we stick to
<a href="/blog/ci-pipeline-docker-php-gitlab-github/#build-target-ci">the technique of the previous tutorial</a>
once again. In short:</p>
<ul>
<li>initialize the <code>make</code> setup for <code>ENV=prod</code> via
<pre><code class="language-bash">make make-init ENVS="ENV=prod"</code></pre>
<p>so that all subsequent <code>make</code> invocations use <code>ENV=prod</code> by default, see also section
<a href="/blog/ci-pipeline-docker-php-gitlab-github/#initialize-the-shared-variables">Initialize the shared variables</a>
of the previous tutorial</p></li>
<li>the <code>ENV</code> is passed as environment variable to the <code>docker compose</code> command as defined in the
<code>.make/02-00-docker.mk</code> Makefile include AND
<a href="#env-based-docker-compose-config">the config files for <code>prod</code> are selected</a>
<pre><code class="language-bash">ENV=prod docker compose -p -f ./.docker/docker-compose/docker-compose.local.ci.prod.yml -f ./.docker/docker-compose/docker-compose.local.prod.yml -f ./.docker/docker-compose/docker-compose.prod.yml</code></pre></li>
<li>the <code>ENV</code> environment variable is used to define the <code>target</code> property as well as the <code>image</code>
name in the <code>docker compose</code> config files. This can be verified via <code>make docker-config</code>, for
instance
<pre><code class="language-text">$ make docker-config
services:
application:
  build:
    target: prod
  image: gcr.io/pl-dofroscra-p/dofroscra/application-prod:latest
# ...</code></pre></li>
</ul>
<p>For <code>ci</code> we only needed the <code>php-base</code> images as well as the <code>application</code> image. For <code>prod</code>
however, we need <em>all</em> images.</p>
<!-- generated -->
<p><a id='adjust-the-dockerignore-file'> </a></p>
<!-- /generated -->
<h4>Adjust the <code>.dockerignore</code> file</h4>
<p>Since we have
<a href="#optimize-gitignore">modified the <code>.gitignore</code> file</a> , we need to adjust the <code>.dockerignore</code>
file as well. In addition to the <code>gitignore</code> rules, we need three additional rules:</p>
<ol>
<li><code>.git</code>: <a href="/blog/ci-pipeline-docker-php-gitlab-github/#dockerignore">Known from the previous tutorial</a>.
We don't need to transfer the <code>.git</code> directory to the build context</li>
<li><code>!.build/build-info</code>: We don't need the content of
<a href="#the-build-directory">the <code>.build/</code> directory</a>, but we <strong>do</strong> need the
<a href="#the-build-info-file">the <code>build-info</code> file</a></li>
<li><code>vendor/**</code>: Has to be added as a workaround for the <code>docker compose</code> bug
<a href="https://github.com/docker/compose/issues/9508">Inconsistent &quot;.dockerignore&quot; behavior between &quot;docker build&quot; and &quot;docker compose build&quot;</a>
that causes <code>docker compose build</code> to include <code>.gitignore</code> files in the <code>vendor/</code> directory.
This would mess with the build of the <code>php-base</code> image as we expect that no <code>vendor/</code> folder
exists</li>
</ol>
<p>So the full <code>.dockerignore</code> file becomes </p>
<pre><code class="language-dockerignore"># ---
# Rules from .gitignore
# ---
**/*.env*
!.env.example
!.make/variables.env
.idea
.phpunit.result.cache
vendor/
secret.gpg
.gitsecret/keys/random_seed
.gitsecret/keys/pubring.kbx~
.secrets/*/*
!**/*.secret
.build/*
!.gitkeep
gcp-service-account-key.json

# =&gt; directory-specific .gitignore files by Laravel
bootstrap/cache/*
database/*
storage/app/*
!storage/app/public/
storage/app/public/*
storage/framework/*
!storage/framework/cache/
storage/framework/cache/*
!storage/framework/cache/data/
storage/framework/cache/data/*
!storage/framework/sessions/
storage/framework/sessions/*
!storage/framework/testing/
storage/framework/testing/*
!storage/framework/views/
storage/framework/views/*
!storage/framework/logs/
storage/framework/logs/*

# =&gt; directory-specific .gitignore files from us
.build/*

# =&gt; keep ALL .gitignore files
!**.gitignore

# ---
# Rules specifically for .dockerignore
# ---

# =&gt; don't transfer the git directory
.git

# =&gt; keep the build-info file
!.build/build-info

# [WORKAROUND]
# temporary fix for https://github.com/docker/compose/issues/9508
# Otherwise, `docker compose build` would transfer the `.gitignore` files 
# in the vendor/ directory to the build context
vendor/**</code></pre>
<!-- generated -->
<p><a id='build-stage-prod-in-the-php-base-image'> </a></p>
<!-- /generated -->
<h4>Build stage <code>prod</code> in the <code>php-base</code> image</h4>
<p>We will re-use a lot of the code that we used in the previous tutorial to build the <code>php-base</code>
image - so I'd recommend giving the corresponding section
<a href="/blog/ci-pipeline-docker-php-gitlab-github/#build-stage-ci-in-the-php-base-image">Build stage <code>ci</code> in the <code>php-base</code> image</a>
a look if anything is not clear.</p>
<p>The relevant parts of the <code>.docker/images/php/base/Dockerfile</code> will be explained in the
following sections but are also shown here for the sake of a better overview:</p>
<pre><code class="language-Dockerfile">ARG ALPINE_VERSION
ARG COMPOSER_VERSION
FROM composer:${COMPOSER_VERSION} as composer
FROM alpine:${ALPINE_VERSION} as base

ARG APP_USER_NAME
ARG APP_GROUP_NAME
ARG APP_CODE_PATH
ARG TARGET_PHP_VERSION
ARG ENV
ENV APP_USER_NAME=${APP_USER_NAME}
ENV APP_GROUP_NAME=${APP_GROUP_NAME}
ENV APP_CODE_PATH=${APP_CODE_PATH}
ENV TARGET_PHP_VERSION=${TARGET_PHP_VERSION}
ENV ENV=${ENV}

RUN apk add --no-cache php8~=${TARGET_PHP_VERSION}

COPY --from=composer /usr/bin/composer /usr/local/bin/composer

WORKDIR $APP_CODE_PATH

FROM base as codebase

# By only copying the composer files required to run composer install
# the layer will be cached and only invalidated when the composer dependencies are changed
COPY ./composer.json /dependencies/
COPY ./composer.lock /dependencies/

# use a cache mount to cache the composer dependencies
# this is essentially a cache that lives in Docker BuildKit (i.e. has nothing to do with the host system) 
RUN --mount=type=cache,target=/tmp/.composer \
    cd /dependencies &amp;&amp; \
    # COMPOSER_HOME=/tmp/.composer sets the home directory of composer that
    # also controls where composer looks for the cache 
    # so we don't have to download dependencies again (if they are cached)
    # @see https://stackoverflow.com/a/60518444 for the correct if-then-else syntax:
    # - end all commands with ; \
    # - except THEN and ELSE
    if [ "$ENV" == "prod" ] ; \
    then \
      # on production, we don't want test dependencies
      COMPOSER_HOME=/tmp/.composer composer install --no-scripts --no-plugins --no-progress -o --no-dev; \
    else  \
      COMPOSER_HOME=/tmp/.composer composer install --no-scripts --no-plugins --no-progress -o; \
    fi

# copy the full codebase
COPY . /codebase

# move the dependencies
RUN mv /dependencies/vendor /codebase/vendor

# remove files we don't require in the image to keep the image size small
RUN cd /codebase &amp;&amp; \
    rm -rf .docker/ .build/ .infrastructure/ &amp;&amp; \
    if [ "$ENV" == "prod" ] ; \
    then \
      # on production, we don't want tests
      rm -rf tests/; \
    fi

# Remove all secrets that are NOT required for the given ENV:
#  `find /codebase/.secrets -type f -print` lists all files in the .secrets directory
#  `grep -v "/\(shared\|$ENV\)/"` matches only the files that are NOT in the shared/ or $ENV/ (e.g. prod/) directories
#  `grep -v ".secret\$"` ensures that we remove all files that are NOT ending in .secret
#    FYI: 
#     the "$" has to be escaped with a "\" 
#     "Escaping is possible by adding a \ before the variable"
#     @see https://docs.docker.com/engine/reference/builder/#environment-replacement
#  `xargs rm -f` retrieves the remaining file and deletes them
#    FYI: 
#     `xargs` is necessary to convert the stdin to args for `rm`
#     @see https://stackoverflow.com/a/20307392/413531
#     the `-f` flag is required so that `rm` doesn't fail if no files are matched
RUN find /codebase/.secrets -type f -print | grep -v "/\(shared\|$ENV\)/" | grep ".secret\$" | xargs rm -f &amp;&amp; \
    find /codebase/.secrets -type f -print | grep -v ".secret\$" | xargs rm -f &amp;&amp; \
    # list the remaining files for debugging purposes
    find /codebase/.secrets -type f -print

# We need a git repository for git-secret to work (can be an empty one)
RUN cd /codebase &amp;&amp; \
    git init

FROM base as prod

# We will use a custom ENTRYPOINT to decrypt the secrets when the container starts.
# This way, we can store the secrets in their encrypted form directly in the image.
# Note: Because we defined a custom ENTRYPOINT, the default CMD of the base image
#       will be overriden. Thus, we must explicitly re-define it here via `CMD ["/bin/sh"]`.
#       This behavior is described in the docs as:
#       "If CMD is defined from the base image, setting ENTRYPOINT will reset CMD to an empty value. In this scenario, CMD must be defined in the current image to have a value."
#       @see https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact
COPY ./.docker/images/php/base/decrypt-secrets.sh /decrypt-secrets.sh
RUN chmod +x /decrypt-secrets.sh
CMD ["/bin/sh"]
ENTRYPOINT ["/decrypt-secrets.sh"]

COPY --from=codebase --chown=$APP_USER_NAME:$APP_GROUP_NAME /codebase $APP_CODE_PATH

COPY --chown=$APP_USER_NAME:$APP_GROUP_NAME ./.build/build-info $APP_CODE_PATH/build-info</code></pre>
<!-- generated -->
<p><a id='env-based-branching'> </a></p>
<!-- /generated -->
<h5><code>ENV</code> based branching</h5>
<p>So far, we have <strong>used the <code>ENV</code> to determine the final build stage</strong> of the docker image, by
using it as value for the <code>target</code> property in the <code>docker compose</code> config files. This
introduces a certain level of flexibility, but we would be forced to duplicate code if the
same logic is required for multiple <code>ENV</code> that use different build stages.</p>
<p><strong>For <code>RUN</code> statements we can achieve branching on a more granular level by using <code>if...else</code>
conditions</strong>. The syntax is described in<br />
<a href="https://stackoverflow.com/a/60518444">this SO answer to &quot;Dockerfile if else condition with external arguments&quot;</a>:</p>
<ul>
<li>place a <code>\</code> at the end of each line</li>
<li>end each command with <code>;</code></li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-Dockerfile">RUN if [ "$ENV" == "prod" ] ; \
    then \
      echo "ENV is prod"; \
    else \
      echo "ENV is NOT prod"; \
    fi</code></pre>
<p>This works, because we don't just use the <code>ENV</code> as the build target, but we also pass it as a
build argument in the <code>.docker/docker-compose/docker-compose-php-base.yml</code> file:</p>
<pre><code class="language-yaml">services:
  php-base:
    image: ${DOCKER_REGISTRY?}/${DOCKER_NAMESPACE?}/php-base-${ENV?}:${TAG?}
    build:
      args:
        - ENV=${ENV?}
      target: ${ENV?}</code></pre>
<!-- generated -->
<p><a id='avoid-composer-dev-dependencies'> </a></p>
<!-- /generated -->
<h5>Avoid composer dev dependencies</h5>
<p><strong>A production image should only contain the dependencies that are necessary to run the code in
production</strong>. This explicitly <em>excludes</em> dependencies that are only required for development or
testing.</p>
<p>This isn't only about image size, but also about security. E.g. take a look at
<a href="https://nvd.nist.gov/vuln/detail/CVE-2017-9841">CVE-2017-9841</a> - a remote code execution
vulnerability in <code>phpunit</code>. In a
<a href="https://thephp.cc/artikel/phpunit-ein-sicherheitsrisiko">blog post</a> (german) Sebastian Bergmann
(creator of PHPUnit) mentions that</p>
<blockquote>
<p>A dependency like PHPUnit, that es only required for the developing the software but not
running it, is not supposed to be deployed to the production system</p>
</blockquote>
<p>Thus, we will add the <code>--no-dev</code> flag of the <code>compose install</code> command for <code>ENV=prod</code>:</p>
<pre><code class="language-Dockerfile">FROM base as codebase

# ...

RUN --mount=type=cache,target=/tmp/.composer \
    cd /dependencies &amp;&amp; \
    if [ "$ENV" == "prod" ] ; \
    then \
      COMPOSER_HOME=/tmp/.composer composer install --no-scripts --no-plugins --no-progress -o --no-dev; \
    else  \
      COMPOSER_HOME=/tmp/.composer composer install --no-scripts --no-plugins --no-progress -o; \
    fi</code></pre>
<p>Note: See also section
<a href="/ci-pipeline-docker-php-gitlab-github/#build-the-dependencies">Build the dependencies</a> of the
previous tutorial for an explanation of the <code>--mount=type=cache,target=/tmp/.composer</code> part.</p>
<!-- generated -->
<p><a id='remove-unnecessary-directories'> </a></p>
<!-- /generated -->
<h5>Remove unnecessary directories</h5>
<p>We already learned that <strong>no unnecessary stuff should end up in the image</strong>. This doesn't stop at
<code>composer</code> dependencies but does in our case also include some other directories:</p>
<ul>
<li><code>.docker</code> (the docker setup files)</li>
<li><code>.build</code> (used to pass <a href="#the-build-info-file">the <code>build-info</code> file</a>)</li>
<li><code>.infrastructure</code> (see <a href="#the-infrastructure-directory">The <code>.infrastructure</code></a>)</li>
<li><code>tests</code> (the test files)</li>
</ul>
<pre><code class="language-Dockerfile">FROM base as codebase

# ...

RUN cd /codebase &amp;&amp; \
    rm -rf .docker/ .build/ .infrastructure/ &amp;&amp; \
    if [ "$ENV" == "prod" ] ; \
    then \
      rm -rf tests/; \
    fi</code></pre>
<!-- generated -->
<p><a id='remove-secrets-for-other-environments'> </a></p>
<!-- /generated -->
<h5>Remove secrets for other environments</h5>
<p>We have <a href="#">re-organized the secrets previously</a> <strong>TODO: add link to section</strong> so that all
secrets for an environment are located in the corresponding <code>.secrets/$ENV/</code> subdirectory. We can
now make use of that separation <strong>to keep only the secret files that we actually need</strong>. This
adds an additional layer of security, because there is no fained-grained access control possible
with <code>git-secret</code>, i.e. everybody with a correct secret <code>gpg</code> key file can decrypt <em>all</em> the
secrets. But: If our &quot;<code>prod</code> secrets&quot; don't even exist in the &quot;<code>ci</code> images&quot; they also cannot
be leaked if <code>ci</code> is compromised.</p>
<pre><code class="language-Dockerfile">FROM base as codebase

# ...

RUN find /codebase/.secrets -type f -print | grep -v "/\(shared\|$ENV\)/" | grep ".secret\$" | xargs rm -f &amp;&amp; \
    find /codebase/.secrets -type f -print | grep -v ".secret\$" | xargs rm -f &amp;&amp; \
    # list the remaining files for debugging purposes
    find /codebase/.secrets -type f -print</code></pre>
<p>Notes:</p>
<ul>
<li><code>find /codebase/.secrets -type f -print</code> lists all files in the .secrets directory</li>
<li><code>grep -v "/\(shared\|$ENV\)/"</code> matches only the files that are NOT in the <code>shared/</code> or <code>$ENV/</code>
(e.g. <code>prod/</code>) directories</li>
<li><code>grep -v ".secret\$"</code> ensures that we remove all files that are NOT ending in <code>.secret</code>
<ul>
<li>as per <a href="https://docs.docker.com/engine/reference/builder/#environment-replacement">documentation</a>,
the <code>$</code> has to be escaped with a <code>\</code>
<blockquote>
<p>&quot;Escaping is possible by adding a \ before the variable&quot;</p>
</blockquote></li>
</ul></li>
<li><code>xargs rm -f</code> retrieves the remaining file and deletes them
<ul>
<li><code>xargs</code> is necessary to
<a href="https://stackoverflow.com/a/20307392/413531">convert the <code>stdin</code> to arguments for <code>rm</code></a></li>
<li>the <code>-f</code> flag is required so that <code>rm</code> doesn't fail if no files are matched</li>
</ul></li>
</ul>
<!-- generated -->
<p><a id='decrypt-the-secrets-via-entrypoint'> </a></p>
<!-- /generated -->
<h5>Decrypt the secrets via <code>ENTRYPOINT</code></h5>
<p>In the <a href="/blog/ci-pipeline-docker-php-gitlab-github/">CI pipeline setup</a> we <strong>decrypt the secret
files in a manual step</strong> after the containers have been started, see
<a href="/blog/ci-pipeline-docker-php-gitlab-github/#run-details">Run details</a>:</p>
<blockquote>
<p>[...]
then, the docker setup is started
[...]
and gpg is initialized so that the secrets can be decrypted</p>
<pre><code>make gpg-init
make secret-decrypt-with-password</code></pre>
</blockquote>
<p>It &quot;works&quot; as long as <strong>no secrets are required when the container starts</strong>. This is unfortunately
no longer the case, because the <code>php-worker</code> container will start its workers immediately, and
they require a valid <code>.env</code> file - but
<a href="#the-secrets-directory">the <code>.env</code> file for <code>prod</code> is only stored encrypted in the image</a>.
Thus, we must ensure that <strong>the secrets are decrypted as soon as the container starts</strong> -
preferably before any other command is run. This sounds like
<a href="/blog/structuring-the-docker-setup-for-php-projects/#using-entrypoint-for-pre-run-configuration">the perfect job for <code>ENTRYPOINT</code></a>:</p>
<blockquote>
<p>the ENTRYPOINT is executed every time we run a container. Some things can't be done during
build but only at runtime [...] - ENTRYPOINT is a good solution for that problem</p>
</blockquote>
<p>In our case, the <code>ENTRYPOINT</code> should</p>
<ul>
<li>initialize <code>gpg</code> (i.e. &quot;read the secret gpg key&quot;) via
<pre><code class="language-bash">make gpg-init</code></pre></li>
<li>decrypt the secrets via
<pre><code class="language-bash">make secret-decrypt</code></pre></li>
<li>move/copy the decrypted files if necessary  
<pre><code class="language-bash">cp .secrets/prod/app.env .env</code></pre></li>
</ul>
<p>and I have created a corresponding script at <code>.docker/images/php/base/decrypt-secrets.sh</code>:</p>
<pre><code class="language-bash">#!/usr/bin/env bash

# exit immediately on error
set -e

# initialize make
make make-init ENVS="ENV=prod GPG_PASSWORD=$GPG_PASSWORD"

# read the secret gpg key
make gpg-init

# Only decrypt files required for production
files=$(make secret-list | grep "/\(shared\|prod\)/" | tr '\n' ' ')
make secret-decrypt-with-password FILES="$files"

cp .secrets/prod/app.env .env

# treat this script as a "decorator" and execute any other command after running it
# @see https://www.pascallandau.com/blog/structuring-the-docker-setup-for-php-projects/#using-entrypoint-for-pre-run-configuration
exec "$@"</code></pre>
<p>Notes:</p>
<ul>
<li><code>make make-init ENVS="ENV=prod GPG_PASSWORD=$GPG_PASSWORD"</code> initializes <code>make</code> and requires
that an environment variable named <code>$GPG_PASSWORD</code> exists 
<ul>
<li>this is ensured via the <code>env_file</code> property in
<a href="#docker-compose-prod-yml"><code>docker-compose.prod.yml</code></a></li>
</ul></li>
<li><code>make gpg-init</code> requires that a secret <code>gpg</code> key exists at <code>./secret.gpg</code> (see
<a href="/blog/git-secret-encrypt-repository-docker/#local-git-secret-and-gpg-setup">Local <code>git-secret</code> and <code>gpg</code> setup</a>)
<ul>
<li>this is ensured via the bind mount in <a href="#docker-compose-prod-yml"><code>docker-compose.prod.yml</code></a></li>
</ul></li>
<li><code>files=$(make secret-list | grep "/\(shared\|prod\)/" | tr '\n' ' ')</code> retrieves all secret
files that are relevant for production
<ul>
<li><a href="/blog/git-secret-encrypt-repository-docker/#makefile-adjustments"><code>make secret-list</code></a> will
list all secret files</li>
<li><code>grep "/\(shared\|prod\)/"</code> reduces the list to only the ones in the <code>.secrets/shared/</code> and
<code>.secrets/prod/</code> directories</li>
<li><code>tr '\n' ' '</code> replaces new lines with spaces in the result so that the <code>$files</code> variable can
be passed savely as an argument to the next command</li>
</ul></li>
<li>via <code>make secret-decrypt-with-password FILES="$files"</code> 
<ul>
<li>we make sure to <strong>only decrypt files that are relevant for production</strong>. This is important,
because <strong>the <code>prod</code> image only contains production secrets</strong>. Secrets for any other environment
<a href="#remove-secrets-for-other-environments">will not be part of the image</a>.
If we wouldn't provide a dedicated list of files, <code>git-secret</code> would attempt to decrypt <em>all</em>
secrets that it knows and would fail if an encrypted file is missing with the error
<pre><code class="language-text">gpg: can't open '/missing-file.secret': No such file or directory
gpg: decrypt_message failed: No such file or directory
git-secret: abort: problem decrypting file with gpg: exit code 2: /missing-file</code></pre></li>
<li>in addition, the <code>secret-decrypt-with-password</code> target expects that the <code>GPG_PASSWORD</code> variable
is populated (see first point).</li>
</ul></li>
<li>the last line <code>exec "$@"</code> ensures that everything &quot;works as before&quot;, i.e. the same
<code>ENTRYPOINT</code> / <code>CMD</code> is used in the containers (e.g. <code>php-fpm</code> will still invoke the <code>php-fpm</code>
process once the secrets have been decrypted)</li>
</ul>
<p>The final code in the <code>Dockerfile</code> looks like this:</p>
<pre><code class="language-Dockerfile">FROM base as prod

COPY ./.docker/images/php/base/decrypt-secrets.sh /decrypt-secrets.sh
RUN chmod +x /decrypt-secrets.sh
CMD ["/bin/sh"]
ENTRYPOINT ["/decrypt-secrets.sh"]</code></pre>
<p><strong>Note</strong>: Because we defined a custom <code>ENTRYPOINT</code>, the default <code>CMD</code> of the base image  will be
overridden. Thus, we must explicitly re-define it here via <code>CMD ["/bin/sh"]</code>. This behavior is also
<a href="https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact">described in the docs</a>:</p>
<blockquote>
<p>If CMD is defined from the base image, setting <code>ENTRYPOINT</code> will reset <code>CMD</code> to an empty value. In
this scenario, <code>CMD</code> must be defined in the current image to have a value.</p>
</blockquote>
<!-- generated -->
<p><a id='copy-codebase-and-build-info-file'> </a></p>
<!-- /generated -->
<h5>Copy codebase and <code>build-info</code> file</h5>
<p>As before, we will
<a href="/blog/ci-pipeline-docker-php-gitlab-github/#create-the-final-image">copy the final &quot;build artifact&quot; from the <code>codebase</code> build stage</a>
to only retain a single layer in the image. In addition, we also copy
<a href="#the-build-info-file">the <code>build-info</code> file</a> from <code>./.build/build-info</code> to the root of the
codebase.</p>
<pre><code class="language-Dockerfile">FROM base as prod

COPY --from=codebase --chown=$APP_USER_NAME:$APP_GROUP_NAME /codebase $APP_CODE_PATH

COPY --chown=$APP_USER_NAME:$APP_GROUP_NAME ./.build/build-info $APP_CODE_PATH/build-info</code></pre>
<!-- generated -->
<p><a id='build-stage-prod-in-the-remaining-images'> </a></p>
<!-- /generated -->
<h4>Build stage <code>prod</code> in the remaining images</h4>
<p>In the remaining images for <code>nginx</code>, <code>php-fpm</code>, <code>php-worker</code> and <code>application</code>, there are no
dedicated instructions for the <code>prod</code> target. We must still define the build stage, though, via</p>
<pre><code class="language-Dockerfile">FROM base as prod</code></pre>
<p>Otherwise, the build would fail with the error </p>
<pre><code class="language-text">failed to solve: rpc error: code = Unknown desc = failed to solve with frontend dockerfile.v0: failed to create LLB definition: target stage prod could not be found</code></pre>
<!-- generated -->
<p><a id='makefile-changes'> </a></p>
<!-- /generated -->
<h2>Makefile changes</h2>
<p>I have updated the default <code>help</code> target that prints all available commands to also include some
information about the current environment (usually set e.g. via <code>make make-init ENVS="ENV=prod"</code>).
The full recipe is</p>
<pre><code class="language-Makefile">help:
    @printf  '%-43s \033[1mDefault values: \033[0m     \n'
    @printf  '%-43s ===================================\n'
    @printf  '%-43s ENV: \033[31m "$(ENV)" \033[0m     \n'
    @printf  '%-43s TAG: \033[31m "$(TAG)" \033[0m     \n'
    @printf  '%-43s ===================================\n'
    @printf  '%-43s \033[3mRun the following command to set them:\033[0m\n'
    @printf  '%-43s \033[1mmake make-init ENVS="ENV=prod TAG=latest"\033[0m\n'
    @awk  'BEGIN {FS = ":.*##"; printf "\n\033[1mUsage:\033[0m\n  make \033[36m&lt;target&gt;\033[0m\n"} /^[a-zA-Z0-9_-]+:.*?##/ { printf "  \033[36m%-40s\033[0m %s\n", $$1, $$2 } /^##@/ { printf "\n\033[1m%s\033[0m\n", substr($$0, 5) } ' Makefile .make/*.mk</code></pre>
<p>and will now print a header showing the values of the <code>$(ENV)</code> and <code>$(TAG)</code> variables:</p>
<pre><code class="language-text">$ make
                                            Default values:
                                            ===================================
                                            ENV:  "local"
                                            TAG:  "latest"
                                            ===================================
                                            Run the following command to set them:
                                            make make-init ENVS="ENV=prod TAG=latest"

Usage:
  make &lt;target&gt;

[Make]
  make-init                                 Initializes the local .makefile/.env file with ENV variables for make. Use via ENVS="KEY_1=value1 KEY_2=value2"

[Application: Setup]
</code></pre>
<!-- generated -->
<p><a id='adding-gcp-values-to-make-variables-env'> </a></p>
<!-- /generated -->
<h3>Adding GCP values to <code>.make/variables.env</code></h3>
<p>The <code>.make/variables.env</code> file contains the &quot;default&quot; shared variables, that are neither &quot;secret&quot;
nor likely to be changed (see <a href="/blog/ci-pipeline-docker-php-gitlab-github/#initialize-the-shared-variables">Initialize the shared variables</a>).</p>
<p>Those variables include the <a href="/blog/docker-from-scratch-for-php-applications-in-2022/#image-naming-convention">&quot;ingredients&quot; for the image naming convention</a> </p>
<pre><code class="language-text">$(DOCKER_REGISTRY)/$(DOCKER_NAMESPACE)/$(DOCKER_SERVICE_NAME)-$(ENV)</code></pre>
<p>Since we will now <a href="#setup-the-container-registry">use our own registry</a>, we need to change the
<code>DOCKER_REGISTRY</code> value from <code>docker.io</code> to <code>gcr.io/pl-dofroscra-p</code> (see section
<a href="#pushing-images-to-the-registry">Pushing images to the registry</a>).</p>
<p>In addition, we will need three more GCP specific variables that are required for the new
<a href="#gcp-recipes"><code>gcloud</code> cli <code>make</code> targets</a>: </p>
<ul>
<li><code>GCP_PROJECT_ID</code>: The <a href="#setup-a-gcp-project">GCP project id</a></li>
<li><code>GCP_ZONE</code>: The <a href="#general-vm-settings">availability zone of the GCP VM</a></li>
<li><code>GCP_VM_NAME</code>: The <a href="#general-vm-settings">name of the GCP VM</a></li>
</ul>
<p>So the full content of <code>.make/variables.env</code> becomes</p>
<pre><code class="language-dotenv">DOCKER_REGISTRY=gcr.io/pl-dofroscra-p
DOCKER_NAMESPACE=dofroscra
APP_USER_NAME=application
APP_GROUP_NAME=application
GCP_PROJECT_ID=pl-dofroscra-p
GCP_ZONE=us-central1-a
GCP_VM_NAME=dofroscra-test</code></pre>
<!-- generated -->
<p><a id='env-based-docker-compose-config'> </a></p>
<!-- /generated -->
<h3>ENV based <code>docker compose</code> config</h3>
<p>We use the same technique as described
<a href="/blog/ci-pipeline-docker-php-gitlab-github/#env-based-docker-compose-config">in the previous tutorial to assemble the <code>docker compose</code> config files</a>
by adding the config files for <code>ENV=prod</code> and the corresponding <code>DOCKER_COMPOSE_FILES</code>
definition in <code>.make/02-00-docker.mk</code>:</p>
<pre><code class="language-Makefile"># File .make/02-00-docker.mk

# ...

DOCKER_COMPOSE_DIR:=...
DOCKER_COMPOSE_COMMAND:=...

DOCKER_COMPOSE_FILE_LOCAL_CI_PROD:=$(DOCKER_COMPOSE_DIR)/docker-compose.local.ci.prod.yml
DOCKER_COMPOSE_FILE_LOCAL_PROD:=$(DOCKER_COMPOSE_DIR)/docker-compose.local.prod.yml
DOCKER_COMPOSE_FILE_LOCAL:=$(DOCKER_COMPOSE_DIR)/docker-compose.local.yml
DOCKER_COMPOSE_FILE_CI:=$(DOCKER_COMPOSE_DIR)/docker-compose.ci.yml
DOCKER_COMPOSE_FILE_PROD:=$(DOCKER_COMPOSE_DIR)/docker-compose.prod.yml

ifeq ($(ENV),prod)
    DOCKER_COMPOSE_FILES:=-f $(DOCKER_COMPOSE_FILE_LOCAL_CI_PROD) -f $(DOCKER_COMPOSE_FILE_LOCAL_PROD) -f $(DOCKER_COMPOSE_FILE_PROD)
else ifeq ($(ENV),ci)
    DOCKER_COMPOSE_FILES:=-f $(DOCKER_COMPOSE_FILE_LOCAL_CI_PROD) -f $(DOCKER_COMPOSE_FILE_CI)
else ifeq ($(ENV),local)
    DOCKER_COMPOSE_FILES:=-f $(DOCKER_COMPOSE_FILE_LOCAL_CI_PROD) -f $(DOCKER_COMPOSE_FILE_LOCAL_PROD) -f $(DOCKER_COMPOSE_FILE_LOCAL)
endif

DOCKER_COMPOSE:=$(DOCKER_COMPOSE_COMMAND) $(DOCKER_COMPOSE_FILES)</code></pre>
<p>FYI: There is no dedicated <code>docker compose</code> config file for settings that only affect <code>ci</code> and
<code>prod</code> (i.e. <code>docker-compose.ci.prod.yml</code>). The &quot;final&quot; <code>$(DOCKER_COMPOSE_FILES)</code> variable will look
like this:</p>
<pre><code class="language-text">-f ./.docker/docker-compose/docker-compose.local.ci.prod.yml -f ./.docker/docker-compose/docker-compose.local.prod.yml -f ./.docker/docker-compose/docker-compose.prod.yml</code></pre>
<p>and the &quot;full&quot; <code>$(DOCKER_COMPOSE)</code> variable like this:</p>
<pre><code class="language-text">ENV=prod TAG=latest DOCKER_REGISTRY=gcr.io/pl-dofroscra-p DOCKER_NAMESPACE=dofroscra APP_USER_NAME=application APP_GROUP_NAME=application docker compose -p dofroscra_prod --env-file ./.docker/.env -f ./.docker/docker-compose/docker-compose.local.ci.prod.yml -f ./.docker/docker-compose/docker-compose.local.prod.yml -f ./.docker/docker-compose/docker-compose.prod.yml</code></pre>
<!-- generated -->
<p><a id='changes-to-the-git-secret-recipes'> </a></p>
<!-- /generated -->
<h3>Changes to the <code>git-secret</code> recipes</h3>
<p>The <code>git-secret</code> recipes are defined in <code>01-00-application-setup.mk</code> and have been added
originally in
<a href="/blog/git-secret-encrypt-repository-docker/#makefile-adjustments">Use <code>git secret</code> to encrypt secrets in the repository: Makefile adjustments</a>.</p>
<p>I have modified the targets <code>secret-decrypt</code> and <code>secret-decrypt-with-password</code> to accept an
optional list of files to decrypt via the <code>FILES</code> variable. If the variable is empty, <em>all</em>
files are decrypted. This is required for the
<a href="#decrypt-the-secrets-via-entrypoint"><code>decrypt-secrets.sh</code> script</a>, because will
<a href="#remove-secrets-for-other-environments">only store the secrets that are relevant for the curently built environment</a>
in the image and the decryption would fail if we attempted to decrypt files that don't exist.</p>
<pre><code class="language-Makefile"># ...

.PHONY: secret-decrypt
secret-decrypt: ## Decrypt secret files via `git-secret reveal -f`. Use FILES=file1 to decrypt only file1 instead of all files
    "$(MAKE)" -s git-secret ARGS="reveal -f $(FILES)"

.PHONY: secret-decrypt-with-password
secret-decrypt-with-password: ## Decrypt secret files using a password for gpg. Use FILES=file1 to decrypt only file1 instead of all files
    @$(if $(GPG_PASSWORD),,$(error GPG_PASSWORD is undefined))
    "$(MAKE)" -s git-secret ARGS="reveal -f -p $(GPG_PASSWORD) $(FILES)" </code></pre>
<p>In addition, I made a minor adjustment to the targets <code>secret-add</code>, <code>secret-cat</code> and
<code>secret-remove</code> to use the variable name <code>FILES</code> (plural) instead of <code>FILE</code>, because all of
them can also work with a list of files instead just a single one.</p>
<!-- generated -->
<p><a id='additional-docker-recipes'> </a></p>
<!-- /generated -->
<h3>Additional <code>docker</code> recipes</h3>
<p>The following targets have been added to <code>.make/02-00-docker.mk</code></p>
<pre><code class="language-Makefile">.PHONY: docker-push
docker-push: validate-docker-variables ## Push all docker images to the remote repository
    $(DOCKER_COMPOSE) push $(ARGS)

.PHONY: docker-pull
docker-pull: validate-docker-variables ## Pull all docker images from the remote repository
    $(DOCKER_COMPOSE) pull $(ARGS)

.PHONY: docker-exec
docker-exec: validate-docker-variables ## Execute a command in a docker container. Usage: `make docker-exec DOCKER_SERVICE_NAME="application" DOCKER_COMMAND="echo 'Hello world!'"`
    @$(if $(DOCKER_SERVICE_NAME),,$(error "DOCKER_SERVICE_NAME is undefined"))
    @$(if $(DOCKER_COMMAND),,$(error "DOCKER_COMMAND is undefined"))
    $(DOCKER_COMPOSE) exec -T $(DOCKER_SERVICE_NAME) $(DOCKER_COMMAND)

# @see https://www.linuxfixes.com/2022/01/solved-how-to-test-dockerignore-file.html
# helpful to debug a .dockerignore file
.PHONY: docker-show-build-context
docker-show-build-context: ## Show all files that are in the docker build context for `docker build`
    @echo  -e "FROM busybox\nCOPY . /codebase\nCMD find /codebase -print" | docker image build --no-cache -t build-context -f - .
    @docker  run --rm build-context | sort

# `docker build` and `docker compose build` are behaving differently
# @see https://github.com/docker/compose/issues/9508
.PHONY: docker-show-compose-build-context
docker-show-compose-build-context: ## Show all files that are in the docker build context for `docker compose build`
    @.dev/scripts/docker-compose-build-context/show-build-context.sh

# Note: This is only a temporary target until https://github.com/docker/for-win/issues/12742 is fixed
.PHONY: docker-fix-mount-permissions
docker-fix-mount-permissions: ## Fix the permissions of the bind-mounted folder, @see https://github.com/docker/for-win/issues/12742
    $(EXECUTE_IN_APPLICATION_CONTAINER) ls -al</code></pre>
<ul>
<li><code>docker-push</code> uses <code>docker compose push</code> to <em>push</em> all defined services to the registry</li>
<li><code>docker-pull</code> uses <code>docker compose pull</code> to <em>pull</em> all defined services from the registry</li>
<li><code>docker-exec</code> uses <code>docker compose exec</code> to run arbitrary commands in the docker container
that is specified via the <code>$(DOCKER_SERVICE_NAME)</code> variable. The command itself has to passed
via the <code>$(DOCKER_COMMAND)</code> variable</li>
<li><code>docker-show-build-context</code> is a small helper script that builds a temporary image and lists
all files in the build context - this is very helpful to debug entries in the <code>.dockerignore</code>
file. See also: <a href="https://www.linuxfixes.com/2022/01/solved-how-to-test-dockerignore-file.html">[SOLVED] How to test dockerignore file?</a></li>
<li><code>docker-show-compose-build-context</code> does the same but for <code>docker compose build</code> - which
currently (in <code>docker compose</code> v2.5.1)
<a href="https://github.com/docker/compose/issues/9508">seems to behave differently than <code>docker build</code></a></li>
<li><code>docker-fix-mount-permissions</code> is a only a temporary target that provides a workaround for a
bug I filed in the Docker Desktop for Windows repository:
<a href="https://github.com/docker/for-win/issues/12742">Ownership of files set via bind mount is set to user who accesses the file first</a></li>
</ul>
<!-- generated -->
<p><a id='gcp-recipes'> </a></p>
<!-- /generated -->
<h3>GCP recipes</h3>
<p>For the <a href="#deployment-workflow">deployment</a>, we need to communicate with the VM and will use
the <a href="#setup-the-gcloud-cli-tool"><code>gcloud</code> cli</a> to run
<a href="#login-using-the-identity-aware-proxy-iap-concept">SSH commands via IAP tunneling</a>. The cli
requires a couple of default parameters like the VM name, the project id and the availability
zone, that we
<a href="#adding-gcp-values-to-make-variables-env">conveniently defined in the <code>.make/variables.env</code> file</a>.</p>
<p>The GCP targets are defined in <code>.make/03-00-gcp.mk</code>:</p>
<pre><code class="language-Makefile">##@ [GCP]

.PHONY: validate-gcp-variables
validate-gcp-variables:
    @$(if $(GCP_PROJECT_ID),,$(error "GCP_PROJECT_ID is undefined"))
    @$(if $(GCP_ZONE),,$(error "GCP_ZONE is undefined"))
    @$(if $(GCP_VM_NAME),,$(error "GCP_VM_NAME is undefined"))

# @see https://cloud.google.com/sdk/gcloud/reference/compute/ssh
.PHONY: gcp-ssh-command
gcp-ssh-command: validate-gcp-variables ## Run an arbitrary SSH command on the VM via IAP tunnel. Usage: `make gcp-ssh-command COMMAND="whoami"`
    @$(if $(COMMAND),,$(error "COMMAND is undefined"))
    gcloud compute ssh $(GCP_VM_NAME) --project $(GCP_PROJECT_ID) --zone $(GCP_ZONE) --tunnel-through-iap --command="$(COMMAND)"

.PHONY: gcp-ssh-login
gcp-ssh-login: validate-gcp-variables ## Log into a VM via IAP tunnel
    gcloud compute ssh $(GCP_VM_NAME) --project $(GCP_PROJECT_ID) --zone $(GCP_ZONE) --tunnel-through-iap

# @see https://cloud.google.com/sdk/gcloud/reference/compute/scp
.PHONY: gcp-scp-command
gcp-scp-command: validate-gcp-variables ## Copy a file via scp to the VM via IAP tunnel. Usage: `make gcp-scp-command SOURCE="foo" DESTINATION="bar"`
    @$(if $(SOURCE),,$(error "SOURCE is undefined"))
    @$(if $(DESTINATION),,$(error "DESTINATION is undefined"))
    gcloud compute scp $(SOURCE) $(GCP_VM_NAME):$(DESTINATION) --project $(GCP_PROJECT_ID) --zone $(GCP_ZONE) --tunnel-through-iap

# Defines the default secret version to retrieve from the Secret Manager
SECRET_VERSION?=latest

# @see https://cloud.google.com/sdk/gcloud/reference/secrets/versions/access
.PHONY: gcp-secret-get
gcp-secret-get: ## Retrieve and print the secret $(SECRET_NAME) in version $(SECRET_VERSION) from the Secret Manager
    @$(if $(SECRET_NAME),,$(error "SECRET_NAME is undefined"))
    @$(if $(SECRET_VERSION),,$(error "SECRET_VERSION is undefined"))
    @gcloud  secrets versions access $(SECRET_VERSION) --secret=$(SECRET_NAME)

.PHONY: gcp-docker-exec
gcp-docker-exec: ## Run a command in a docker container on the VM. Usage: `make gcp-docker-exec DOCKER_SERVICE_NAME="application" DOCKER_COMMAND="echo 'Hello world!'"`
    @$(if $(DOCKER_SERVICE_NAME),,$(error "DOCKER_SERVICE_NAME is undefined"))
    @$(if $(DOCKER_COMMAND),,$(error "DOCKER_COMMAND is undefined"))
    "$(MAKE)" -s gcp-ssh-command COMMAND="cd $(CODEBASE_DIRECTORY) &amp;&amp; make docker-exec DOCKER_SERVICE_NAME='$(DOCKER_SERVICE_NAME)' DOCKER_COMMAND='$(DOCKER_COMMAND)'"</code></pre>
<ul>
<li><code>validate-gcp-variables</code> is the pendant to the <code>validate-docker-variables</code> in the
<code>.make/02-00-docker.mk</code> file and checks if the default variables <code>GCP_PROJECT_ID</code>,
<code>GCP_ZONE</code> and <code>GCP_VM_NAME</code> exist. See also section
<a href="/blog/docker-from-scratch-for-php-applications-in-2022/#enforce-required-parameters">Enforce required parameters</a></li>
<li><code>gcp-ssh-command</code> is used to run arbitrary SSH commands on the VM using
<a href="https://cloud.google.com/sdk/gcloud/reference/compute/ssh"><code>gcloud compute ssh</code></a>
The command is defined via the <code>COMMAND</code> variable</li>
<li><code>gcp-ssh-login</code> is a convenience target to
<a href="#login-using-the-identity-aware-proxy-iap-concept">log into the GCP VM via SSH using IAP tunneling</a></li>
<li><code>gcp-scp-command</code> copies files from the local system to the VM via <code>scp</code> using
<a href="https://cloud.google.com/sdk/gcloud/reference/compute/scp"><code>gcloud compute scp</code></a>
The source must be defined via the <code>SOURCE</code> variable and the destination via the <code>DESTINATION</code>
variable</li>
<li><code>gcp-secret-get</code> retrieves a secret from the <a href="#setup-the-secret-manager">Secret Manager</a>. The
secret has to specified via the <code>SECRET_NAME</code> variable and an optional version can be given
via the <code>VERSION</code> variable (that defaults to <code>latest</code> if omitted)</li>
<li><code>gcp-docker-exec</code> runs the <code>gcp-ssh-command</code> target to execute the
<a href="#additional-docker-recipes"><code>docker-exec</code> target</a> on the VM</li>
</ul>
<!-- generated -->
<p><a id='infrastructure-recipes'> </a></p>
<!-- /generated -->
<h3>Infrastructure recipes</h3>
<p>For the infrastructure, we currently only have a single target defined in the
<code>.make/04-00-infrastructure.mk</code> file</p>
<pre><code class="language-Makefile">.PHONY: infrastructure-provision
infrastructure-provision: ## Provision the VM
    "$(MAKE)" -s gcp-scp-command SOURCE=".infrastructure/provision.sh" DESTINATION="provision.sh"
    "$(MAKE)" -s gcp-ssh-command COMMAND="sudo bash provision.sh &amp;&amp; gcloud auth configure-docker --quiet"</code></pre>
<ul>
<li><code>infrastructure-provision</code> copies the provisioning script defined in
<a href="#the-infrastructure-directory"><code>.infrastructure/provision.sh</code></a> file to the VM, then runs it
and <a href="#authenticate-docker-via-gcloud">authenticates docker</a></li>
</ul>
<!-- generated -->
<p><a id='deployment-recipes'> </a></p>
<!-- /generated -->
<h3>Deployment recipes</h3>
<p>The <a href="#deployment-workflow">Deployment workflow</a> is described in more detail in the following
section, thus I'll only show the corresponding targets defined in <code>.make/05-00-deployment.mk</code>
here</p>
<pre><code class="language-Makefile">.PHONY: deploy
deploy: # Build all images and deploy them to GCP
    @printf  "$(GREEN)Switching to 'prod' environment$(NO_COLOR)\n"
    @make  --no-print-directory make-init ENVS="ENV=prod TAG=latest"
    @printf  "$(GREEN)Verify that there are no uncommitted changes in the codebase$(NO_COLOR)\n"
    @make  --no-print-directory deployment-guard-uncommitted-changes
    @printf  "$(GREEN)Creating build information file$(NO_COLOR)\n"
    @make  --no-print-directory deployment-create-build-info-file
    @printf  "$(GREEN)Building docker images$(NO_COLOR)\n"
    @make  --no-print-directory docker-build
    @printf  "$(GREEN)Pushing images to the registry$(NO_COLOR)\n"
    @make  --no-print-directory docker-push
    @printf  "$(GREEN)Building deployment archive$(NO_COLOR)\n"
    @make  deployment-create-tar
    @printf  "$(GREEN)Copying the deployment archive to the VM and run the deployment$(NO_COLOR)\n"
    @make  --no-print-directory deployment-run-on-vm
    @printf  "$(GREEN)Clearing deployment archive$(NO_COLOR)\n"
    @make  --no-print-directory deployment-clear-tar
    @printf  "$(GREEN)Switching to 'local' environment$(NO_COLOR)\n"
    @make  --no-print-directory make-init

# directory on the VM that will contain the files to start the docker setup
CODEBASE_DIRECTORY=/tmp/codebase

IGNORE_UNCOMMITED_CHANGES?=

.PHONY: deployment-guard-uncommitted-changes
deployment-guard-uncommitted-changes: ## Check if there are any git changes and abort if so. The check can be ignore by passing `IGNORE_UNCOMMITED_CHANGES=true`
    if [ "$$(git status -s)" != "" ] &amp;&amp; [ "$(IGNORE_UNCOMMITED_CHANGES)" == "" ] ; then \
        printf "Found uncommitted changes in git =&gt; $(RED)ABORTING$(NO_COLOR)\n\n"; \
        printf "Use with IGNORE_UNCOMMITED_CHANGES=true to ignore this warning\n\n"; \
        exit 1; \
    fi
    @echo  "No uncommitted changes found!"

# FYI: make converts all new lines in spaces when they are echo'd 
# @see https://stackoverflow.com/a/54068252/413531
# To execute a shell command via $(command), the $ has to be escaped with another $
#  ==&gt; $$(command)
# @see https://stackoverflow.com/a/26564874/413531
.PHONY: deployment-create-build-info-file
deployment-create-build-info-file: ## Create a file containing version information about the codebase
    @echo  "BUILD INFO" &gt; ".build/build-info"
    @echo  "==========" &gt;&gt; ".build/build-info"
    @echo  "User  :" $$(whoami) &gt;&gt; ".build/build-info"
    @echo  "Date  :" $$(date --rfc-3339=seconds) &gt;&gt; ".build/build-info"
    @echo  "Branch:" $$(git branch --show-current) &gt;&gt; ".build/build-info"
    @echo  "" &gt;&gt; ".build/build-info"
    @echo  "Commit" &gt;&gt; ".build/build-info"
    @echo  "------" &gt;&gt; ".build/build-info"
    @git  log -1 --no-color &gt;&gt; ".build/build-info"

# create tar archive
#  tar -czvf archive.tar.gz ./source
#
# extract tar archive
#  tar -xzvf archive.tar.gz -C ./target
#
# @see https://www.cyberciti.biz/faq/how-to-create-tar-gz-file-in-linux-using-command-line/
# @see https://serverfault.com/a/330133
.PHONY: deployment-create-tar
deployment-create-tar:
    # create the build directory
    rm -rf .build/deployment
    mkdir -p .build/deployment
    # copy the necessary files
    mkdir -p .build/deployment/.docker/docker-compose/
    cp -r .docker/docker-compose/ .build/deployment/.docker/
    cp -r .make .build/deployment/
    cp Makefile .build/deployment/
    cp .infrastructure/deploy.sh .build/deployment/
    # make sure we don't have any .env files in the build directory (don't wanna leak any secrets) ...
    find .build/deployment -name '.env' -delete
    # ... apart fromt the .env file we need to start docker
    cp .secrets/production/docker.env .build/deployment/.docker/.env
    # create the archive
    tar -czvf .build/deployment.tar.gz -C .build/deployment/ ./

.PHONY: deployment-clear-tar
deployment-clear-tar:
    # clear the build directory
    rm -rf .build/deployment
    # remove the archive
    rm -rf .build/deployment.tar.gz

.PHONY: deployment-run-on-vm
deployment-run-on-vm:## Run the deployment script on the VM
    "$(MAKE)" -s gcp-scp-command SOURCE=".build/deployment.tar.gz" DESTINATION="deployment.tar.gz"
    "$(MAKE)" -s gcp-ssh-command COMMAND="sudo rm -rf $(CODEBASE_DIRECTORY) &amp;&amp; sudo mkdir -p $(CODEBASE_DIRECTORY) &amp;&amp; sudo tar -xzvf deployment.tar.gz -C $(CODEBASE_DIRECTORY) &amp;&amp; cd $(CODEBASE_DIRECTORY) &amp;&amp; sudo bash deploy.sh"

.PHONY: deployment-setup-db-on-vm
deployment-setup-db-on-vm: ## Setup the application on the VM. CAUTION: The docker setup must be running!
    "$(MAKE)" -s gcp-docker-exec DOCKER_SERVICE_NAME="application" DOCKER_COMMAND="make setup-db"</code></pre>
<ul>
<li><code>deploy</code> is the main target to <a href="#the-deploy-target">trigger a full deployment</a></li>
<li><code>deployment-guard-uncommitted-changes</code> checks if there are changes in the codebase that have
not been committed to git, yet. We want to avoid that, because that might cause a
<a href="#avoiding-code-drift">&quot;drift&quot; between the codebase and the deployed code</a></li>
<li><code>deployment-create-build-info-file</code> creates
<a href="#the-build-info-file">the <code>build-info</code> file</a> in the <code>.build/</code> directory</li>
<li><code>deployment-create-tar</code>
<a href="#create-the-deployment-archive">creates a deployment <code>tar</code> archive</a> that contains all necessary
files to start the <code>docker</code> setup via <code>docker compose</code> on the VM</li>
<li><code>deployment-clear-tar</code> removes the archive including any temporary files that have been
created via <code>deployment-create-tar</code></li>
<li><code>deployment-run-on-vm</code> copies the deployment <code>tar</code> archive to the VM, extracts it and runs the
deployment script defined in <a href="#the-infrastructure-directory">.infrastructure/deploy.sh</a>, see
section <a href="#deployment-commands-on-the-vm">Deployment commands on the VM</a></li>
<li><code>deployment-setup-db-on-vm</code> executes the <code>setup-db</code> command in the <code>application</code> container on
the VM</li>
</ul>
<!-- generated -->
<p><a id='deployment-workflow'> </a></p>
<!-- /generated -->
<h2>Deployment workflow</h2>
<p>As a precondition we expect <a href="#the-actual-vm-creation">that a GCP VM is up and running</a>. The
basic idea of the deployment is:</p>
<ul>
<li>build the <code>docker</code> images using the <code>prod</code> environment and <strong>push</strong> them to the remote registry</li>
<li>log into the VM and <strong>pull</strong> the images</li>
<li>use <code>docker compose</code> on the VM to <strong>start</strong> the <code>docker</code> setup</li>
</ul>
<p>This shouldn't be too complicated - we already do the same thing locally, don't we? In theory:
Yes. In practice, there is <strong>one major difference: Locally, we have access to our repository</strong>,
including the files for running</p>
<ul>
<li>the <code>docker</code> setup (=&gt; the <code>.docker</code> directory) </li>
<li>the <code>make</code> setup to control the application (=&gt; the <code>Makefile</code> and the <code>.make</code> directory) </li>
</ul>
<p>Fortunately we can solve this issue easily and provide a single <code>make</code> target named <code>deploy</code>
that will take care of everything.</p>
<!-- generated -->
<p><a id='the-deploy-target'> </a></p>
<!-- /generated -->
<h3>The <code>deploy</code> target</h3>
<p>The <code>deploy</code> target runs all necessary commands for a deployment:</p>
<p>Run a safeguard checks to <a href="#avoiding-code-drift">avoid code drift</a></p>
<pre><code class="language-Makefile">    @printf  "$(GREEN)Switching to 'local' environment$(NO_COLOR)\n"
    @make  --no-print-directory make-init
    @printf  "$(GREEN)Verifying that there are no changes in the secrets$(NO_COLOR)\n"
    @make  --no-print-directory gpg-init
    @make  --no-print-directory deployment-guard-secret-changes
    @printf  "$(GREEN)Verify that there are no uncommitted changes in the codebase$(NO_COLOR)\n"
    @make  --no-print-directory deployment-guard-uncommitted-changes</code></pre>
<p>Enable the <code>prod</code> environment for the <code>make</code> setup, see section
<a href="#env-based-docker-compose-config">ENV based <code>docker compose</code> config</a></p>
<pre><code class="language-Makefile">    @printf  "$(GREEN)Switching to 'prod' environment$(NO_COLOR)\n"
    @make  --no-print-directory make-init ENVS="ENV=prod TAG=latest"</code></pre>
<p>Create <a href="#the-build-info-file">the <code>build-info</code> file</a></p>
<pre><code class="language-Makefile">    @printf  "$(GREEN)Creating build information file$(NO_COLOR)\n"
    @make  --no-print-directory deployment-create-build-info-file</code></pre>
<p><a href="#build-and-push-the-docker-images">Build and push the <code>docker</code> images</a></p>
<pre><code class="language-Makefile">    @printf  "$(GREEN)Building docker images$(NO_COLOR)\n"
    @make  --no-print-directory docker-build
    @printf  "$(GREEN)Pushing images to the registry$(NO_COLOR)\n"
    @make  --no-print-directory docker-push</code></pre>
<p><a href="#create-the-deployment-archive">Create the deployment archive</a></p>
<pre><code class="language-Makefile">    @printf  "$(GREEN)Creating the deployment archive$(NO_COLOR)\n"
    @make  deployment-create-tar</code></pre>
<p><a href="#deployment-commands-on-the-vm">Run deployment commands on the VM</a></p>
<pre><code class="language-Makefile">    @printf  "$(GREEN)Copying the deployment archive to the VM and run the deployment$(NO_COLOR)\n"
    @make  --no-print-directory deployment-run-on-vm</code></pre>
<p>Cleanup the deployment by removing the local deployment archive and enabling the default
environment  (<code>local</code>) for the <code>make</code> setup.</p>
<pre><code class="language-Makefile">    @printf  "$(GREEN)Clearing deployment archive$(NO_COLOR)\n"
    @make  --no-print-directory deployment-clear-tar
    @printf  "$(GREEN)Switching to 'local' environment$(NO_COLOR)\n"
    @make  --no-print-directory make-init</code></pre>
<!-- generated -->
<p><a id='avoiding-code-drift'> </a></p>
<!-- /generated -->
<h3>Avoiding code drift</h3>
<p>The term &quot;code drift&quot; is derived from <a href="https://coder.com/blog/what-is-configuration-drift">configuration drift</a>,
which indicates the (subtle) differences in configuration between environments:</p>
<blockquote>
<p>If you've ever heard an engineer lamenting (or sometimes arrogantly proclaiming)
&quot;well, it works on my machine&quot; then you have been witness to configuration drift.</p>
</blockquote>
<p>In our case it refers to <strong>differences between our git repository and the code in the docker
images</strong> as well as <strong>changes between the decrypted and encrypted secret files</strong>. These problems
can occur, because we are currently
<strong>executing the deployment from our local machine</strong> and we might have made some
<strong>changes in the codebase</strong> when we build the docker images. The build context sent
to the <code>docker</code> daemon would then be different from the git repository resp. the encrypted
<code>.secret</code> files. This can lead to all sorts of hard-to-debug quirks and should thus be avoided.</p>
<p>When we deploy later <strong>from the CI pipelines, those problems simply won't occur</strong>, because the whole
<strong>codebase will be identical with the git repository</strong> - but I really do NOT want to lose the
ability to deploy code from my local system (devs that went through Gitlab / Github downtimes
will understand...)</p>
<p>Corresponding checks are implemented via the <code>deployment-guard-uncommitted-changes</code> and
<code>deployment-guard-secret-changes</code> targets that exit with <code>exit 1</code> (a non-zero status code) which in
turn makes the <a href="#the-deploy-target"><code>deploy</code> target</a> stop/fail.</p>
<pre><code class="language-Makefile">IGNORE_SECRET_CHANGES?=

.PHONY: deployment-guard-secret-changes
deployment-guard-secret-changes: ## Check if there are any changes between the decrypted and encrypted secret files
    if ( ! make secret-diff || [ "$$(make secret-diff | grep ^@@)" != "" ] ) &amp;&amp; [ "$(IGNORE_SECRET_CHANGES)" == "" ] ; then \
        printf "Found changes in the secret files =&gt; $(RED)ABORTING$(NO_COLOR)\n\n"; \
        printf "Use with IGNORE_SECRET_CHANGES=true to ignore this warning\n\n"; \
        make secret-diff; \
        exit 1; \
    fi
    @echo  "No changes in the secret files!"</code></pre>
<p><a href="/blog/git-secret-encrypt-repository-docker/#makefile-adjustments"><code>make secret-diff</code></a> is used
to check for differences between decrypted and encrypted secrets. </p>
<p><code>! make secret-diff</code> checks if the commands exits with a non-zero exit code. This happens for
instance, when the secrets have not been decrypted yet. The error is</p>
<pre><code class="language-gitignore">git-secret: abort: file not found. Consider using 'git secret reveal': &lt;missing-file&gt;</code></pre>
<p>If the command doesn't fail, the changes are displayed in a <code>diff</code> format, e.g.</p>
<pre><code class="language-diff"> --- /dev/fd/63
 +++ /var/www/app/.secrets/shared/passwords.txt
 @@ -1 +1,2 @@
  my_secret_password
 +1
 foo</code></pre>
<p>We use <code>grep ^@@</code> to check the existence of a &quot;line that starts with @@&quot; to identify a change.
If no changes are found the info <code>"No changes in the secret files!"</code> is printed. Otherwise, a
warning is shown. The check an be suppressed by passing <code>IGNORE_SECRET_CHANGES=true</code>.</p>
<pre><code class="language-Makefile">IGNORE_UNCOMMITED_CHANGES?=

.PHONY: deployment-guard-uncommitted-changes
deployment-guard-uncommitted-changes: ## Check if there are any git changes and abort if so. The check can be ignore by passing `IGNORE_UNCOMMITED_CHANGES=true`
    if [ "$$(git status -s)" != "" ] &amp;&amp; [ "$(IGNORE_UNCOMMITED_CHANGES)" == "" ] ; then \
        printf "Found uncommitted changes in git =&gt; $(RED)ABORTING$(NO_COLOR)\n\n"; \
        printf "Use with IGNORE_UNCOMMITED_CHANGES=true to ignore this warning\n\n"; \
        git status -s; \
        exit 1; \
    fi
    @echo  "No uncommitted changes found!"</code></pre>
<p><code>git status -s</code> is used to check for any uncommitted changes. If no changes are found the info
<code>"No uncommitted changes found!"</code> is printed. Otherwise, a warning is shown. The check an be
suppressed by passing <code>IGNORE_UNCOMMITED_CHANGES=true</code>.</p>
<!-- generated -->
<p><a id='the-build-info-file'> </a></p>
<!-- /generated -->
<h3>The <code>build-info</code> file</h3>
<p>When testing the deployments I often needed to identify small bugs in the code. The more complex
the whole process gets, the more things can go wrong and the more &quot;stuff needs to be checked&quot;.
One of them is the <a href="#avoiding-code-drift">code drift mentioned in the previous section</a>, btw.</p>
<p>To make my life a little easier, <strong>I added a file called <code>build-info</code> that contains information
about the build</strong> and will be stored in the docker images - allowing me to inspect the file
later, see also section <a href="#show-the-build-info">Show the <code>build-info</code></a>.</p>
<p>The file is created via <code>deployment-create-build-info-file</code> target</p>
<pre><code class="language-Makefile">.PHONY: deployment-create-build-info-file
deployment-create-build-info-file: ## Create a file containing version information about the codebase
    @echo  "BUILD INFO" &gt; ".build/build-info"
    @echo  "==========" &gt;&gt; ".build/build-info"
    @echo  "User  :" $$(whoami) &gt;&gt; ".build/build-info"
    @echo  "Date  :" $$(date --rfc-3339=seconds) &gt;&gt; ".build/build-info"
    @echo  "Branch:" $$(git branch --show-current) &gt;&gt; ".build/build-info"
    @echo  "" &gt;&gt; ".build/build-info"
    @echo  "Commit" &gt;&gt; ".build/build-info"
    @echo  "------" &gt;&gt; ".build/build-info"
    @git  log -1 --no-color &gt;&gt; ".build/build-info"</code></pre>
<p>The file is created on the host system under <code>.build/build-info</code> and then
<a href="#copy-codebase-and-build-info-file">copied to <code>./build-info</code> in the <code>Dockerfile</code> of the <code>php-base</code> image</a>.
To execute a shell command via <code>$(command)</code>,
<a href="https://stackoverflow.com/a/26564874/413531">the <code>$</code> has to be escaped with another <code>$</code></a>, to
not be interpreted by <code>make</code> as a variable. Example:</p>
<pre><code class="language-Makefile">some-target:
    $$(command)</code></pre>
<p>FYI: I learned that
<a href="https://stackoverflow.com/a/54068252/413531"><code>make</code> converts all new lines in spaces when they are echo'd</a>
because I initially used</p>
<pre><code class="language-text">@echo $$(git log -1 --no-color) &gt;&gt; ".build/build-info"</code></pre>
<p>instead of </p>
<pre><code class="language-text">@git log -1 --no-color &gt;&gt; ".build/build-info"</code></pre>
<p>which would remove all new lines.</p>
<p>A final file <code>build-info</code> file looks like this:</p>
<pre><code class="language-text">BUILD INFO
==========
User  : Pascal
Date  : 2022-05-22 17:10:21+02:00
Branch: part-8-deploy-docker-compose-php-gcp-poc

Commit
------
commit c47464536613874d192696d93d3c97b138c7a6be
Author: Pascal Landau &lt;pascal.landau@googlemail.com&gt;
Date:   Sun May 22 17:10:15 2022 +0200

    Testing the new `build-info` file
</code></pre>
<!-- generated -->
<p><a id='build-and-push-the-docker-images'> </a></p>
<!-- /generated -->
<h3>Build and push the <code>docker</code> images</h3>
<p><code>make</code> is initialized with <code>ENV=prod</code>, i.e. calling <code>make docker-build</code> will use
<a href="#env-based-docker-compose-config">the correct <code>docker compose</code> config</a> for <strong>building</strong> production
images. In addition, we have adjusted the <code>DOCKER_REGISTRY</code> to <code>gcr.io/pl-dofroscra-p</code> in the
<a href="#adding-gcp-values-to-make-variables-env">.make/variables.env file</a>, so that the images will
immediately be <a href="#pushing-images-to-the-registry">tagged correctly</a> as</p>
<pre><code class="language-text">gcr.io/pl-dofroscra-p/dofroscra/$service-prod

# e.g. for `php-base`

gcr.io/pl-dofroscra-p/dofroscra/php-base-prod</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-text">$ make docker-build
ENV=prod TAG=latest DOCKER_REGISTRY=gcr.io/pl-dofroscra-p DOCKER_NAMESPACE=dofroscra APP_USER_NAME=application APP_GROUP_NAME=application docker compose -p dofroscra_prod --env-file ./.docker/.env -f ./.docker/docker-compose/docker-compose-php-base.yml build php-base
#1 [internal] load build definition from Dockerfile
# ...

$ docker image ls 
REPOSITORY                                          TAG     IMAGE ID       CREATED          SIZE
gcr.io/pl-dofroscra-p/dofroscra/php-fpm-prod        latest  2be3bec977de   24 seconds ago   147MB
gcr.io/pl-dofroscra-p/dofroscra/php-worker-prod     latest  6dbf14d1b329   25 seconds ago   181MB
gcr.io/pl-dofroscra-p/dofroscra/php-base-prod       latest  9164976a78a6   32 seconds ago   130MB
gcr.io/pl-dofroscra-p/dofroscra/application-prod    latest  377fdee0f12a   32 seconds ago   130MB
gcr.io/pl-dofroscra-p/dofroscra/nginx-prod          latest  42dd1608d126   24 seconds ago   23.5MB</code></pre>
<p>Thanks to the image name, we can also immediately <strong>push</strong> the images to the remote registry via
<code>make docker-push</code>. Note, that we see a lot of <code>Layer already exists</code> infos in the console
output for the <code>php-fpm</code> and <code>php-worker</code> images. This is due to the fact that we use
<a href="/blog/docker-from-scratch-for-php-applications-in-2022/#php-images">a common <code>php-base</code> base image</a>
for <code>application</code>, <code>php-fpm</code> and <code>php-worker</code>, i.e. <strong>those images have a lot of layers in
common</strong> and docker is smart enough to recognize, that the same layer doesn't have to be pushed
multiple times.</p>
<pre><code class="language-text">$ make docker-push
ENV=prod TAG=latest DOCKER_REGISTRY=gcr.io/pl-dofroscra-p DOCKER_NAMESPACE=dofroscra APP_USER_NAME=application APP_GROUP_NAME=application docker compose -p dofroscra_prod --env-file ./.docker/.env -f ./.docker/docker-compose/docker-compose.local.ci.prod.yml -f ./.docker/docker-compose/docker-compose.local.prod.yml -f ./.docker/docker-compose/docker-compose.prod.yml push
mysql Skipped
redis Skipped
Pushing application: c8f4416c4383 Preparing
#...
Pushing application: 6bbfa8829d07 Pushing [==================================================&gt;]  3.584kB
#...
Pushing php-worker: 6bbfa8829d07 Layer already exists
#...
Pushing php-fpm: 6bbfa8829d07 Layer already exists</code></pre>
<!-- generated -->
<p><a id='create-the-deployment-archive'> </a></p>
<!-- /generated -->
<h3>Create the deployment archive</h3>
<p>As described in the <a href="#deployment-workflow">introduction of the Deployment workflow</a>, we need to
<strong>make our <code>make</code> and <code>docker</code> setup somehow available on the VM</strong>. We will solve this issue by
<strong>creating a <code>tar</code> archive with all necessary files locally</strong> and
<a href="#deployment-commands-on-the-vm">transfer it to the VM</a></p>
<p>The archive is created via the <code>deployment-create-tar</code> target</p>
<pre><code class="language-Makefile">.PHONY: deployment-create-tar
deployment-create-tar:
    # create the build directory
    rm -rf .build/deployment
    mkdir -p .build/deployment
    # copy the necessary files
    mkdir -p .build/deployment/.docker/docker-compose/
    cp -r .docker/docker-compose/ .build/deployment/.docker/
    cp -r .make .build/deployment/
    cp Makefile .build/deployment/
    cp .infrastructure/deploy.sh .build/deployment/
    # make sure we don't have any .env files in the build directory (don't wanna leak any secrets) ...
    find .build/deployment -name '.env' -delete
    # ... apart from the .env file we need to start docker
    cp .secrets/prod/docker.env .build/deployment/.docker/.env
    # create the archive
    tar -czvf .build/deployment.tar.gz -C .build/deployment/ ./</code></pre>
<p>The recipe uses the <code>.build/deployment</code> directory as a temporary location to store all necessary
files, i.e.</p>
<ul>
<li>the <code>docker compose</code> config files in <code>.docker/docker-compose/</code> and the <code>.secrets/prod/docker.env</code>
file for the <code>docker</code> setup</li>
<li>the <code>Makefile</code> and the <code>.make</code> directory in the root of the codebase for the <code>make</code> setup</li>
<li>the <code>.infrastructure/deploy.sh</code> script to run the deployment</li>
</ul>
<p>In addition, we copy <a href="#a-env-file-for-prod">the <code>.secrets/prod/docker.env</code> file</a> to use it as the
<code>.env</code> file for <code>docker compose</code>. <strong>Caution</strong>: This only works, because we have
<a href="#avoiding-code-drift">verified previously that there are no changes between the decrypted and encrypted .secret files</a>
(which also means that <code>.secrets/prod/docker.env</code> is already decrypted).</p>
<p>Once all files are copied, the whole directory is added to the <code>.build/deployment.tar.gz</code>
archive via</p>
<pre><code class="language-bash">tar -czvf .build/deployment.tar.gz -C .build/deployment/ ./</code></pre>
<p>The <code>-C .build/deployment/</code> option makes sure that
<a href="https://serverfault.com/a/330133">the directory structure is retained when extracting the archive</a>.<br />
For the remaining options take a look at
<a href="https://www.cyberciti.biz/faq/how-to-create-tar-gz-file-in-linux-using-command-line/">How to create tar.gz file in Linux using command line</a></p>
<!-- generated -->
<p><a id='deployment-commands-on-the-vm'> </a></p>
<!-- /generated -->
<h3>Deployment commands on the VM</h3>
<p>Once the <a href="#create-the-deployment-archive">creation of the deployment archive</a> is done, we can
transfer the resulting <code>.build/deployment.tar.gz</code> file to the VM, extract it and run the deployment
script. All of that is done via the <code>deployment-run-on-vm</code> target</p>
<pre><code class="language-Makefile"># directory on the VM that will contain the files to start the docker setup
CODEBASE_DIRECTORY=/tmp/codebase

.PHONY: deployment-run-on-vm
deployment-run-on-vm:## Run the deployment script on the VM
    "$(MAKE)" -s gcp-scp-command SOURCE=".build/deployment.tar.gz" DESTINATION="deployment.tar.gz"
    "$(MAKE)" -s gcp-ssh-command COMMAND="sudo rm -rf $(CODEBASE_DIRECTORY) &amp;&amp; sudo mkdir -p $(CODEBASE_DIRECTORY) &amp;&amp; sudo tar -xzvf deployment.tar.gz -C $(CODEBASE_DIRECTORY) &amp;&amp; cd $(CODEBASE_DIRECTORY) &amp;&amp; sudo bash deploy.sh"</code></pre>
<p>Under the hood, the target uses the
<a href="#gcp-recipes"><code>gcp-scp-command</code> and <code>gcp-ssh-command</code></a> targets. The deployment archive is
extracted in <code>/tmp/codebase</code> via </p>
<pre><code class="language-bash">sudo rm -rf /tmp/codebase &amp;&amp; sudo mkdir -p /tmp/codebase &amp;&amp; sudo tar -xzvf deployment.tar.gz -C /tmp/codebase</code></pre>
<p>and then the deployment script is executed</p>
<pre><code class="language-bash">cd /tmp/codebase &amp;&amp; sudo bash deploy.sh</code></pre>
<p>All of those commands are run <strong>in a single invocation of <code>gcp-ssh-command</code></strong>, because there's a
certain overhead involved when tunneling commands via IAP, i.e. each invocation takes a couple
of seconds.</p>
<!-- generated -->
<p><a id='the-deploy-sh-script'> </a></p>
<!-- /generated -->
<h4>The <code>deploy.sh</code> script</h4>
<p>The actual deployment is done &quot;on the VM&quot; via the
<a href="#the-infrastructure-directory"><code>.infrastructure/deploy.sh</code> script</a></p>
<pre><code class="language-bash">#!/usr/bin/env bash

echo "Retrieving secrets"
make gcp-secret-get SECRET_NAME=GPG_KEY &gt; secret.gpg
GPG_PASSWORD=$(make gcp-secret-get SECRET_NAME=GPG_PASSWORD)
echo "Creating compose-secrets.env file"
echo "GPG_PASSWORD=$GPG_PASSWORD" &gt; compose-secrets.env
echo "Initializing the codebase"
make make-init ENVS="ENV=prod TAG=latest"
echo "Pulling images on the VM from the registry"
make docker-pull
echo "Stop the containers on the VM"
make docker-down || true
echo "Start the containers on the VM"
make docker-up</code></pre>
<p>The script is located at the root of the codebase and</p>
<ul>
<li>will first retrieve the <code>GPG_KEY</code> and the <code>GPG_PASSWORD</code> values that we
<a href="#add-the-secret-gpg-key-and-password">created previously in the Secret Manager</a>
<ul>
<li>the <code>GPG_KEY</code> is stored in the file <code>secret.gpg</code> in the root of the codebase so that it is
<a href="/blog/git-secret-encrypt-repository-docker/#local-git-secret-and-gpg-setup">picked up automatically when initializing <code>gpg</code></a>
<blockquote>
<p>[...]
and <strong>the private key has to be named secret.gpg and put in the root of the codebase</strong>.</p>
</blockquote></li>
<li>the <code>GPG_PASSWORD</code> is stored in the bash variable <code>$GPG_PASSWORD</code> and from there stored in
a file called <code>compose-secrets.env</code> as 
<pre><code class="language-dotenv">GPG_PASSWORD=$GPG_PASSWORD</code></pre>
<p>This file is used in the
<a href="#docker-compose-prod-yml"><code>docker-compose.prod.yml</code> file as <code>env_file</code> for the php docker containers</a>,
so that the <code>GPG_PASSWORD</code> becomes available in the
<a href="#decrypt-the-secrets-via-entrypoint"><code>decrypt-secrets.sh</code> script used in the <code>ENTRYPOINT</code></a>
of the <code>php-base</code> image</p></li>
</ul></li>
<li>then the <code>make</code> setup is initialized for the <code>prod</code> environment via
<pre><code class="language-bash">make-init ENVS="ENV=prod TAG=latest"</code></pre>
<p>so that all subsequent <code>docker-*</code> targets
<a href="#env-based-docker-compose-config">use the correct configuration</a>  </p></li>
<li>and finally, the <code>docker</code> images we pushed in step
<a href="#build-and-push-the-docker-images">&quot;Build and push the <code>docker</code> images&quot;</a> are <strong>pulled</strong>, any
running containers are <strong>stopped</strong> and the whole <code>docker</code> setup is <strong>started</strong> with the new
images
<ul>
<li>FYI: <code>docker compose down</code> would fail (exit with a non-zero status code) if no containers are
running. Since this is fine for us (we simply want to ensure that no containers are running),
the command is OR'd via <code>make docker-down || true</code> so that the script won't stop if that
happens.</li>
</ul></li>
</ul>
<!-- generated -->
<p><a id='wrapping-up'> </a></p>
<!-- /generated -->
<h2>Wrapping up</h2>
<p>Congratulations, you made it! If some things are not completely clear by now, don't hesitate to
leave a comment. </p>
<p><strong>TODO: Add summary</strong></p>
<p>In the next part of this tutorial, we will use terraform to create the infrastructure for
production deployments on GCP and deploy the docker containers on invididual VMs without
<code>docker compose</code>.</p>
<p>Please subscribe to the <a href="/feed.xml">RSS feed</a> or <a href="#newsletter">via email</a> to get automatic
notifications when this next part comes out :)</p>                <hr />
                <h3>Wanna stay in touch?</h3>
                <p>Since you ended up on this blog, chances are pretty high that you're into Software Development
                (probably PHP, Laravel, Docker or Google Big Query) and I'm a big fan of feedback and networking.
                </p><p>
                So - if you'd like to stay in touch, feel free to shoot me an email with a couple of words about yourself and/or
                connect with me on
                <a href="https://www.linkedin.com/in/pascallandau">LinkedIn</a> or
                <a href="https://twitter.com/PascalLandau">Twitter</a>
                or simply subscribe to my <a href="https://www.pascallandau.com/feed.xml">RSS feed</a>
                or go the crazy route and subscribe via mail
                and don't forget to leave a comment :)
                </p>
                <!-- Begin Mailchimp Signup Form -->
                <link href="//cdn-images.mailchimp.com/embedcode/classic-10_7.css" rel="stylesheet" type="text/css">
                <style type="text/css">
                    #mc_embed_signup{background:#bae1ff; clear:left; font:14px Helvetica,Arial,sans-serif; border-radius: 20px}
                    #mc_embed_signup h4 {padding:1em 0 0 1em}
                    #mc-embedded-subscribe-form input[type=checkbox]{display: inline; width: auto;margin-right: 10px;}
                    #mergeRow-gdpr {margin-top: 20px;}
                    #mergeRow-gdpr fieldset label {font-weight: normal;}
                    #mc-embedded-subscribe-form .mc_fieldset{border:none;min-height: 0px;padding-bottom:0px;}
                </style>
                <div id="mc_embed_signup">
                    <h4 id="newsletter">Subscribe to posts via mail</h4>
                    <form action="https://pascallandau.us20.list-manage.com/subscribe/post?u=89e1c97fa614ded06a44fbcfd&amp;id=852c78303c" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
                        <div id="mc_embed_signup_scroll">
                            <div class="mc-field-group">
                                <label for="mce-EMAIL">Email Address </label>
                                <input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL">
                            </div>
                            <div class="mc-field-group">
                                <label for="mce-FNAME">First Name </label>
                                <input type="text" value="" name="FNAME" class="required" id="mce-FNAME">
                            </div>
                            <div id="mce-responses" class="clear">
                                <div class="response" id="mce-error-response" style="display:none"></div>
                                <div class="response" id="mce-success-response" style="display:none"></div>
                            </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
                            <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_89e1c97fa614ded06a44fbcfd_852c78303c" tabindex="-1" value=""></div>
                            <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
                            <div id="mergeRow-gdpr" class="mergeRow gdpr-mergeRow content__gdprBlock mc-field-group">
                                <div class="content__gdprLegal">
                                    <small>
                                        We use Mailchimp as our newsletter provider. By clicking subscribe, you acknowledge that your
                                        information will be transferred to Mailchimp for processing.
                                        <a href="https://mailchimp.com/legal/" target="_blank" rel="nofollow">Learn more about Mailchimp's privacy practices here.</a>
                                    </small>
                                </div>
                            </div>
                        </div>
                    </form>
                </div>
                <script type='text/javascript' src='//s3.amazonaws.com/downloads.mailchimp.com/js/mc-validate.js'></script><script type='text/javascript'>(function($) {window.fnames = new Array(); window.ftypes = new Array();fnames[0]='EMAIL';ftypes[0]='email';fnames[1]='FNAME';ftypes[1]='text';fnames[2]='LNAME';ftypes[2]='text';fnames[3]='ADDRESS';ftypes[3]='address';fnames[4]='PHONE';ftypes[4]='phone';fnames[5]='BIRTHDAY';ftypes[5]='birthday';}(jQuery));var $mcj = jQuery.noConflict(true);</script>
                <!--End mc_embed_signup-->
                <div style="text-align:center; margin-top:1em;">
                    <img src="/img/waving-bear.gif" alt="Waving bear" style="max-width:416px"/>
                </div>
                <h2>Comments</h2>
                <div id="disqus_thread"></div>
                <script>
                     var disqus_config = function () {
                        this.page.url = "https://www.pascallandau.com/blog/deploy-docker-compose-php-gcp-poc/";
                                                     this.page.identifier = "deploy-docker-compose-php-gcp-poc";
                                              };
                    (function() {  // DON'T EDIT BELOW THIS LINE
                        var d = document, s = d.createElement('script');

                        s.src = '//pascallandau.disqus.com/embed.js';

                        s.setAttribute('data-timestamp', +new Date());
                        (d.head || d.body).appendChild(s);
                    })();
                </script>
                <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
            </div>
        </div>
    </div>
</article>

<hr>

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="https://twitter.com/PascalLandau">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.linkedin.com/in/pascallandau">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/paslandau/">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.youtube.com/channel/UC8hVNCGAtz1DvOOpSQ3Nfzw">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-youtube fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.pascallandau.com/feed.xml">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                    </li>
                </ul>
                <p class="copyright text-muted">&copy; <a href="https://www.pascallandau.com">www.pascallandau.com</a> 2022                    built with <a href="https://github.com/tightenco/jigsaw">Jigsaw</a></p>
            </div>
        </div>
    </div>
</footer>
    <img src="https://ssl-vg03.met.vgwort.de/na/8ccbd67f658e4ad1ade1c5bdc5fd49a9" width="1" height="1" alt=""/>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>
<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>
<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js"></script>
<!-- Custom JavaScript -->
<script src="/js/main.js"></script>
<!-- Code highlighting 
     See source/img/highlight-js-languages.PNG for an overview of the selected languages 
     The files can be re-compiled at https://highlightjs.org/download/
     -->
<script src="/js/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</body>

</html>
