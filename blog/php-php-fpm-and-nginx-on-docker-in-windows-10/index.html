<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="Step-by-Step tutorial for setting up PHP Docker containers (cli and fpm)  for local development on Windows 10.">
            <meta name="author" content="Pascal Landau">
        <title>How to set up PHP, PHP-FPM and NGINX on Docker in Windows 10 [Tutorial Into] | pascallandau.com</title>
    <meta name="google-site-verification" content="fcW8afndMqg-HUmdh_fIAbz81qMkxVJA-Hogrg3UYEw"/>

    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link href="/css/clean-blog.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/css/main.css">
    <!-- highlight.js -->
    <link rel="stylesheet" href="/css/default.min.css">
    <!-- RSS Feed -->
    <link rel="canonical" href="https://www.pascallandau.com/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/"/>
        <link rel="alternate" type="application/rss+xml" title="pascallandau.com" href="https://www.pascallandau.com/feed.xml"/>
    <link rel="alternate" type="application/rss+xml" title="pascallandau.com - Finance related articles" href="https://www.pascallandau.com/feed-finance.xml"/>
    <!-- Custom Fonts -->
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || [];
            w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            });
            var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : '';
            j.async = true;
            j.src =
                'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-5B9NRTM');</script>
    <!-- End Google Tag Manager -->
</head>

<body>
<!-- Google Tag Manager (noscript) -->
<noscript>
    <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5B9NRTM"
            height="0" width="0" style="display:none;visibility:hidden"></iframe>
</noscript>
<!-- End Google Tag Manager (noscript) -->
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse"
                    data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">pascallandau.com</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right" id="navbar">
                <li>
                    <a href="/">Home</a>
                </li>
                <li>
                    <a href="/about/">About</a>
                </li>
                <li>
                    <a href="/blog/">Blog</a>
                </li>
                <li>
                    <a href="/blog/#newsletter">Newsletter</a>
                </li>
                <li>
                    <a href="/bigquery-snippets/">BigQuery Snippets</a>
                </li>
                <li>
                    <a href="/docker-php-tutorial/">Docker PHP Tutorial</a>
                </li>
                <li>
                    <a href="/personal-finance/">Personal Finance</a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

<!-- Page Header -->
<!-- Set your background image for this header on the line below. -->
<header class="intro-header" style="background: #000
        ">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Setting up PHP, PHP-FPM and NGINX for local development on Docker</h1>
                                            <h2 class="subheading">A primer on PHP on Docker under Windows 10.</h2>
                                                                <span class="meta">
                            <span style="display:block; margin:0;">
                                Posted by <a href="#">Pascal Landau</a> on 2018-07-08 22:00:00
                            </span>
                            <span style="display:block;">
                                <a href="https://twitter.com/PascalLandau">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-twitter fa-stack-1x"></i>
                                    </span>
                                </a>
                                <a href="https://www.linkedin.com/in/pascallandau">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-linkedin fa-stack-1x"></i>
                                    </span>
                                </a>
                                <a href="https://github.com/paslandau/">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-github fa-stack-1x"></i>
                                    </span>
                                </a>
                                <a href="https://www.youtube.com/channel/UC8hVNCGAtz1DvOOpSQ3Nfzw">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-youtube fa-stack-1x"></i>
                                    </span>
                                </a>
                            </span>
                        </span>
                                    </div>
            </div>
        </div>
    </div>
</header>

<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    
                <p>You probably heard from the new kid around the block called "Docker"?
You are a PHP developer and would like to get into that, but you didn't have the time to look into it, yet? 
Then this tutorial is for you! By the end of it, you should know:
- how to set up Docker "natively" on a Windows 10 machine
- how to build and run containers from the command line
- how to log into containers and explore them for information
- what a Dockerfile is and how to use it
- how containers can talk to each other
- how <code>docker-compose</code> can be used to fit everything nicely together</p>

<p><strong>Note</strong>: I will not only walk on the happy path during this tutorial. That means I'll deep-dive into
some things that are not completely related to docker (e.g. how to find out where the configuration
files for php-fpm are located), but that are imho important to understand, because they enable you to
solve problems later on your own.</p>

<p>But if you are short on time, you might also jump directly to <a href="#tl-dr">the tl;dr</a>.</p>

<p><strong>All code samples are publicly available</strong> in my
<a href="https://github.com/paslandau/docker-php-tutorial/">Docker PHP Tutorial repository on Github</a>.
The branch for this tutorial is
<a href="https://github.com/paslandau/docker-php-tutorial/tree/part_1_setting-up-php-php-fpm-and-nginx-for-local-development-on-docker">part_1_setting-up-php-php-fpm-and-nginx-for-local-development-on-docker</a>.</p>

<p><strong>All published parts of the Docker PHP Tutorial</strong> are collected under a dedicated page at
<a href="/docker-php-tutorial/">Docker PHP Tutorial</a>. The following part is
<a href="/blog/structuring-the-docker-setup-for-php-projects/">Setting up PhpStorm with Xdebug for local development on Docker</a> .</p>

<p>If you want to follow along, please subscribe to the <a href="/feed.xml">RSS feed</a>
or <a href="#newsletter">via email</a>
to get <strong>automatic notifications</strong> when the next part comes out :)</p>

<h2>Table of contents</h2>

<ul>
<li><a id="introduction">Introduction</a>
    <ul>
    <li><a href="#precondiction">Preconditions</a></li>
    <li><a href="#why-use-docker">Why use Docker?</a></li>
    <li><a href="#transition-vagrant">Transition from Vagrant</a></li>
    </ul>
</li>
<li><a href="#setup-docker">Setup Docker</a>    
<li><a href="#setup-php-cli">Setting up the PHP cli container</a>
    <ul>
        <li><a href="#xdebug-php">Installing Xdebug in the PHP container</a></li>
        <li><a href="#dockerfile">Persisting image changes with a Dockerfile</a></li>
    </ul>
</li> 
<li><a href="#webstack">Setting up a web stack with php-fpm and nginx</a>
    <ul>
        <li><a href="#setup-nginx">Setting up nginx</a></li>
        <li><a href="#setup-php-fpm">Setting up php-fpm</a>
            <ul>
                <li><a href="#php-fpm-xdebug">Installing xdebug</a></li>
            </ul>
        </li> 
        <li><a href="#connecting-nginx-php-fpm">Connecting nginx and php-fpm</a></li>
    </ul>
</li> 
<li><a href="#docker-compose">Putting it all together: Meet docker-compose</a></li>
<li><a href="#tl-dr">The tl;dr</a></li>
</ul>

<h2><a id="introduction"></a>Introduction</h2>

<h3><a id="precondiction"></a>Preconditions</h3>

<p>I'm assuming that you have installed <a href="https://git-scm.com/download/win">Git bash for Windows</a>. If not, please do that before, 
see <a href="http://www.pascallandau.com/blog/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/#git-and-git-bash">Setting up the software: Git and Git Bash</a>.</p>

<h3><a id="why-use-docker"></a>Why use Docker?</h3>

<p>I won't go into too much detail what Docker is and why you should use it, because 
<a href="https://www.linode.com/docs/applications/containers/when-and-why-to-use-docker/">others</a> 
<a href="https://www.zdnet.com/article/what-is-docker-and-why-is-it-so-darn-popular/">have</a>
<a href="https://stackoverflow.com/questions/16647069/should-i-use-vagrant-or-docker-for-creating-an-isolated-environment">already</a>
talked about this extensively.</p>

<p>As for me, my main reasons were
- Symlinks in vagrant didn't work the way they should
- VMs become bloated and hard to manage over time
- Setup in the team involved a lot of work
- I wanted to learn Docker for quite some time because you hear a lot about it</p>

<p>In general, Docker is kind of like a virtual machine, so it allows us to develop in an OS of our choice (e.g. Windows) 
but run the code in the same environment as it will in production (e.g. on a linux server). Thanks to its core principles, 
it makes the separation of services really easy (e.g. having a dedicated server for your database) which - again - 
is something that should happen on production anyway.</p>

<h3><a id="transition-vagrant"></a>Transition from Vagrant</h3>

<p>On Windows, you can either use the <a href="https://docs.docker.com/toolbox/toolbox_install_windows/">Docker Toolbox</a> 
(which is essentially a VM with Docker setup on it) or the Hyper-V based <a href="https://www.docker.com/docker-windows">Docker for Windows</a>. 
This tutorial will only look at the latter.</p>

<p><strong>A word of caution</strong>: Unfortunately, we cannot have other Gods besides Docker (on Windows). 
The native Docker client requires Hyper-V to be activated which in turn will cause Virtualbox to not work any longer. 
Thus, we will not be able to use Vagrant and Docker alongside each other. 
This was actually the main reason it took me so long to start working with Docker.</p>

<h2><a id="setup-docker"></a>Setup Docker</h2>

<p>First, <a href="https://store.docker.com/editions/community/docker-ce-desktop-windows">download Docker for Windows</a>
(requires Microsoft Windows 10 Professional or Enterprise 64-bit). The version I am using in this tutorial is <code>18.03.1-ce-win65</code>.
During the installation, 
leave the option "Use Windows Containers instead of Linux containers" unticked as we intend to develop on linux containers 
(you can change it later anyway).</p>

<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/use-linux-containers.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/use-linux-containers.PNG" alt="Install docker" /></a></p>

<p>After the installation finishes, we need to log out of Windows and in again. 
Docker should start automatically. If not, there should be a "Docker for Windows" icon placed on your desktop.
If Hyper-V is not activated yet, Docker will automatically urge you to do so now.</p>

<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/enable-hyper-v-and-containers.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/enable-hyper-v-and-containers.PNG" alt="Activate Hype-V" /></a></p>

<p>If you agree, Hyper-V and container features are activated and a reboot is initiated. 
See <a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v">Install Hyper-V on Windows 10</a>
to deactivate it again.</p>

<p><strong>Caution</strong>: VirtualBox will stop working afterwards! Starting one of my previous machines from the VirtualBox interface 
or via <code>vagrant up</code> fails with the error message</p>

<blockquote>
  <p>VT-x is not available (VERR_VMX_NO_VMX)</p>
</blockquote>

<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/virtual-box-error.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/virtual-box-error.PNG" alt="Virtual box error" /></a>
<a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/vagrant-error.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/vagrant-error.PNG" alt="Vagrant error" /></a></p>

<p>After rebooting, Docker will start automatically and a welcome screen appears.</p>

<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/welcome-screen.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/welcome-screen.PNG" alt="Docker welcome screen" /></a></p>

<p>We can ignore that (close the window). 
In addition, a new icon is added to your system tray. A right-click reveals the context menu.</p>

<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/system-tray-icon.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/system-tray-icon.PNG" alt="Docker settings in system tray" /></a></p>

<p>Open the tab "Shared Devices" and tick the hard drives on your host machine that you want to share with Docker containers.</p>

<p><em>Note: We will still need to define explicit path mappings for the actual containers later on, but the hard drive that the path belongs 
to must be made available here. After clicking "Apply", you will be prompted for your credentials</em></p>

<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-shared-drives.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-shared-drives.PNG" alt="Docker settings: Shared devices" /></a>
<a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-shared-drives-credentials.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-shared-drives-credentials.PNG" alt="Docker settings: Credential prompt" /></a></p>

<p>Next, open tab "Advanced". You don't actually have to change any of the settings but if you (like me) 
don't have <code>C:/</code> set up as you biggest partition, you might want to change the "Disk image location". 
I'm putting mine at <code>C:\Hyper-V\Virtual Hard Disks\MobyLinuxVM.vhdx</code>. It might take some minutes for Docker to process the changes.</p>

<p>Docker "physically" stores the container images in that location.</p>

<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-advanced-disk-image-location.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-advanced-disk-image-location.PNG" alt="Docker settings: Advanced" /></a></p>

<p>Congratulations, Docker is now set up on your machine 😊</p>

<h2><a id="setup-php-cli"></a>Setting up the PHP cli container</h2>

<p>Now that we have the general stuff out of the way, let's set up our first container. 
I've created the directory <code>C:/codebase/docker-php/</code> and will run the remaining examples in there.</p>

<p>Firstly, lets create a directory for our sourcecode:</p>

<pre><code>mkdir -p "C:/codebase/docker-php/app"
</code></pre>

<p>For the sake of simplicity, we will stick to the <a href="https://hub.docker.com/_/php/">official PHP image</a> and run:</p>

<pre><code>docker run -d --name docker-php -v "C:/codebase/docker-php/app":/var/www php:7.0-cli
</code></pre>

<p>Which means:</p>

<pre><code>docker run                               // run a container
-d                                       // in the background (detached)
--name docker-php                        // named docker-php
-v "C:/codebase/docker-php/app":/var/www // sync the directory C:/codebase/docker-php/app on the 
                                         // windows host with /var/www in the container
php:7.0-cli                              // use this image to build the container
</code></pre>

<p>The result looks something like this:</p>

<pre><code>$ docker run -d --name docker-php -v "C:/codebase/docker-php/app":/var/www php:7.0-cli
Unable to find image 'php:7.0-cli' locally
7.0-cli: Pulling from library/php
f2aa67a397c4: Pulling fs layer
c533bdb78a46: Pulling fs layer
65a7293804ac: Pulling fs layer
35a9c1f94aea: Pulling fs layer
54cffc62e1c2: Pulling fs layer
153ff2f4c2af: Pulling fs layer
96d392f71f56: Pulling fs layer
e8c43e665458: Pulling fs layer
35a9c1f94aea: Waiting
54cffc62e1c2: Waiting
153ff2f4c2af: Waiting
96d392f71f56: Waiting
e8c43e665458: Waiting
c533bdb78a46: Verifying Checksum
c533bdb78a46: Download complete
35a9c1f94aea: Verifying Checksum
35a9c1f94aea: Download complete
f2aa67a397c4: Verifying Checksum
f2aa67a397c4: Download complete
153ff2f4c2af: Verifying Checksum
153ff2f4c2af: Download complete
54cffc62e1c2: Verifying Checksum
54cffc62e1c2: Download complete
e8c43e665458: Verifying Checksum
e8c43e665458: Download complete
96d392f71f56: Verifying Checksum
96d392f71f56: Download complete
f2aa67a397c4: Pull complete
65a7293804ac: Verifying Checksum
65a7293804ac: Download complete
c533bdb78a46: Pull complete
65a7293804ac: Pull complete
35a9c1f94aea: Pull complete
54cffc62e1c2: Pull complete
153ff2f4c2af: Pull complete
96d392f71f56: Pull complete
e8c43e665458: Pull complete
Digest: sha256:ff6c5e695a931f18a5b59c82b1045edea42203a299e89a554ebcd723df8b9014
Status: Downloaded newer image for php:7.0-cli
56af890e1a61f8ffa5528b040756dc62a94c0b929c29df82b9bf5dec6255321f
</code></pre>

<p>Since we don't have the image on our machine (see <code>Unable to find image 'php:7.0-cli' locally</code>), 
Docker attempts to pull it from the official registry at https://hub.docker.com/. 
We've specifically chosen the "7.0-cli" version of the PHP image (which means: PHP 7.0 CLI only). 
See https://hub.docker.com/_/php/ for a list of all available tags/images.</p>

<p>Now let's see if the container is actually running via <code>docker ps</code></p>

<pre><code>$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></pre>

<p>Weird. For some reason, we don't see our newly created container there. Let's check with the <code>-a</code> flag to list <strong>all</strong> containers, 
even the ones that are not running.</p>

<pre><code>$ docker ps -a
CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS                      PORTS               NAMES
56af890e1a61        php:7.0-cli         "docker-php-entrypoi…"   27 seconds ago     Exited (0) 25 seconds ago                       docker-php
</code></pre>

<p>Aha. So the container was created, but immediately stopped (see <code>Created 27 seconds ago; Exited (0) 25 seconds ago</code>). 
That's because a container only <a href="https://stackoverflow.com/a/28214133/413531">lives as long as it's main process is running</a>.
According to <a href="https://docs.docker.com/config/containers/multi-service_container/">the docs</a>,</p>

<blockquote>
  <p>A container's main running process is the ENTRYPOINT and/or CMD at the end of the Dockerfile."</p>
</blockquote>

<p><a href="https://stackoverflow.com/a/21564990/413531">This answer explains the difference between CMD and ENTRYPOINT</a> quite well. 
Since we don't have a Dockerfile defined, we would need to look at the 
<a href="https://github.com/docker-library/php/blob/27c65bbd606d1745765b89bf43f39b06efad1e43/7.0/stretch/cli/Dockerfile">Dockerfile of the base image</a> 
we're using, but I actually don't wanna go down this rabbit hole for now. Basically, the "problem" is, that the
container doesn't have a long running process / service defined, (as the php-fpm or the nginx containers do later on).
To keep the container alive, we need to add the <code>-i</code> flag to the <code>docker run</code> command:</p>

<pre><code>docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www php:7.0-cli
</code></pre>

<p>But then this happens:</p>

<pre><code>Pascal@Landau-Laptop MINGW64 /
$ docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www php:7.0-cli
C:\Program Files\Docker\Docker\Resources\bin\docker.exe: Error response from daemon: Conflict. The container name "/docker-php" is already in use by container "56af890e1a61f8ffa5528b040756dc62a94c0b929c29df82b9bf5dec6255321f". You have to remove (or rename) that container to be able to reuse that name.
See 'C:\Program Files\Docker\Docker\Resources\bin\docker.exe run --help'.
</code></pre>

<p>Apparently, we cannot use the same name (<code>docker-php</code>) again. Bummer. So, let's remove the previous container first via</p>

<pre><code>docker rm docker-php
</code></pre>

<p>and try again afterwards:</p>

<pre><code>Pascal@Landau-Laptop MINGW64 /
$ docker rm docker-php
docker-php

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www php:7.0-cli
7b3024a542a2d25fd36cef96f4ea689ec7ebb758818758300097a7be3ad2c2f6

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker ps
CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS              PORTS               NAMES
7b3024a542a2        php:7.0-cli         "docker-php-entrypoi…"   5 seconds ago      Up 4 seconds                            docker-php
</code></pre>

<p>Sweet, so now that the container is up and running, let's "<a href="https://stackoverflow.com/a/30173220">log in</a>" via</p>

<pre><code>docker exec -it docker-php bash
</code></pre>

<p>You might get the following error message</p>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker exec -it docker-php bash
the input device is not a TTY.  If you are using mintty, try prefixing the command with 'winpty'
</code></pre>

<p>If so, prefixing the command with <code>winpty</code> should help:</p>

<pre><code>winpty docker exec -it docker-php bash
</code></pre>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ winpty docker exec -it docker-php bash
root@7b3024a542a2:/#
</code></pre>

<p>A quick <code>php -v</code> within the container verifies, that we can actually run php scripts in there:</p>

<pre><code>root@7b3024a542a2:/# php -v
PHP 7.0.30 (cli) (built: May 23 2018 23:04:32) ( NTS )
Copyright (c) 1997-2017 The PHP Group
Zend Engine v3.0.0, Copyright (c) 1998-2017 Zend Technologies
</code></pre>

<p>Remember the path mapping, that we specified? Let's create a simple "hello world" script <strong>on the windows 10 host machine</strong> 
at <code>C:\codebase\docker-php\app\hello-world.php</code> to make sure it works:</p>

<pre><code>cd "C:\codebase\docker-php\app"
echo '&lt;?php echo "Hello World (php)\n"; ?&gt;' &gt; hello-world.php
</code></pre>

<p>Should look like this on the host machine:</p>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ ls -alh app
total 1,0K
drwxr-xr-x 1 Pascal 197121  0 Mai 28 12:29 ./
drwxr-xr-x 1 Pascal 197121  0 Mai 28 11:46 ../
-rw-r--r-- 1 Pascal 197121 49 Mai 28 12:30 hello-world.php
</code></pre>

<p>And like this from within the container:</p>

<pre><code>root@7b3024a542a2:/# ls -alh /var/www
total 4.5K
drwxr-xr-x 2 root root  0 May 28 10:29 .
drwxr-xr-x 1 root root 4.0K May 28 10:00 ..
-rwxr-xr-x 1 root root   31 May 28 10:31 hello-world.php
</code></pre>

<p>Let's run the script <strong>in the container</strong> via</p>

<pre><code>php /var/www/hello-world.php
</code></pre>

<pre><code>root@7b3024a542a2:/# php /var/www/hello-world.php
Hello World
</code></pre>

<p>Purrfect. We created the file on our host system and it's automatically available in the container.</p>

<h3><a id="xdebug-php"></a>Installing Xdebug in the PHP container</h3>

<p>Since we intend to use Docker for our local development setup, the ability to debug is mandatory. So let's extend our image with the xdebug extension.
The readme of the official Docker PHP repository does a good job at explaining 
<a href="https://github.com/docker-library/docs/blob/master/php/README.md#how-to-install-more-php-extensions">how to install extensions</a>. 
For xdebug, we'll use PECL. To install the extension, make sure to be logged into the container and run</p>

<pre><code>pecl install xdebug-2.6.0
</code></pre>

<p>You should see an output like this:</p>

<pre><code>root@7b3024a542a2:/# pecl install xdebug-2.6.0
[...]
Build process completed successfully
Installing '/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so'
install ok: channel://pecl.php.net/xdebug-2.6.0
configuration option "php_ini" is not set to php.ini location
You should add "zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so" to php.ini
</code></pre>

<p>The xdebug extension has been build and saved in <code>/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so</code>. 
To actually activate it, run</p>

<pre><code>docker-php-ext-enable xdebug
</code></pre>

<p>That helper command will place the file <code>docker-php-ext-xdebug.ini</code> in the directory for additional php ini files with the content</p>

<pre><code>zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so
</code></pre>

<p>which enables the extension. Btw. you can locate the additional php ini files folder by running</p>

<pre><code>php -i | grep "additional .ini"
</code></pre>

<p>Result:</p>

<pre><code>root@7b3024a542a2:/# php -i | grep "additional .ini"
Scan this dir for additional .ini files =&gt; /usr/local/etc/php/conf.d
</code></pre>

<p>When we check the contents of that folder, we will indeed find the <code>xdebug.ini</code> file with the before mentioned content and <code>php -m</code> reveals, 
that xdebug is actually active.</p>

<pre><code>root@7b3024a542a2:/# ls -alh /usr/local/etc/php/conf.d
total 12K
drwxr-sr-x 1 root staff 4.0K May 28 13:30 .
drwxr-sr-x 1 root staff 4.0K Apr 30 20:34 ..
-rw-r--r-- 1 root staff   81 May 28 13:30 docker-php-ext-xdebug.ini
root@7b3024a542a2:/# cat /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini
zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so
root@7b3024a542a2:/# php -m | grep xdebug
xdebug
</code></pre>

<p>Now we'll log out of the container (type "exit" or hit <code>CTRL</code> +<code>D</code>) and stop the container via</p>

<pre><code>docker stop docker-php
</code></pre>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker stop docker-php
docker-php

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker ps -a
CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS                      PORTS               NAMES
7b3024a542a2        php:7.0-cli         "docker-php-entrypoi…"   2 hours ago        Exited (137) 7 seconds ago                      docker-php
</code></pre>

<p>Now we start the container again via</p>

<pre><code>docker start docker-php
</code></pre>

<p>log back in and check if xdebug is still there:</p>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker start docker-php
docker-php

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ winpty docker exec -it docker-php bash
root@7b3024a542a2:/# php -m | grep xdebug
xdebug
</code></pre>

<p>And... it is! So the changes we made "survived" a restart of the container. But: They won't survive a "rebuild" of the container.
First we stop and remove the container via</p>

<pre><code>docker rm -f docker-php
</code></pre>

<p>The <code>-f</code> flag forces the container to stop. Otherwise we would need an additional <code>docker stop docker-php</code> before.</p>

<p>Then we rebuild it, log in</p>

<pre><code>docker run -di --name docker-php -v "C:/codebase/docker-php/":/codebase php:7.0-cli
inpty docker exec -it docker-php bash
</code></pre>

<p>and check for xdebug:</p>

<pre><code>php -m | grep xdebug
</code></pre>

<p>... which won't be there anymore.</p>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker rm -f docker-php
docker-php

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker run -di --name docker-php -v "C:/codebase/docker-php/":/codebase php:7.0-cli
1da17524418f5327760eb113904b7ceec30f22b41e4b4bd77f9fa2f7b92b4ead

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ winpty docker exec -it docker-php bash
root@1da17524418f:/# php -m | grep xdebug
root@1da17524418f:/#
</code></pre>

<p>Note the new container ID (before: <code>7b3024a542a2</code>; now: <code>1da17524418f</code>) and that <code>php -m | grep xdebug</code> doesn't yield anything.</p>

<h3><a id="dockerfile"></a>Persisting image changes with a Dockerfile</h3>

<p>Simply put, a <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile</a> describes the changes we make to a base image, 
so we (and everybody else) can easily recreate the same environment. In our case, 
we need to define the PHP base image that we used as well as instructions for installing and enabling xdebug.
To clearly separate infrastructure from code, we'll create a new directory at <code>C:/codebase/docker-php/php-cli/</code>. 
Create a file named <code>Dockerfile</code> in this directory</p>

<pre><code>mkdir "C:/codebase/docker-php/php-cli/"
touch "C:/codebase/docker-php/php-cli/Dockerfile"
</code></pre>

<p>and give it the following content:</p>

<pre><code>FROM php:7.0-cli
RUN pecl install xdebug-2.6.0 \
    &amp;&amp; docker-php-ext-enable xdebug
</code></pre>

<p>Change to the <code>C:/codebase/docker-php/php-cli/</code> directory and build the image based on that Dockerfile</p>

<pre><code>cd "C:/codebase/docker-php/php-cli/"
docker build -t docker-php-image -f Dockerfile .
</code></pre>

<p>The <code>-f Dockerfile</code> is actually optional as this is the default anyway. "docker-php-image" is the name of our new image.</p>

<p>If you encounter the following error</p>

<pre><code>"docker build" requires exactly 1 argument.
See 'docker build --help'.

Usage:  docker build [OPTIONS] PATH | URL | - [flags]

Build an image from a Dockerfile
</code></pre>

<p>you probably missed the trailing <code>.</code> at the end of <code>docker build -t docker-php-image -f Dockerfile .</code> ;)</p>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker build -t docker-php-image -f Dockerfile .
Sending build context to Docker daemon   5.12kB
Step 1/2 : FROM php:7.0-cli
 ---&gt; da771ba4e565
Step 2/2 : RUN pecl install xdebug-2.6.0    &amp;&amp; docker-php-ext-enable xdebug
 ---&gt; Running in ff16ef56e648
downloading xdebug-2.6.0.tgz ...
Starting to download xdebug-2.6.0.tgz (283,644 bytes)
[...]
You should add "zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so" to php.ini
Removing intermediate container ff16ef56e648
 ---&gt; 12be27256b12
Successfully built 12be27256b12
Successfully tagged docker-php-image:latest
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have '-rwxr-xr-x' permissions. It is recommended to double check and reset permissions for sensitive files and directories.
</code></pre>

<p>Note, that the building takes longer than before, because Docker now needs to do the extra work of installing xdebug. 
Instead of using the base <code>php:7.0-cli</code> image, we'll now use our new, shiny <code>docker-php-image</code> image to start the container and check for xdebug.</p>

<pre><code>docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www docker-php-image
</code></pre>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www docker-php-image
C:\Program Files\Docker\Docker\Resources\bin\docker.exe: Error response from daemon: Conflict. The container name "/docker-php" is already in use by container "2e84cb536fc573142a9951331b16393e3028d9c6eff87f89cfda682279634a2b". You have to remove (or rename) that container to be able to reuse that name.
See 'C:\Program Files\Docker\Docker\Resources\bin\docker.exe run --help'.
</code></pre>

<p>Aaaand we get an error, because we tried to use the same name ("docker-php"), that we used for the previous, still running container.
Sigh.. fortunately we already know how to solve that via</p>

<pre><code>docker rm -f docker-php
</code></pre>

<p>Retry</p>

<pre><code>docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www docker-php-image
</code></pre>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker rm -f docker-php
docker-php

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www docker-php-image
f27cc1310c836b15b7062e1fd381f283250a85133fb379c4cf1f891dec63770b

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ winpty docker exec -it docker-php bash
root@f27cc1310c83:/# php -m | grep xdebug
xdebug
</code></pre>

<p>Yep, all good. Btw. since we "only" want to check if xdebug was installed, we could also simply pass <code>-m</code> to the <code>docker run</code> command:</p>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker run docker-php-image php -m | grep xdebug
xdebug
</code></pre>

<p>Be aware that this will create a new container every time it's run (, note the first entry with the wonderful name "distracted_mclean"):</p>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker ps -a
CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS                      PORTS               NAMES
abc9fec8a88b        docker-php-image    "docker-php-entrypoi…"   4 minutes ago      Exited (0) 4 minutes ago                        distracted_mclean
f27cc1310c83        docker-php-image    "docker-php-entrypoi…"   10 minutes ago     Exited (137) 6 minutes ago                      docker-php
</code></pre>

<p>Before we move on, let's []stop and remove all containers via](https://coderwall.com/p/ewk0mq/stop-remove-all-docker-containers).</p>

<pre><code>docker rm -f $(docker ps -aq)
</code></pre>

<p>The <code>$(docker ps -aq)</code> part returns only the numeric ids of all containers and passes them to the <code>docker rm -f</code> command.</p>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker rm -f $(docker ps -aq)
abc9fec8a88b
f27cc1310c83
</code></pre>

<h2><a id="webstack"></a>Setting up a web stack with php-fpm and nginx</h2>

<p>Since most people are probably not only working on CLI scripts but rather on web pages, 
the next step in this tutorial is about setting up an nginx web server and connect it to php-fpm.</p>

<h3><a id="setup-nginx"></a>Setting up nginx</h3>

<p>We're gonna use the <a href="https://hub.docker.com/_/nginx/">official nginx image</a> and since we don't know anything about that image yet, 
let's run and explore it a bit:</p>

<pre><code>docker run -di nginx:latest
</code></pre>

<p>yields</p>

<pre><code>Pascal@Landau-Laptop MINGW64 /
$ docker run -di nginx:latest
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
[...]
Status: Downloaded newer image for nginx:latest
15c6b8d8a2bff873f353d24dc9c40d3008da9396029b3f1d9db7caeebedd3f50
</code></pre>

<p>Note that we only used the minimum number of arguments here. Since we did not specify a name, we will simply use the ID instead to log in
(so be sure to use the one that your shell returned - don't just copy the line below :P)</p>

<pre><code>$ winpty docker exec -it 15c6b8d8a2bff873f353d24dc9c40d3008da9396029b3f1d9db7caeebedd3f50 bash
root@15c6b8d8a2bf:/#
</code></pre>

<p>We would expect that there is an nginx process running, but upon checking with <code>ps aux</code> we get</p>

<pre><code>bash: ps: command not found" as a response. 
</code></pre>

<p>This is common when using docker images, because they are usually kept as minimal as possible. 
 Although this is a good practice in production, it is kind of cumbersome in development. 
 So, let's install <code>ps</code> via</p>

<pre><code>apt-get update &amp;&amp; apt-get install -y procps
</code></pre>

<p>and try again:</p>

<pre><code>root@15c6b8d8a2bf:/# apt-get update &amp;&amp; apt-get install -y procps
Get:1 http://security.debian.org/debian-security stretch/updates InRelease [94.3 kB]
[...] 
associated file /usr/share/man/man1/w.procps.1.gz (of link group w) doesn't exist
Processing triggers for libc-bin (2.24-11+deb9u3) ...
root@15c6b8d8a2bf:/# ps aux
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root          1  0.0  0.2  32608  5148 ?        Ss   06:46   0:00 nginx: master process nginx -g daemon off;
nginx         5  0.0  0.1  33084  2388 ?        S    06:46   0:00 nginx: worker process
root         14  0.0  0.1  18132  3272 pts/0    Ss   06:50   0:00 bash
root        259  0.0  0.1  36636  2844 pts/0    R+   06:53   0:00 ps aux
root@15c6b8d8a2bf:/#
</code></pre>

<p>Ah. Much better. Lets dig a little deeper and see how the process is configured via <code>nginx -V</code></p>

<pre><code>root@15c6b8d8a2bf:/# nginx -V
nginx version: nginx/1.13.12
built by gcc 6.3.0 20170516 (Debian 6.3.0-18+deb9u1)
built with OpenSSL 1.1.0f  25 May 2017
TLS SNI support enabled
configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/ng
inx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path
=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-
http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module
 --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_
module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt='-g -O2 -fdebug-prefix-map=/data/builder/debuild/nginx-1.13.12/debian/debuild-base/nginx-
1.13.12=. -specs=/usr/share/dpkg/no-pie-compile.specs -fstack-protector-strong -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fPIC' --with-ld-opt='-specs=/usr/share/dpkg/no-pie-link.specs -Wl,-z,relr
o -Wl,-z,now -Wl,--as-needed -pie'
</code></pre>

<p>Sweet, so the configuration file is placed in the default location at <code>/etc/nginx/nginx.conf</code> 
(see <code>--conf-path=/etc/nginx/nginx.conf</code>). Checking that file will show us, where we need to place additional config files 
(e.g. for the configuration of our web site). Run</p>

<pre><code>cat /etc/nginx/nginx.conf
</code></pre>

<p>... and see</p>

<pre><code>root@15c6b8d8a2bf:/# cat /etc/nginx/nginx.conf

user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}
</code></pre>

<p>Note the line <code>include /etc/nginx/conf.d/*.conf</code> at the end of the file. In this directory, we'll find the default nginx config:</p>

<pre><code>ls -alh /etc/nginx/conf.d/
cat /etc/nginx/conf.d/default.conf
</code></pre>

<pre><code>root@15c6b8d8a2bf:/# ls -alh /etc/nginx/conf.d/
total 12K
drwxr-xr-x 2 root root 4.0K Apr 30 13:55 .
drwxr-xr-x 3 root root 4.0K Apr 30 13:55 ..
-rw-r--r-- 1 root root 1.1K Apr  9 16:01 default.conf
root@15c6b8d8a2bf:/# cat /etc/nginx/conf.d/default.conf
server {
    listen       80;
    server_name  localhost;

    #charset koi8-r;
    #access_log  /var/log/nginx/host.access.log  main;

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    # proxy the PHP scripts to Apache listening on 127.0.0.1:80
    #
    #location ~ \.php$ {
    #    proxy_pass   http://127.0.0.1;
    #}

    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    #
    #location ~ \.php$ {
    #    root           html;
    #    fastcgi_pass   127.0.0.1:9000;
    #    fastcgi_index  index.php;
    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
    #    include        fastcgi_params;
    #}

    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
}
</code></pre>

<p>So the server is listening on port 80. Unfortunately, we cannot reach the web server from our windows host machine, 
as there is currently (2018-05-31) an <a href="https://github.com/docker/for-win/issues/221">open bug for accessing container IPs from a windows host</a> 
(don't worry, we'll fix that with port mappings in a second)). 
So, in order to verify that the server is actually  working, we'll install <code>curl</code> inside the nginx container and fetch <code>127.0.0.1:80</code>:</p>

<pre><code>apt-get install curl -y
curl localhost:80
</code></pre>

<p>Looks like this:</p>

<pre><code>root@15c6b8d8a2bf:/# apt-get install curl -y
Reading package lists... Done
Building dependency tree
[...]
Running hooks in /etc/ca-certificates/update.d...
done.
root@15c6b8d8a2bf:/# curl localhost:80
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Looks good! Now let's customize some stuff:
- point the root to <code>/var/www</code>
- place a "Hello world" index file in <code>/var/www/index.html</code></p>

<pre><code>sed -i "s#/usr/share/nginx/html#/var/www#" /etc/nginx/conf.d/default.conf
mkdir -p /var/www
echo "Hello world!" &gt; /var/www/index.html
</code></pre>

<p>To make the changes become effective, we need to <a href="http://nginx.org/en/docs/beginners_guide.html#control">reload nginx</a> via</p>

<pre><code>nginx -s reload
</code></pre>

<pre><code>root@15c6b8d8a2bf:/# nginx -s reload
2018/05/29 09:22:54 [notice] 351#351: signal process started
</code></pre>

<p>Check with curl, et voilá:</p>

<pre><code>root@15c6b8d8a2bf:/# curl 127.0.0.1:80
Hello world!
</code></pre>

<p>With all that new information we can set up our nginx image with the following folder structure on the host machine:</p>

<pre><code>C:\codebase\docker-php
+ nginx\
  + conf.d\
    - site.conf
  - Dockerfile
+ app\
  - index.html
  - hello-world.php
</code></pre>

<p><code>nginx\Dockerfile</code></p>

<pre><code>FROM nginx:latest
</code></pre>

<p><code>nginx\conf.d\site.conf</code></p>

<pre><code>server {
    listen      80;
    server_name localhost;
    root        /var/www;
}
</code></pre>

<p><code>app\index.html</code></p>

<pre><code>Hello World
</code></pre>

<p>Clean up the "exploration" nginx container, <code>cd</code> into <code>/c/codebase/docker-php/nginx</code> and build the new image:</p>

<pre><code>docker rm -f $(docker ps -aq)
cd /c/codebase/docker-php/nginx
docker build -t docker-nginx-image .
</code></pre>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker rm -f $(docker ps -aq)
15c6b8d8a2bf
Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ cd nginx
Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/nginx
$ docker build -t docker-nginx-image .
Sending build context to Docker daemon  3.584kB
Step 1/1 : FROM nginx:latest
 ---&gt; ae513a47849c
Successfully built ae513a47849c
Successfully tagged docker-nginx-image:latest
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have '-rwxr-xr-x' permissions. It is recommended to double check and reset permissions for sensitive files and directories.
</code></pre>

<p>And then run the "new" container via</p>

<pre><code>docker run -di --name docker-nginx -p 8080:80 -v "C:\codebase\docker-php\nginx\conf.d":/etc/nginx/conf.d/ -v "C:\codebase\docker-php\app":/var/www docker-nginx-image
</code></pre>

<p>where</p>

<pre><code>-p 8080:80                                                  // maps port 8080 on the windows host to port 80 in the container
-v "C:\codebase\docker-php\nginx\conf.d":/etc/nginx/conf.d/ // mounts the conf.d folder on the host to the correct directory in the container
-v "C:\codebase\docker-php\app":/var/www                    // mounts the "code" directory in the correct place
</code></pre>

<p>Thanks to the port mapping we can now simply open http://127.0.0.1:8080/ in a browser on the host machine 
and see the content of our <code>app\index.html</code> file.</p>

<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-nginx.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-nginx.PNG" alt="nginx index file" /></a></p>

<p>If you want some more information about running nginx on Docker, check out 
<a href="https://www.digitalocean.com/community/tutorials/how-to-run-nginx-in-a-docker-container-on-ubuntu-14-04">this tutorial</a>.</p>

<p>Before we move on, let's clean up</p>

<pre><code>docker stop docker-nginx
</code></pre>

<h3><a id="setup-php-fpm"></a>Setting up php-fpm</h3>

<p>We are already familiar with the official docker PHP image but have only used the cli-only version so far. 
FPM ones can be pulled in by using the <code>-fpm</code> tags (e.g. like <code>php:7.0-fpm</code>).
As with nginx, let's explore the php-fpm image first:</p>

<pre><code>docker run -di --name php-fpm-test php:7.0-fpm
</code></pre>

<p>The first thing to note is, that the image automatically exposes port 9000 as a <code>docker ps</code> reveals:</p>

<pre><code>$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                  NAMES
c5d23b694563        php:7.0-fpm         "docker-php-entrypoi…"   4 hours ago         Up 4 hours                  9000/tcp               php-fpm-test
</code></pre>

<p>When we examine the Dockerfile that was used to build the image 
(click <a href="https://hub.docker.com/r/library/php/">here</a> and search for the "7.0-fpm" tag 
that currently (2018-05-31) links <a href="https://github.com/docker-library/php/blob/27c65bbd606d1745765b89bf43f39b06efad1e43/7.0/stretch/fpm/Dockerfile">here</a>), 
we can see that it contains an <code>EXPOSE 9000</code> at the bottom.</p>

<p>What else we can we figure out...</p>

<pre><code>winpty docker exec -it php-fpm-test bash
</code></pre>

<p>First, will check where the configuration files are located via <code>php-fpm -i | grep config</code>:</p>

<pre><code>root@c5d23b694563:/var/www/html# php-fpm -i | grep config
Configure Command =&gt;  './configure'  '--build=x86_64-linux-gnu' '--with-config-file-path=/usr/local/etc/php' '--with-config-file-scan-dir=/usr/local/etc/php/conf.d' '--enable-option-checking=fatal' '--disable-c
gi' '--with-mhash' '--enable-ftp' '--enable-mbstring' '--enable-mysqlnd' '--with-curl' '--with-libedit' '--with-openssl' '--with-zlib' '--with-libdir=lib/x86_64-linux-gnu' '--enable-fpm' '--with-fpm-user=www-da
ta' '--with-fpm-group=www-data' 'build_alias=x86_64-linux-gnu'
fpm.config =&gt; no value =&gt; no value
[...]

</code></pre>

<p><code>--with-config-file-path=/usr/local/etc/php</code> is our suspect. So it is very likely, 
that we will find the <a href="https://myjeeva.com/php-fpm-configuration-101.html#global-directives">global directives config file</a> at 
<code>/usr/local/etc/php-fpm.conf</code> (unfortunately, we cannot resolve the location directly). 
<code>grep</code>'ing this file for <code>include=</code> reveals the location for the 
<a href="https://myjeeva.com/php-fpm-configuration-101.html#pool-directives">pool directives config</a>:</p>

<pre><code>grep "include=" /usr/local/etc/php-fpm.conf
</code></pre>

<pre><code>root@c5d23b694563:/var/www/html# grep "include=" /usr/local/etc/php-fpm.conf
include=etc/php-fpm.d/*.conf
</code></pre>

<p>Hm - a relative path. That looks kinda odd? Let's get a little more context with the <code>-C</code> option for <code>grep</code>:</p>

<pre><code>grep -C 6 "include=" /usr/local/etc/php-fpm.conf
</code></pre>

<pre><code>root@c5d23b694563:/var/www/html# grep -C 6 "include=" /usr/local/etc/php-fpm.conf
; Include one or more files. If glob(3) exists, it is used to include a bunch of
; files from a glob(3) pattern. This directive can be used everywhere in the
; file.
; Relative path can also be used. They will be prefixed by:
;  - the global prefix if it's been set (-p argument)
;  - /usr/local otherwise
include=etc/php-fpm.d/*.conf
</code></pre>

<p>Ah - that makes more sense. So we need to resolve <code>etc/php-fpm.d/*.conf</code> relative to <code>/usr/local</code>. 
Resulting in <code>/usr/local/etc/php-fpm.d/*.conf</code> (usually you'll at least find a <code>www.conf</code> file in there). 
The pool config determines amongst other things how php-fpm listens for connections (e.g. via Unix socket or via TCP IP:port).</p>

<pre><code>cat /usr/local/etc/php-fpm.d/www.conf
</code></pre>

<pre><code>root@c5d23b694563:/var/www/html# cat /usr/local/etc/php-fpm.d/www.conf
[...]
; The address on which to accept FastCGI requests.
; Valid syntaxes are:
;   'ip.add.re.ss:port'    - to listen on a TCP socket to a specific IPv4 address on
;                            a specific port;
;   '[ip:6:addr:ess]:port' - to listen on a TCP socket to a specific IPv6 address on
;                            a specific port;
;   'port'                 - to listen on a TCP socket to all addresses
;                            (IPv6 and IPv4-mapped) on a specific port;
;   '/path/to/unix/socket' - to listen on a unix socket.
; Note: This value is mandatory.
listen = 127.0.0.1:9000
[...]
</code></pre>

<p>php-fpm ist listening on port 9000 on 127.0.0.1 (localhost). So it makes total sense to expose port 9000.</p>

<h4><a id="php-fpm-xdebug"></a>Installing xdebug</h4>

<p>Since we probably also want to debug php-fpm, xdebug needs to be setup as well. The process is pretty much the same as for the cli image:</p>

<pre><code>pecl install xdebug-2.6.0
docker-php-ext-enable xdebug
php-fpm -m | grep xdebug
</code></pre>

<p>Of course we'll also put that in its own Dockerfile:</p>

<pre><code>C:\codebase\docker-php
+ php-fpm\
  - Dockerfile
</code></pre>

<p><code>php-fpm\Dockerfile</code></p>

<pre><code>FROM php:7.0-fpm
RUN pecl install xdebug-2.6.0 \
    &amp;&amp; docker-php-ext-enable xdebug
</code></pre>

<p>Clean up the test container and build the new image</p>

<pre><code>docker rm -f php-fpm-test
cd /c/codebase/docker-php/php-fpm
docker build -t docker-php-fpm-image .
</code></pre>

<h3><a id="connecting-nginx-php-fpm"></a>Connecting nginx and php-fpm</h3>

<p>Now that we have containers for nginx and php-fpm, we need to connect them. 
To do so, we have to make sure that both containers are in the same network and can talk to each other
(<a href="https://stackoverflow.com/questions/29905953/how-to-correctly-link-php-fpm-and-nginx-docker-containers">which is a common problem</a>). 
Docker provides so called 
<a href="https://docs.docker.com/network/network-tutorial-standalone/#use-user-defined-bridge-networks">user defined bridge networks</a> 
allowing <strong>automatic service discovery</strong>. That basically means, 
that our nginx container can use <em>the name</em> of the php-fpm container to connect to it. 
Otherwise we would have to figure out the containers <em>IP address</em> in the default network every time we start the containers.</p>

<pre><code>docker network ls
</code></pre>

<p>reveals a list of the current networks</p>

<pre><code>Pascal@Landau-Laptop MINGW64 /
$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
7019b0b37ba7        bridge              bridge              local
3820ad97cc92        host                host                local
03fecefbe8c9        none                null                loca
</code></pre>

<p>Now let's add a new one called <code>web-network</code> for our web stack via</p>

<pre><code>docker network create --driver bridge web-network
</code></pre>

<pre><code>Pascal@Landau-Laptop MINGW64 /
$ docker network create --driver bridge web-network
20966495e04e9f9df9fd64fb6035a9e9bc3aa6d83186dcd23454e085a0d97648

Pascal@Landau-Laptop MINGW64 /
$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
7019b0b37ba7        bridge              bridge              local
3820ad97cc92        host                host                local
03fecefbe8c9        none                null                local
20966495e04e        web-network         bridge              local
</code></pre>

<p>Start the nginx container and connect it to the new network via</p>

<pre><code>docker start docker-nginx
docker network connect web-network docker-nginx
</code></pre>

<p>Finally, we need to mount the local code folder <code>app\</code> we mounted to the nginx container at <code>/var/www</code>
also in the php-fpm container in the same location:</p>

<pre><code>docker run -di --name docker-php-fpm -v "C:\codebase\docker-php\app":/var/www --network web-network docker-php-fpm-image
</code></pre>

<p>Note that we specified the network in the run command via the <code>--network</code> option.
We can verify that both containers are connected to the <code>web-network</code> by running</p>

<pre><code>docker network inspect web-network
</code></pre>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-fpm
$ docker network inspect web-network
[
    {
        "Name": "web-network",
        "Id": "20966495e04e9f9df9fd64fb6035a9e9bc3aa6d83186dcd23454e085a0d97648",
        "Created": "2018-05-30T06:39:44.3107066Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "3358e813423165880d59c8ebc2cb4c563ee8ad1d401595f8bfcf763ff5db8f4a": {
                "Name": "docker-php-fpm",
                "EndpointID": "d2f1d6285a0932817e1fb8839bef3a6d178f5306a2116307dba200038ea2a3a3",
                "MacAddress": "02:42:ac:12:00:03",
                "IPv4Address": "172.18.0.3/16",
                "IPv6Address": ""
            },
            "eaa5c05942788985e90a80fa000723286e9b4e7179d0f6f431c0f5109e012764": {
                "Name": "docker-nginx",
                "EndpointID": "274fa9a6868aff656078a72e19c05fb87e4e86b83aaf12be9b943890140a421d",
                "MacAddress": "02:42:ac:12:00:02",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]
</code></pre>

<p>The "Containers" key reveals that the <code>docker-php-fpm</code> container has the IP address 172.18.0.3 
and the docker-nginx container is reachable via 172.18.0.2. 
But can we actually connect from nginx to php-fpm? Let's find out:</p>

<p>Log into the nginx container</p>

<pre><code>winpty docker exec -ti docker-nginx bash
</code></pre>

<p>and ping the IP</p>

<pre><code>ping 172.18.0.3 -c 2
</code></pre>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-fpm
$ winpty docker exec -ti docker-nginx bash
root@eaa5c0594278:/# ping 172.18.0.3 -c 2
bash: ping: command not found
</code></pre>

<p>.. well, after we make the command available by installing <code>iputils-ping</code>:</p>

<pre><code>apt-get update &amp;&amp; apt-get install iputils-ping -y
ping 172.18.0.3 -c 2
</code></pre>

<pre><code>root@eaa5c0594278:/# apt-get update &amp;&amp; apt-get install iputils-ping -y
root@eaa5c0594278:/# ping 172.18.0.3 -c 2
PING 172.18.0.3 (172.18.0.3) 56(84) bytes of data.
64 bytes from 172.18.0.3: icmp_seq=1 ttl=64 time=0.142 ms
64 bytes from 172.18.0.3: icmp_seq=2 ttl=64 time=0.162 ms

--- 172.18.0.3 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1071ms
rtt min/avg/max/mdev = 0.142/0.152/0.162/0.010 ms
</code></pre>

<p>We can ping the container - that's good. But we were also promised we could reach the container by its name <code>docker-php-fpm</code>:</p>

<pre><code>ping docker-php-fpm -c 2
</code></pre>

<pre><code>root@eaa5c0594278:/# ping docker-php-fpm -c 2
PING docker-php-fpm (172.18.0.3) 56(84) bytes of data.
64 bytes from docker-php-fpm.web-network (172.18.0.3): icmp_seq=1 ttl=64 time=0.080 ms
64 bytes from docker-php-fpm.web-network (172.18.0.3): icmp_seq=2 ttl=64 time=0.131 ms

--- docker-php-fpm ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1045ms
rtt min/avg/max/mdev = 0.080/0.105/0.131/0.027 ms
</code></pre>

<p>And we can - awesome! Now we need to tell nginx to pass all PHP related requests to php-fpm by changing the 
<code>nginx\conf.d\site.conf</code> file on our windows host to</p>

<pre><code>server {
    listen      80;
    server_name localhost;
    root        /var/www;

   location ~ \.php$ {
        try_files $uri =404;
        fastcgi_pass docker-php-fpm:9000;
        include fastcgi_params;
        fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }
}
</code></pre>

<p>Note the <code>fastcgi_pass docker-php-fpm:9000;</code> line that tells nginx how to reach our php-fpm service.
Because we mounted the <code>nginx\conf.d</code> folder, we just need to reload nginx:</p>

<pre><code>nginx -s reload
</code></pre>

<p>and open http://127.0.0.1:8080/hello-world.php on a browser on your host machine.</p>

<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-php-fpm.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-php-fpm.PNG" alt="php-fpm hello world" /></a></p>

<p>Btw. there's also a good tutorial on geekyplatypus.com on how to 
<a href="http://geekyplatypus.com/dockerise-your-php-application-with-nginx-and-php7-fpm/">Dockerise your PHP application with Nginx and PHP7-FPM</a>.
But since it's using docker-compose you might want to read the next chapter first :)</p>

<h2><a id="docker-compose"></a>Putting it all together: Meet docker-compose</h2>

<p>Lets sum up what we have do now to get everything up and running:
1. start php-cli
2. start nginx
3. start php-fpm</p>

<pre><code>docker run -di --name docker-php -v "C:\codebase\docker-php\app":/var/www --network web-network docker-php-image
docker run -di --name docker-nginx -p 8080:80 -v "C:\codebase\docker-php\nginx\conf.d":/etc/nginx/conf.d/ -v "C:\codebase\docker-php\app":/var/www  --network web-network docker-nginx-image
docker run -di --name docker-php-fpm -v "C:\codebase\docker-php\app":/var/www --network web-network docker-php-fpm-image
</code></pre>

<p>Hm. That's alright I guess... but it also feels like "a lot". Wouldn't it be much better to have everything neatly defined in one place? 
I bet so! Let me introduce you to <a href="https://docs.docker.com/compose/">docker-compose</a></p>

<blockquote>
  <p>Compose is a tool for defining and running multi-container Docker applications. 
  With Compose, you use a YAML file to configure your application's services. 
  Then, with a single command, you create and start all the services from your configuration.</p>
</blockquote>

<p>Lets do this step by step, starting with the php-cli container. Create the file <code>C:\codebase\docker-php\docker-compose.yml</code>:</p>

<pre><code># tell docker what version of the docker-compose.yml we're using
version: '3'

# define the network
networks:
  web-network:

# start the services section
services:
  # define the name of our service
  # corresponds to the "--name" parameter
  docker-php-cli:
    # define the directory where the build should happened,
    # i.e. where the Dockerfile of the service is located
    # all paths are relative to the location of docker-compose.yml
    build: 
      context: ./php-cli
    # reserve a tty - otherwise the container shuts down immediately
    # corresponds to the "-i" flag
    tty: true
    # mount the app directory of the host to /var/www in the container
    # corresponds to the "-v" option
    volumes:
      - ./app:/var/www
    # connect to the network
    # corresponds to the "--network" option
    networks:
      - web-network
</code></pre>

<p>Before we get started, we're gonna clean up the old containers:</p>

<pre><code>docker rm -f $(docker ps -aq)
</code></pre>

<p>To test the docker-compose.yml we need to run <code>docker-compose up -d</code> from <code>C:\codebase\docker-php</code></p>

<pre><code>cd "C:\codebase\docker-php"
docker-compose up -d
</code></pre>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker-compose up -d
Creating network "docker-php_web-network" with the default driver
Building docker-php-cli
Step 1/2 : FROM php:7.0-cli
 ---&gt; da771ba4e565
Step 2/2 : RUN pecl install xdebug-2.6.0     &amp;&amp; docker-php-ext-enable xdebug
 ---&gt; Using cache
 ---&gt; 12be27256b12
Successfully built 12be27256b12
Successfully tagged docker-php_docker-php-cli:latest
Image for service docker-php-cli was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.
Creating docker-php_docker-php-cli_1 ... done
</code></pre>

<p>Note that the image is build from scratch when we run <code>docker-compose up</code> for the first time. 
A <code>docker ps -a</code> shows that the container is running fine, we can log in and execute source code from the host machine.</p>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker ps -a
CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS               NAMES
adf794f27315        docker-php_docker-php-cli   "docker-php-entrypoi…"   3 minutes ago       Up 2 minutes                            docker-php_docker-php-cli_1
</code></pre>

<p>Logging in</p>

<pre><code>winpty docker exec -it docker-php_docker-php-cli_1 bash
</code></pre>

<p>and running</p>

<pre><code>php /var/www/hello-world.php
</code></pre>

<p>works as before</p>

<pre><code>root@adf794f27315:/# php /var/www/hello-world.php
Hello World (php)
</code></pre>

<p>Now log out of the container and run</p>

<pre><code>docker-compose down 
</code></pre>

<p>to shut the container down again:</p>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker-compose down
Stopping docker-php_docker-php-cli_1 ... done
Removing docker-php_docker-php-cli_1 ... done
Removing network docker-php_web-network
</code></pre>

<p>Add the remaining services to the <code>docker-compose.yml</code> file:</p>

<pre><code># tell docker what version of the docker-compose.yml we're using
version: '3'

# define the network
networks:
  web-network:

# start the services section
services:
  # define the name of our service
  # corresponds to the "--name" parameter
  docker-php-cli:
    # define the directory where the build should happened,
    # i.e. where the Dockerfile of the service is located
    # all paths are relative to the location of docker-compose.yml
    build: 
      context: ./php-cli
    # reserve a tty - otherwise the container shuts down immediately
    # corresponds to the "-i" flag
    tty: true
    # mount the app directory of the host to /var/www in the container
    # corresponds to the "-v" option
    volumes:
      - ./app:/var/www
    # connect to the network
    # corresponds to the "--network" option
    networks:
      - web-network

  docker-nginx:
    build: 
      context: ./nginx
    # defines the port mapping
    # corresponds to the "-p" flag
    ports:
      - "8080:80"
    tty: true
    volumes:
      - ./app:/var/www
      - ./nginx/conf.d:/etc/nginx/conf.d
    networks:
      - web-network

  docker-php-fpm:
    build: 
      context: ./php-fpm
    tty: true
    volumes:
      - ./app:/var/www
    networks:
      - web-network
</code></pre>

<p>And up again...</p>

<pre><code>docker-compose up -d
</code></pre>

<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker-compose up -d
Building docker-nginx
Step 1/1 : FROM nginx:latest
 ---&gt; ae513a47849c
Successfully built ae513a47849c
Successfully tagged docker-php_docker-nginx:latest
Image for service docker-nginx was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.
Building docker-php-fpm
Step 1/2 : FROM php:7.0-fpm
 ---&gt; a637000da5a3
Step 2/2 : RUN pecl install xdebug-2.6.0     &amp;&amp; docker-php-ext-enable xdebug
 ---&gt; Running in 4ec27516df54
downloading xdebug-2.6.0.tgz ...
Starting to download xdebug-2.6.0.tgz (283,644 bytes)
[...]
---&gt; 120c8472b4f3
Successfully built 120c8472b4f3
Successfully tagged docker-php_docker-php-fpm:latest
Image for service docker-php-fpm was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.
Creating docker-php_docker-nginx_1   ... done
Creating docker-php_docker-php-cli_1 ... done
Creating docker-php_docker-php-fpm_1 ... done
</code></pre>

<p>Only nginx and php-fpm needed to be built because the php-cli one already existed. 
Lets check if we can still open http://127.0.0.1:8080/hello-world.php in a browser on the host machine:</p>

<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-php-fpm.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-php-fpm.PNG" alt="php-fpm hello world" /></a></p>

<p>Yes we can! So instead of needing to run 3 different command with a bunch of parameters we're now down to 
<code>docker-compose up -d</code>. Looks like an improvement to me ;)</p>

<h2><a id="tl-dr"></a>The tl;dr</h2>

<p>The whole article is a lot to take in and it is most likely not the most efficient approach when you "just want to get started".
So in this section we'll boil it down to only the necessary steps without in depth explanations.</p>

<ul>
<li><a href="https://store.docker.com/editions/community/docker-ce-desktop-windows">Download Docker for Windows</a></li>
<li><a href="#setup-docker">Install Docker</a>

<ul>
<li>activate Hyper-V (Virtual Box will stop working)</li>
<li>enable Disk Sharing in the settings</li>
</ul></li>
<li>Set up the following folder structure
````
C:\codebase\docker-php

<ul>
<li>nginx\

<ul>
<li>conf.d\</li>
<li>site.conf</li>
<li>Dockerfile</li>
</ul></li>
<li>php-cli\

<ul>
<li>Dockerfile</li>
</ul></li>
<li>php-fpm\

<ul>
<li>Dockerfile</li>
</ul></li>
<li>app\

<ul>
<li>index.html</li>
<li>hello-world.html</li>
</ul></li>
<li>docker-compose.yml
````</li>
<li>or simply <code>git clone git@github.com:paslandau/docker-php-tutorial.git docker-php &amp;&amp; git checkout part_1_setting-up-php-php-fpm-and-nginx-for-local-development-on-docker</code></li>
</ul></li>
<li>Open a shell at <code>C:\codebase\docker-php</code></li>
<li>run <code>docker-compose up -d</code></li>
<li>check in browser via

<ul>
<li>127.0.0.1:8080</li>
<li>127.0.0.1:8080/hello-world.php</li>
</ul></li>
<li>run <code>docker-compose down</code></li>
</ul>

<p>Your application code lives in the <code>app\</code> folder and changes are automatically available to the containers.
This setup denotes the end of the first tutorial. In the next part we will learn how to set up Docker in PHPStorm,
especially in combination with xdebug.</p>

<h2>Wrapping up</h2>

<p>Congratulations, you made it! If some things are not completely clear by now, don't hesitate to
leave a comment. Apart from that, you should now have a first idea on what docker is and how you 
can use it.</p>

<p>If you want to go deeper, please check out the remaining articles of the 
<a href="/docker-php-tutorial/">Docker PHP Tutorial series</a>.</p>

<p>Please subscribe to the <a href="/feed.xml">RSS feed</a> or <a href="#newsletter">via email</a> to get automatic
notifications when this next part comes out :)</p>
                <hr />
                <h3>Wanna stay in touch?</h3>
                <p>Since you ended up on this blog, chances are pretty high that you're into Software Development
                (probably PHP, Laravel, Docker or Google Big Query) and I'm a big fan of feedback and networking.
                </p><p>
                So - if you'd like to stay in touch, feel free to shoot me an email with a couple of words about yourself and/or
                connect with me on
                <a href="https://www.linkedin.com/in/pascallandau">LinkedIn</a> or
                <a href="https://twitter.com/PascalLandau">Twitter</a>
                or simply subscribe to my <a href="https://www.pascallandau.com/feed.xml">RSS feed</a>
                or go the crazy route and subscribe via mail
                and don't forget to leave a comment :)
                </p>
                <!-- Begin Mailchimp Signup Form -->
                <link href="//cdn-images.mailchimp.com/embedcode/classic-10_7.css" rel="stylesheet" type="text/css">
                <style type="text/css">
                    #mc_embed_signup{background:#bae1ff; clear:left; font:14px Helvetica,Arial,sans-serif; border-radius: 20px}
                    #mc_embed_signup h4 {padding:1em 0 0 1em}
                    #mc-embedded-subscribe-form input[type=checkbox]{display: inline; width: auto;margin-right: 10px;}
                    #mergeRow-gdpr {margin-top: 20px;}
                    #mergeRow-gdpr fieldset label {font-weight: normal;}
                    #mc-embedded-subscribe-form .mc_fieldset{border:none;min-height: 0px;padding-bottom:0px;}
                </style>
                <div id="mc_embed_signup">
                    <h4 id="newsletter">Subscribe to posts via mail</h4>
                    <form action="https://pascallandau.us20.list-manage.com/subscribe/post?u=89e1c97fa614ded06a44fbcfd&amp;id=852c78303c" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
                        <div id="mc_embed_signup_scroll">
                            <div class="mc-field-group">
                                <label for="mce-EMAIL">Email Address </label>
                                <input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL">
                            </div>
                            <div class="mc-field-group">
                                <label for="mce-FNAME">First Name </label>
                                <input type="text" value="" name="FNAME" class="required" id="mce-FNAME">
                            </div>
                            <div id="mce-responses" class="clear">
                                <div class="response" id="mce-error-response" style="display:none"></div>
                                <div class="response" id="mce-success-response" style="display:none"></div>
                            </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
                            <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_89e1c97fa614ded06a44fbcfd_852c78303c" tabindex="-1" value=""></div>
                            <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
                            <div id="mergeRow-gdpr" class="mergeRow gdpr-mergeRow content__gdprBlock mc-field-group">
                                <div class="content__gdprLegal">
                                    <small>
                                        We use Mailchimp as our newsletter provider. By clicking subscribe, you acknowledge that your
                                        information will be transferred to Mailchimp for processing.
                                        <a href="https://mailchimp.com/legal/" target="_blank" rel="nofollow">Learn more about Mailchimp's privacy practices here.</a>
                                    </small>
                                </div>
                            </div>
                        </div>
                    </form>
                </div>
                <script type='text/javascript' src='//s3.amazonaws.com/downloads.mailchimp.com/js/mc-validate.js'></script><script type='text/javascript'>(function($) {window.fnames = new Array(); window.ftypes = new Array();fnames[0]='EMAIL';ftypes[0]='email';fnames[1]='FNAME';ftypes[1]='text';fnames[2]='LNAME';ftypes[2]='text';fnames[3]='ADDRESS';ftypes[3]='address';fnames[4]='PHONE';ftypes[4]='phone';fnames[5]='BIRTHDAY';ftypes[5]='birthday';}(jQuery));var $mcj = jQuery.noConflict(true);</script>
                <!--End mc_embed_signup-->
                <div style="text-align:center; margin-top:1em;">
                    <img src="/img/waving-bear.gif" alt="Waving bear" style="max-width:416px"/>
                </div>
                <h2>Comments</h2>
                <div id="disqus_thread"></div>
                <script>
                     var disqus_config = function () {
                        this.page.url = "https://www.pascallandau.com/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/";
                                                     this.page.identifier = "php-fpm-nginx-xdebug-docker-windows-10";
                                              };
                    (function() {  // DON'T EDIT BELOW THIS LINE
                        var d = document, s = d.createElement('script');

                        s.src = '//pascallandau.disqus.com/embed.js';

                        s.setAttribute('data-timestamp', +new Date());
                        (d.head || d.body).appendChild(s);
                    })();
                </script>
                <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
            </div>
        </div>
    </div>
</article>

<hr>

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="https://twitter.com/PascalLandau">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.linkedin.com/in/pascallandau">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/paslandau/">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.youtube.com/channel/UC8hVNCGAtz1DvOOpSQ3Nfzw">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-youtube fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.pascallandau.com/feed.xml">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                                </span>
                        </a>
                    </li>
                </ul>
                <p class="copyright text-muted">&copy; <a href="https://www.pascallandau.com">www.pascallandau.com</a> 2023                    built with <a href="https://github.com/tightenco/jigsaw">Jigsaw</a></p>
            </div>
        </div>
    </div>
</footer>
    <img src="https://ssl-vg03.met.vgwort.de/na/e8a8b08253d04d8f96ba390a1d2a0037" width="1" height="1" alt=""/>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>
<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>
<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js"></script>
<!-- Custom JavaScript -->
<script src="/js/main.js"></script>
<!-- Code highlighting 
     See source/img/highlight-js-languages.PNG for an overview of the selected languages 
     The files can be re-compiled at https://highlightjs.org/download/
     -->
<script src="/js/highlight.min.js"></script>

<script type='text/javascript'>
    hljs.highlightAll();
    // show the hidden blog only locally
    if(window.location.href.startsWith("http://localhost:8000/")){
        $('#navbar').prepend('<li><a href="/blog-hidden/">HIDDEN Blog</a></li>');
    }
</script>
</body>

</html>
