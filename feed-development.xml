<?xml version = "1.0" encoding = "UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>pascallandau.com [dev only]</title>
        <description>Personal website of Pascal Landau - Development related posts only</description>
        <link>https://www.pascallandau.com</link>
        <atom:link href="https://www.pascallandau.com/feed-development.xml" rel="self" type="application/rss+xml"/>
        <pubDate>Sat, 26 Jan 2019 10:03:28 +0000</pubDate>
        <lastBuildDate>Sat, 26 Jan 2019 10:03:28 +0000</lastBuildDate>
        <language>en</language>
                    <item>
                <title>How to setup PhpStorm with Xdebug on Docker [Tutorial Part 2]</title>
                <description><![CDATA[<p>In the second part of this tutorial series on developing PHP on Docker we're taking a good hard look
at PhpStorm, Xdebug and how to run and debug scripts from within PhpStorm on Docker.</p>
<p>And just as a reminder, the first part is over at
<a href="/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/">Setting up PHP, PHP-FPM and NGINX for local development on Docker</a>.</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/27KBaI24jKI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</div>
<p><strong>Note</strong>: The setup that I am going to use is for demonstration purposes only! I do <strong>not</strong> recommend that you use it
&quot;as is&quot; as your development setup. Some problems that I won't solve here include:</p>
<ul>
<li>everything is owned by root (no dedicated user; that will in particular be problematic for linux users)</li>
<li>SSH login credentials are hard-coded in the container (inherently insecure)</li>
<li><code>host.docker.internal</code> will only exist for Windows and Mac users, NOT for unix users</li>
</ul>
<p>There will be a another part of this series that will deal with all of those (and some more common) problems and
aims at providing a consistent development environment for all developers in a team (regardless of the OS they are using).
Please subscribe to the <a href="http:///feed.xml">RSS feed</a> to get automatic notifications when that part comes out :)</p>
<h2>Table of contents</h2>
<ul>
<li><a href="#setup-the-docker-containers">Setup: The docker containers</a></li>
<li><a href="#run-php-via-built-in-docker-setup">Run PHP via built-in Docker setup</a><ul>
 <li><a href="#enable-docker-to-communicate-on-port 2375">Enable docker to communicate on port 2375</a></li>
 <li><a href="#configure-docker-server-in-phpstorm">Configure Docker Server in PhpStorm</a></li>
 <li><a href="#configure-docker-php-cli-interpreter">Configure Docker PHP CLI Interpreter</a></li>
 <li><a href="#run-debug-a-php-script-on-docker-server">Run/debug a php script on docker</a></li>
</ul></li>
<li><a href="#run-php-on-docker-via-deployment-configuration">Run PHP on Docker via Deployment Configuration</a><ul>
 <li><a href="#preparing-the-workspace-container">Preparing the "workspace" container</a></li>
 <li><a href="#configure-the-deployment-configuration">Configure the Deployment Configuration</a></li>
 <li><a href="#run-debug-a-php-script-on-docker">Run/debug a php script on docker</a></li>
 <li><a href="#fix-xdebug-on-phpstorm-when-run-from-a-docker-container">Fix Xdebug on PhpStorm when run from a Docker container</a></li>
</ul></li>
</ul>
<h2><a id="setup-the-docker-containers"></a>Setup: The docker containers</h2>
<p>We will only need the php-cli container for this part.
Luckily, we already have a good understanding on how to create the container, although we'll need to make some
adjustments to make everything work smoothly with PhpStorm. I'm gonna walk you through all the necessary changes,
but I'd still recommend to clone the corresponding git repository <a href="https://github.com/paslandau/docker-php-tutorial">docker-php-tutorial</a>
(unless you've already done that in part 1), checkout branch <a href="https://github.com/paslandau/docker-php-tutorial/tree/part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker"><code>part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker</code></a> and
build the containers now.</p>
<p>As in part 1, I'm assuming your codebase lives at <code>/c/codesbase</code>:</p>
<pre><code>cd /c/codebase/
git clone https://github.com/paslandau/docker-php-tutorial.git
cd docker-php-tutorial
git checkout part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker
docker-compose build</code></pre>
<p>Further, make sure to open <code>/c/codebase/docker-php-tutorial</code> as a project in PhpStorm.</p>
<p>In general, there are two ways to run PHP from PhpStorm using Docker:</p>
<ol>
<li>via the built-in Docker setup</li>
<li>via Deployment Configuration (treating docker more or less like a VM)</li>
</ol>
<h2><a id="run-php-via-built-in-docker-setup"></a>Run PHP via built-in Docker setup</h2>
<p>This is the &quot;easier&quot; way and should mostly work &quot;out of the box&quot;. When you run a PHP script using this method, PhpStorm will start a
docker container and configure it automatically (path mappings, network setup, ...). Next, the script in question is executed and the container
is stopped afterwards.</p>
<h3><a id="enable-docker-to-communicate-on-port 2375"></a>Enable docker to communicate on port 2375</h3>
<p>Open the Docker Setting in tab &quot;General&quot; and activate the checkbox that says
&quot;Expose daemon on tcp://localhost:2375 without TLS&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-port-tcp-2375.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-port-tcp-2375.PNG" alt="Enable docker to communicate on port 2375" /></a></p>
<h3><a id="configure-docker-server-in-phpstorm"></a>Configure Docker Server in PhpStorm</h3>
<p>In PhpStorm, navigate to <code>File | Settings | Build, Execution, Deployment | Docker</code>. Fill out <code>Name</code> and <code>Engine API URL</code>:</p>
<ul>
<li>Name: Docker</li>
<li>Engine API URL: <code>tcp://localhost:2375</code></li>
</ul>
<p>PhpStorm will automatically validate your settings and show a &quot;Connection successful&quot; info below the path mappings box:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/php-built-in-docker-setup.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/php-built-in-docker-setup.PNG" alt="Configure Docker server in PhpStorm" /></a></p>
<h3><a id="configure-docker-php-cli-interpreter"></a>Configure Docker PHP CLI Interpreter</h3>
<p>Navigate to <code>File | Settings | Languages &amp; Frameworks | PHP</code>. Click on the three dots &quot;...&quot; next to &quot;CLI Interpreter&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter.PNG" alt="Setup CLI Interpreter PhpStorm" /></a></p>
<p>In the newly opened pop up click on the &quot;+&quot; sign on the top left and choose &quot;From Docker,Vagrant,VM,Remote...&quot;</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker.PNG" alt="New CLI Interpreter" /></a></p>
<p>Next, choose &quot;Docker&quot; from the radio buttons and select our previously created Docker server (named &quot;Docker&quot;).
As image, choose <code>docker-php-tutorial_docker-php-cli:latest</code> (which is one of the images used in this tutorial). If you don't see
this image you've probably not yet built the containers. In that case, please checkout the repo and build the containers: </p>
<pre><code>cd /c/codebase/
git clone https://github.com/paslandau/docker-php-tutorial.git
cd docker-php-tutorial
git checkout part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker
docker-compose build</code></pre>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker-php-cli.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker-php-cli.PNG" alt="New CLI Interpreter from Docker server" /></a></p>
<p>PhpStorm will now try to create the container and figure out if it can run PHP. If all goes well, you should see the following screenshot
with information about the PHP and Xdebug versions in the image/container.</p>
<p><em>Note</em>: Sometimes, this does not work immediately. If that's the case for you, try to click the &quot;Refresh&quot; icon next to &quot;PHP executable&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker-configured.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker-configured.PNG" alt="New CLI Interpreter from Docker configured" /></a></p>
<p>After you hit &quot;OK&quot;, you'll be back in the PHP Interpreter screen where our newly configured Docker interpreter should be already selected:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-done.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-done.PNG" alt="New CLI Interpreter from Docker chosen" /></a></p>
<p>Note that PhpStorm has automatically configured the path mappings as <code>-v</code> command line option for the Docker container. After hitting &quot;OK&quot;
one last time, everything is set up.</p>
<h3><a id="run-debug-a-php-script-on-docker-server"></a>Run/debug a php script on docker</h3>
<p>To verify that everything is working, open the file <code>app/hello-world.php</code> in PhpStorm, right click in the editor pane and choose &quot;Run&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-run-php-script.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-run-php-script.PNG" alt="Run PHP script" /></a></p>
<p>PhpStorm will start the configured container and run the script. The output is then visible at the bottom of the IDE:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/built-in-docker-run-php-script-finished.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/built-in-docker-run-php-script-finished.PNG" alt="PHP script output" /></a></p>
<p>Since we're using an image that has Xdebug installed, we can also set a breakpoint and use &quot;Debug&quot; instead of &quot;Run&quot; to trigger a debug session:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script.PNG" alt="Debug PHP script" /></a></p>
<p>PhpStorm should stop on the marked line. </p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script-breakpoint.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script-breakpoint.PNG" alt="Debug PHP script pausing" /></a></p>
<p>When you take a look at the &quot;Console&quot; panel at the bottom of the IDE, you should see something like this:</p>
<pre><code>docker://docker-php-tutorial_docker-php-cli:latest/php -dxdebug.remote_enable=1 -dxdebug.remote_mode=req -dxdebug.remote_port=9000 -dxdebug.remote_host=192.168.10.1 /opt/project/app/hello-world.php</code></pre>
<p>Please keep the <code>-dxdebug.remote_host=192.168.10.1</code> option in mind - this will be &quot;interesting&quot; when we set up a Docker-based PHP Interpreter
via Deployment Configuration ;)</p>
<p>PS: You find the official documentation for the built-in Docker support at
<a href="https://confluence.jetbrains.com/display/PhpStorm/Docker+Support+in+PhpStorm">Docker Support in PhpStorm</a>.</p>
<h2><a id="run-php-on-docker-via-deployment-configuration"></a>Run PHP on Docker via Deployment Configuration</h2>
<p>The previously explained method is nice, but it is lacking flexibility and it's also pretty slow as the container used to run
the script needs to be started each time we want to execute something. Luckily, there is an additional way of running PHP scripts
on Docker in PhpStorm, which is closely related to the Vagrant setup that I explained in
<a href="https://www.pascallandau.com/blog/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/#configuring-phpstorm-to-use-the-vagrant-box">Configuring PhpStorm to use the vagrant box</a>.</p>
<p>To make this work, we will keep a docker container running all the time and configure PhpStorm to connect to it via SSH. Thus, PhpStorm
effectively treats the docker container as any other remote host.</p>
<h3><a id="preparing-the-workspace-container"></a>Preparing the &quot;workspace&quot; container</h3>
<p>Please make sure to checkout my demo repository and switch to the correct branch first:</p>
<pre><code>cd /c/codebase/
git clone https://github.com/paslandau/docker-php-tutorial.git
cd docker-php-tutorial
git checkout part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker</code></pre>
<p>For now, we only need the <code>php-cli</code> container. In it, we need to setup the xdebug extension (already done and explained in the previous part) and
an SSH server so that we can log in via SSH. Let's take a look a the <code>Dockerfile</code>:</p>
<pre><code>FROM php:7.0-cli

RUN apt-get update -yqq \
 &amp;&amp; apt-get install -yqq \
    # install sshd
    openssh-server \
    # install ping and netcat (for debugging xdebug connectivity)
    iputils-ping netcat \
    # fix ssh start up bug
    # @see https://github.com/ansible/ansible-container/issues/141
 &amp;&amp; mkdir /var/run/sshd \
;

# add default public key to authorized_keys
COPY ./ssh/insecure_id_rsa.pub /root/insecure_id_rsa.pub
RUN mkdir -p /root/.ssh \
 &amp;&amp; cat /root/insecure_id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys \
 &amp;&amp; rm -rf /root/insecure_id_rsa.pub \
;

RUN pecl -q install xdebug-2.6.0 \
;
COPY ./conf.d/xdebug.ini /usr/local/etc/php/conf.d/xdebug.ini

# @see https://docs.docker.com/engine/examples/running_ssh_service/
CMD ["/usr/sbin/sshd", "-D"]
</code></pre>
<p>and the <code>docker-compose.yml</code>:</p>
<pre><code>  docker-php-cli:
    # define the directory where the build should happened,
    # i.e. where the Dockerfile of the service is located
    # all paths are relative to the location of docker-compose.yml
    build: 
      context: ./php-cli
    # make the SSH port available via port mapping
    ports:
      - "2222:22"
    # reserve a tty - otherwise the container shuts down immediately
    # corresponds to the "-i" flag
    tty: true
    # mount the app directory of the host to /var/www in the container
    # corresponds to the "-v" option
    volumes:
      - ./app:/var/www
    # connect to the network
    # corresponds to the "--network" option
    networks:
      - web-network</code></pre>
<p>There are four things to note:</p>
<ol>
<li>installing the server </li>
<li>adding the ssh keys to actually log in</li>
<li>changing the default <code>CMD</code> to keep the SSH daemon running</li>
<li>port- and volume mapping</li>
</ol>
<h4><a id="installing-the-server"></a>Installing the server</h4>
<p>The server installation is straight forward:</p>
<pre><code>apt-get install -yqq openssh-server</code></pre>
<p>the only none-intuitive thing is, that we need to &quot;manually&quot; create the directory <code>/var/run/sshd</code>
( <a href="https://github.com/ansible/ansible-container/issues/141">due to a bug</a> ).</p>
<h4><a id="adding-the-ssh-keys"></a>Adding the ssh keys</h4>
<p>For the ssh keys, I'm choosing the easy route (for now) and use a pre-generated ssh key pair (see <code>php-cli/ssh/*</code>).
The content of the public key is appended to <code>/root/.ssh/authorized_keys</code> so that I can log in to the container as user <code>root</code> using the
corresponding private key from <code>php-cli/ssh/insecure_id_rsa</code>.</p>
<p><strong>Caution</strong>: Of course, this is massively insecure! Those keys are part of the repository, making them available to everybody with access to the repo.
That makes sense for this publicly available tutorial (because everything works &quot;out of the box&quot; for everybody following along) but it is also one
of the reasons you should <strong>not</strong> use that repo as your <strong>actual</strong> development setup.</p>
<p>Again, there will be another part of this tutorial in which I'll present a solution to this problem (using volumes to share my local ssh keys with a
container and an <code>ENTRYPOINT</code> to put them in the right place).</p>
<h4><a id="keep-the-ssh-daemon-running"></a>Keep the SSH daemon running</h4>
<p>For SSH to work, we must start <code>sshd</code> and keep it running in the container. We achieve this by using <code>CMD ["/usr/sbin/sshd", "-D"]</code> in the
Dockerfile, following the official docker example to <a href="https://docs.docker.com/engine/examples/running_ssh_service/">Dockerize an SSH service</a>.</p>
<h4><a id="port-and-volume-mapping"></a>Port- and volume mapping</h4>
<p>Since docker containers do not have deterministic IP addresses, we map port 22 from the container to port 2222 on our host machine and we
further provide a path mapping from our local <code>./app</code> folder to <code>/var/www</code> in the container. Both pieces of information a required when
we configure PhpStorm later on.</p>
<p>Now that everything is in place, let's build and run the container:</p>
<pre><code>cd /c/codebase/docker-php-tutorial
docker-compose up -d docker-php-cli</code></pre>
<p>yielding</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /d/codebase/docker-php-tutorial (part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker)
$ docker-compose up -d docker-php-cli
Creating docker-php-tutorial_docker-php-cli_1 ... done</code></pre>
<p><em>Note</em>: One might argue, that it's kinda defeating the purpose of docker, when we now treat it as a VM, installing SSH and neglecting it's
&quot;one process per container&quot; rule. But honestly, I don't care about that when
it comes to my local development setup as my main goal is to have something lightweight, that is easily shareable with my team to have a
consistent infrastructure setup ;)</p>
<h3><a id="configure-the-deployment-configuration"></a>Configure the Deployment Configuration</h3>
<p>In PhpStorm, navigate to <code>File | Settings | Build, Execution, Deployment | Deployment</code>.
In the newly opened pop up click on the &quot;+&quot; sign on the top left and choose &quot;From Docker,Vagrant,VM,Remote...&quot; with:</p>
<ul>
<li>Name: Docker (SSH)</li>
<li>Type: SFTP</li>
</ul>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/new-deployment-configuration.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/new-deployment-configuration.PNG" alt="New SFTP Deployment Configuration" /></a></p>
<p>In the <code>Connection</code> tab, choose the following settings:</p>
<ul>
<li>SFTP host: 127.0.0.1</li>
<li>Port: 2222</li>
<li>User name: root</li>
<li>Auth type: Key pair (OpenSSH or PuTTY)</li>
<li>Private key file: <code>C:\codebase\docker-php-tutorial\php-cli\ssh\insecure_id_rsa</code></li>
</ul>
<p><em>Notes</em>:</p>
<ul>
<li>the &quot;Port&quot; corresponds to the port mapping that we defined in the <code>docker-compose.yml</code> file</li>
<li>the &quot;Private key file&quot; is the &quot;insecure&quot; ssh key that matches the public key we specified in the <code>php-cli/Dockerfile</code></li>
</ul>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-connection.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-connection.PNG" alt="Deployment Configuration: Connection" /></a></p>
<p>Hit the &quot;Test SFT connection...&quot; button to test the settings. You should see</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-connection-test.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-connection-test.PNG" alt="Deployment Configuration: Test Connection" /></a></p>
<p>(there might also appear a fingerprint warning because we're using 127.0.0.1 as host. You can simply ignore that warning).</p>
<p>Now choose the <code>Mappings</code> tab and fill it the fields as follows:</p>
<ul>
<li>Local path: <code>C:\codebase\docker-php-tutorial\app</code></li>
<li>Deployment path on server 'Docker (SSH)': <code>/var/www/</code></li>
</ul>
<p>Those mappings correspond to the volume definition for the <code>docker-php-cli</code> service in <code>docker-compose.yml</code>:</p>
<pre><code>[...]
    # mount the app directory of the host to /var/www in the container
    # corresponds to the "-v" option
    volumes:
      - ./app:/var/www
[...]</code></pre>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-path-mappings.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-path-mappings.PNG" alt="Deployment Configuration: Path Mappings" /></a></p>
<p>Next, we need to create a PHP Interpreter based on our newly created Deployment Configuration.
Open settings and navigate to <code>File | Settings | Languages &amp; Frameworks | PHP</code>. Click on the three dots &quot;...&quot; next to &quot;CLI Interpreter&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter.PNG" alt="Setup CLI Interpreter PhpStorm" /></a></p>
<p>In the newly opened pop up click on the &quot;+&quot; sign on the top left and choose &quot;From Docker,Vagrant,VM,Remote...&quot;</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker.PNG" alt="New CLI Interpreter" /></a></p>
<p>Choose &quot;Deployment Configuration&quot; from the radio buttons and select the &quot;Docker (SSH)&quot; entry. Please make sure to enter
<code>/usr/local/bin/php</code> as path for the PHP executable (as PhpStorm by default will set this path to <code>/usr/bin/php</code>).</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-deployment-configuration.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-deployment-configuration.PNG" alt="Setup Docker (SSH) Interpreter" /></a></p>
<p>Set &quot;Docker (SSH)&quot; as name for the new interpreter and click &quot;OK&quot;. </p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-docker-deployment-configuration.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-docker-deployment-configuration.PNG" alt="Finalize Docker (SSH) Interpreter" /></a></p>
<p>Confirm the new PHP Interpreter to close the settings dialog.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-deployment-configuration-done.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-deployment-configuration-done.PNG" alt="Confirm Deployment Configuration Interpreter" /></a></p>
<h3><a id="run-debug-a-php-script-on-docker"></a>Run/debug a php script on docker</h3>
<p>To verify that everything is working, open the file <code>app/hello-world.php</code> in PhpStorm, right click in the editor pane and choose &quot;Run&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-run-php-script.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-run-php-script.PNG" alt="Run PHP script" /></a></p>
<p>PhpStorm will start the configured container and run the script. The output is then visible in at the bottom of the IDE:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-ssh-run-php-script-finished.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-ssh-run-php-script-finished.PNG" alt="PHP script output when run via SFTP" /></a></p>
<p>Since we're using an image that has Xdebug installed, we can also set a breakpoint and use &quot;Debug&quot; instead of &quot;Run&quot; to trigger a debug session:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script.PNG" alt="Debug PHP script" /></a></p>
<p>Hm weird... Although this worked flawlessly when we used the built-in functionality, it does not when we use the Deployment Configuration and shows
a &quot;Connection with 'Xdebug 2.6.0' not established.&quot; error.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/failing-xdebug-connection.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/failing-xdebug-connection.PNG" alt="Xdebug connection cannot be established error" /></a></p>
<h3><a id="fix-xdebug-on-phpstorm-when-run-from-a-docker-container"></a>Fix Xdebug on PhpStorm when run from a Docker container</h3>
<p>Long story short: There is a bug in the networking setup of Docker for Win that makes PhpStorm use the wrong <code>remote_host</code> when it starts a
debugging session. When you take a look at the &quot;Console&quot; panel at the bottom of the IDE, you should see something like this:</p>
<pre><code>sftp://root@127.0.0.1:2222/usr/local/bin/php -dxdebug.remote_enable=1 -dxdebug.remote_mode=req -dxdebug.remote_port=9000 -dxdebug.remote_host=172.18.0.1 /var/www/hello-world.php</code></pre>
<p>The <code>-dxdebug.remote_host=172.18.0.1</code> option is our suspect here. Luckily, since
<a href="https://docs.docker.com/docker-for-windows/networking/#use-cases-and-workarounds">Docker v18.03</a> there is a &quot;magic&quot; DNS entry called <code>host.docker.internal</code>
that we can use to reach the host from a container.</p>
<p>So, how can we solve this? PhpStorm enables us to
<a href="https://www.jetbrains.com/help/phpstorm/configuring-xdebug.html#d165872e407">pass custom options to Xdebug</a> when a debugging session is initiated.
Open <code>File | Settings | Languages &amp; Frameworks | PHP</code> and click on the &quot;...&quot; next to &quot;PHP Interpreter&quot; to bring up the interpreters. Choose
&quot;Docker (SSH)&quot; in the left pane and click on the little folder icon on the bottom of the window next to &quot;Configuration options&quot;. In the pop up enter
<code>xdebug.remote_host</code> as key and <code>host.docker.internal</code> as value and hit &quot;OK&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/xdebug-options.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/xdebug-options.PNG" alt="Configure Xdebug options" /></a></p>
<p>This results in the configuration setting <code>-dxdebug.remote_host=host.docker.internal</code> that is now appended to the remaining (default) arguments
that PhpStorm uses and will <strong>override</strong> any existing options (including the incorrect <code>xdebug.remote_host</code>).</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/xdebug-options-configured.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/xdebug-options-configured.PNG" alt="Configured Xdebug options" /></a></p>
<p>Initiating a debug session on <code>app/hello-world.php</code> will now finally stop the execution as expected and the
&quot;Console&quot; panel at the bottom of the IDE, shows</p>
<pre><code>sftp://root@127.0.0.1:2222/usr/local/bin/php -dxdebug.remote_enable=1 -dxdebug.remote_mode=req -dxdebug.remote_port=9000 -dxdebug.remote_host=172.18.0.1 -dxdebug.remote_host=host.docker.internal /var/www/hello-world.php</code></pre>
<p>This setup denotes the end of the second tutorial. In the next part we will take a <strong>much</strong> deeper look into Xdebug to fully understand how it works
(especially in combination with PhpStorm), how to fix common problems and make it work in different scenarios (debugging from the browser, from php workers, etc.).</p>]]></description>
                                                    <pubDate>Mon, 06 Aug 2018 12:00:00 +0000</pubDate>
                                <link>https://www.pascallandau.com/blog/setup-phpstorm-with-xdebug-on-docker/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=development-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/blog/setup-phpstorm-with-xdebug-on-docker/</guid>
            </item>
                    <item>
                <title>How to setup PHP, PHP-FPM and NGINX on Docker in Windows 10 [Tutorial Part 1]</title>
                <description><![CDATA[<p>You probably heard from the new kid around the block called &quot;Docker&quot;?
You are a PHP developer and would like to get into that, but you didn't have the time to look into it, yet?
Then this tutorial is for you! By the end of it, you should know:</p>
<ul>
<li>how to setup Docker &quot;natively&quot; on a Windows 10 machine</li>
<li>how to build and run containers from the command line</li>
<li>how to log into containers and explore them for information</li>
<li>what a Dockerfile is and how to use it</li>
<li>how containers can talk to each other</li>
<li>how <code>docker-compose</code> can be used to fit everything nicely together</li>
</ul>
<p><strong>Note</strong>: I will not only walk on the happy path during this tutorial. That means I'll deep-dive into
some things that are not completely related to docker (e.g. how to find out where the configuration
files for php-fpm are located), but that are imho important to understand, because they enable you to
solve problems later on your own. </p>
<p>But if you are short on time, you might also jump directly to <a href="#tl-dr">the tl;dr</a>.</p>
<p>This is the first part of a (probably) multi-part series on Docker. The second part explains how
to <a href="/blog/setup-phpstorm-with-xdebug-on-docker">set up PHP in Docker containers in order to work nicely with PHPStorm when using XDebug</a>.</p>
<h2>Table of contents</h2>
<ul>
<li><a id="introduction">Introduction</a>
    <ul>
    <li><a href="#precondiction">Preconditions</a></li>
    <li><a href="#why-use-docker">Why use Docker?</a></li>
    <li><a href="#transition-vagrant">Transition from Vagrant</a></li>
    </ul>
</li>
<li><a href="#setup-docker">Setup Docker</a>    
<li><a href="#setup-php-cli">Setting up the PHP cli container</a>
    <ul>
        <li><a href="#xdebug-php">Installing Xdebug in the PHP container</a></li>
        <li><a href="#dockerfile">Persisting image changes with a Dockerfile</a></li>
    </ul>
</li> 
<li><a href="#webstack">Setting up a web stack with php-fpm and nginx</a>
    <ul>
        <li><a href="#setup-nginx">Setting up nginx</a></li>
        <li><a href="#setup-php-fpm">Setting up php-fpm</a>
            <ul>
                <li><a href="#php-fpm-xdebug">Installing xdebug</a></li>
            </ul>
        </li> 
        <li><a href="#connecting-nginx-php-fpm">Connecting nginx and php-fpm</a></li>
    </ul>
</li> 
<li><a href="#docker-compose">Putting it all together: Meet docker-compose</a></li>
<li><a href="#tl-dr">The tl;dr</a></li>
</ul>
<h2><a id="introduction"></a>Introduction</h2>
<h3><a id="precondiction"></a>Preconditions</h3>
<p>I'm assuming that you have installed <a href="https://git-scm.com/download/win">Git bash for Windows</a>. If not, please do that before,
see <a href="http://www.pascallandau.com/blog/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/#git-and-git-bash">Setting up the software: Git and Git Bash</a>.</p>
<h3><a id="why-use-docker"></a>Why use Docker?</h3>
<p>I won't go into too much detail what Docker is and why you should use it, because
<a href="https://www.linode.com/docs/applications/containers/when-and-why-to-use-docker/">others</a>
<a href="https://www.zdnet.com/article/what-is-docker-and-why-is-it-so-darn-popular/">have</a>
<a href="https://stackoverflow.com/questions/16647069/should-i-use-vagrant-or-docker-for-creating-an-isolated-environment">already</a>
talked about this extensively.</p>
<p>As for me, my main reasons were</p>
<ul>
<li>Symlinks in vagrant didn't work the way they should</li>
<li>VMs become bloated and hard to manage over time</li>
<li>Setup in the team involved a lot of work</li>
<li>I wanted to learn Docker for quite some time because you hear a lot about it</li>
</ul>
<p>In general, Docker is kind of like a virtual machine, so it allows us to develop in an OS of our choice (e.g. Windows)
but run the code in the same environment as it will in production (e.g. on a linux server). Thanks to its core principles,
it makes the separation of services really easy (e.g. having a dedicated server for your database) which - again -
is something that should happen on production anyway.</p>
<h3><a id="transition-vagrant"></a>Transition from Vagrant</h3>
<p>On Windows, you can either use the <a href="https://docs.docker.com/toolbox/toolbox_install_windows/">Docker Toolbox</a>
(which is essentially a VM with Docker setup on it) or the Hyper-V based <a href="https://www.docker.com/docker-windows">Docker for Windows</a>.
This tutorial will only look at the latter.</p>
<p><strong>A word of caution</strong>: Unfortunately, we cannot have other Gods besides Docker (on Windows).
The native Docker client requires Hyper-V to be activated which in turn will cause Virtualbox to not work any longer.
Thus, we will not be able to use Vagrant and Docker alongside each other.
This was actually the main reason it took me so long to start working with Docker.</p>
<h2><a id="setup-docker"></a>Setup Docker</h2>
<p>First, <a href="https://store.docker.com/editions/community/docker-ce-desktop-windows">download Docker for Windows</a>
(requires Microsoft Windows 10 Professional or Enterprise 64-bit). The version I am using in this tutorial is <code>18.03.1-ce-win65</code>.
During the installation,
leave the option &quot;Use Windows Containers instead of Linux containers&quot; unticked as we intend to develop on linux containers
(you can change it later anyway).</p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/use-linux-containers.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/use-linux-containers.PNG" alt="Install docker" /></a></p>
<p>After the installation finishes, we need to log out of Windows and in again.
Docker should start automatically. If not, there should be a &quot;Docker for Windows&quot; icon placed on your desktop.
If Hyper-V is not activated yet, Docker will automatically urge you to do so now.</p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/enable-hyper-v-and-containers.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/enable-hyper-v-and-containers.PNG" alt="Activate Hype-V" /></a></p>
<p>If you agree, Hyper-V and container features are activated and a reboot is initiated.
See <a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v">Install Hyper-V on Windows 10</a>
to deactivate it again.</p>
<p><strong>Caution</strong>: VirtualBox will stop working afterwards! Starting one of my previous machines from the VirtualBox interface
or via <code>vagrant up</code> fails with the error message</p>
<blockquote>
<p>VT-x is not available (VERR_VMX_NO_VMX)</p>
</blockquote>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/virtual-box-error.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/virtual-box-error.PNG" alt="Virtual box error" /></a>
<a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/vagrant-error.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/vagrant-error.PNG" alt="Vagrant error" /></a></p>
<p>After rebooting, Docker will start automatically and a welcome screen appears.</p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/welcome-screen.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/welcome-screen.PNG" alt="Docker welcome screen" /></a></p>
<p>We can ignore that (close the window).
In addition, a new icon is added to your system tray. A right-click reveals the context menu. </p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/system-tray-icon.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/system-tray-icon.PNG" alt="Docker settings in system tray" /></a></p>
<p>Open the tab &quot;Shared Devices&quot; and tick the hard drives on your host machine that you want to share with Docker containers. </p>
<p><em>Note: We will still need to define explicit path mappings for the actual containers later on, but the hard drive that the path belongs
to must be made available here. After clicking &quot;Apply&quot;, you will be prompted for your credentials</em></p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-shared-drives.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-shared-drives.PNG" alt="Docker settings: Shared devices" /></a>
<a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-shared-drives-credentials.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-shared-drives-credentials.PNG" alt="Docker settings: Credential prompt" /></a></p>
<p>Next, open tab &quot;Advanced&quot;. You don't actually have to change any of the settings but if you (like me)
don't have <code>C:/</code> set up as you biggest partition, you might want to change the &quot;Disk image location&quot;.
I'm putting mine at <code>C:\Hyper-V\Virtual Hard Disks\MobyLinuxVM.vhdx</code>. It might take some minutes for Docker to process the changes.</p>
<p>Docker &quot;physically&quot; stores the container images in that location.</p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-advanced-disk-image-location.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-advanced-disk-image-location.PNG" alt="Docker settings: Advanced" /></a></p>
<p>Congratulations, Docker is now set up on your machine ðŸ˜Š</p>
<h2><a id="setup-php-cli"></a>Setting up the PHP cli container</h2>
<p>Now that we have the general stuff out of the way, let's set up our first container.
I've created the directory <code>C:/codebase/docker-php/</code> and will run the remaining examples in there. </p>
<p>Firstly, lets create a directory for our sourcecode:</p>
<pre><code>mkdir -p "C:/codebase/docker-php/app"</code></pre>
<p>For the sake of simplicity, we will stick to the <a href="https://hub.docker.com/_/php/">official PHP image</a> and run:</p>
<pre><code>docker run -d --name docker-php -v "C:/codebase/docker-php/app":/var/www php:7.0-cli</code></pre>
<p>Which means:</p>
<pre><code>docker run                               // run a container
-d                                       // in the background (detached)
--name docker-php                        // named docker-php
-v "C:/codebase/docker-php/app":/var/www // sync the directory C:/codebase/docker-php/app on the 
                                         // windows host with /var/www in the container
php:7.0-cli                              // use this image to build the container</code></pre>
<p>The result looks something like this:</p>
<pre><code>$ docker run -d --name docker-php -v "C:/codebase/docker-php/app":/var/www php:7.0-cli
Unable to find image 'php:7.0-cli' locally
7.0-cli: Pulling from library/php
f2aa67a397c4: Pulling fs layer
c533bdb78a46: Pulling fs layer
65a7293804ac: Pulling fs layer
35a9c1f94aea: Pulling fs layer
54cffc62e1c2: Pulling fs layer
153ff2f4c2af: Pulling fs layer
96d392f71f56: Pulling fs layer
e8c43e665458: Pulling fs layer
35a9c1f94aea: Waiting
54cffc62e1c2: Waiting
153ff2f4c2af: Waiting
96d392f71f56: Waiting
e8c43e665458: Waiting
c533bdb78a46: Verifying Checksum
c533bdb78a46: Download complete
35a9c1f94aea: Verifying Checksum
35a9c1f94aea: Download complete
f2aa67a397c4: Verifying Checksum
f2aa67a397c4: Download complete
153ff2f4c2af: Verifying Checksum
153ff2f4c2af: Download complete
54cffc62e1c2: Verifying Checksum
54cffc62e1c2: Download complete
e8c43e665458: Verifying Checksum
e8c43e665458: Download complete
96d392f71f56: Verifying Checksum
96d392f71f56: Download complete
f2aa67a397c4: Pull complete
65a7293804ac: Verifying Checksum
65a7293804ac: Download complete
c533bdb78a46: Pull complete
65a7293804ac: Pull complete
35a9c1f94aea: Pull complete
54cffc62e1c2: Pull complete
153ff2f4c2af: Pull complete
96d392f71f56: Pull complete
e8c43e665458: Pull complete
Digest: sha256:ff6c5e695a931f18a5b59c82b1045edea42203a299e89a554ebcd723df8b9014
Status: Downloaded newer image for php:7.0-cli
56af890e1a61f8ffa5528b040756dc62a94c0b929c29df82b9bf5dec6255321f</code></pre>
<p>Since we don't have the image on our machine (see <code>Unable to find image 'php:7.0-cli' locally</code>),
Docker attempts to pull it from the official registry at <a href="https://hub.docker.com/">https://hub.docker.com/</a>.
We've specifically chosen the &quot;7.0-cli&quot; version of the PHP image (which means: PHP 7.0 CLI only).
See <a href="https://hub.docker.com/_/php/">https://hub.docker.com/_/php/</a> for a list of all available tags/images.</p>
<p>Now let's see if the container is actually running via <code>docker ps</code></p>
<pre><code>$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</code></pre>
<p>Weird. For some reason, we don't see our newly created container there. Let's check with the <code>-a</code> flag to list <strong>all</strong> containers,
even the ones that are not running.</p>
<pre><code>$ docker ps -a
CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS                      PORTS               NAMES
56af890e1a61        php:7.0-cli         "docker-php-entrypoiâ€¦"   27 seconds ago     Exited (0) 25 seconds ago                       docker-php</code></pre>
<p>Aha. So the container was created, but immediately stopped (see <code>Created 27 seconds ago; Exited (0) 25 seconds ago</code>).
That's because a container only <a href="https://stackoverflow.com/a/28214133/413531">lives as long as it's main process is running</a>.
According to <a href="https://docs.docker.com/config/containers/multi-service_container/">the docs</a>,</p>
<blockquote>
<p>A container's main running process is the ENTRYPOINT and/or CMD at the end of the Dockerfile.&quot; </p>
</blockquote>
<p><a href="https://stackoverflow.com/a/21564990/413531">This answer explains the difference between CMD and ENTRYPOINT</a> quite well.
Since we don't have a Dockerfile defined, we would need to look at the
<a href="https://github.com/docker-library/php/blob/27c65bbd606d1745765b89bf43f39b06efad1e43/7.0/stretch/cli/Dockerfile">Dockerfile of the base image</a>
we're using, but I actually don't wanna go down this rabbit hole for now. Basically, the &quot;problem&quot; is, that the
container doesn't have a long running process / service defined, (as the php-fpm or the nginx containers do later on).
To keep the container alive, we need to add the <code>-i</code> flag to the <code>docker run</code> command:</p>
<pre><code>docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www php:7.0-cli</code></pre>
<p>But then this happens:</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /
$ docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www php:7.0-cli
C:\Program Files\Docker\Docker\Resources\bin\docker.exe: Error response from daemon: Conflict. The container name "/docker-php" is already in use by container "56af890e1a61f8ffa5528b040756dc62a94c0b929c29df82b9bf5dec6255321f". You have to remove (or rename) that container to be able to reuse that name.
See 'C:\Program Files\Docker\Docker\Resources\bin\docker.exe run --help'.</code></pre>
<p>Apparently, we cannot use the same name (<code>docker-php</code>) again. Bummer. So, let's remove the previous container first via </p>
<pre><code>docker rm docker-php</code></pre>
<p>and try again afterwards:</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /
$ docker rm docker-php
docker-php

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www php:7.0-cli
7b3024a542a2d25fd36cef96f4ea689ec7ebb758818758300097a7be3ad2c2f6

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker ps
CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS              PORTS               NAMES
7b3024a542a2        php:7.0-cli         "docker-php-entrypoiâ€¦"   5 seconds ago      Up 4 seconds                            docker-php</code></pre>
<p>Sweet, so now that the container is up and running, let's &quot;<a href="https://stackoverflow.com/a/30173220">log in</a>&quot; via </p>
<pre><code>docker exec -it docker-php bash</code></pre>
<p>You might get the following error message</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker exec -it docker-php bash
the input device is not a TTY.  If you are using mintty, try prefixing the command with 'winpty'</code></pre>
<p>If so, prefixing the command with <code>winpty</code> should help:</p>
<pre><code>winpty docker exec -it docker-php bash</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ winpty docker exec -it docker-php bash
root@7b3024a542a2:/#</code></pre>
<p>A quick <code>php -v</code> within the container verifies, that we can actually run php scripts in there:</p>
<pre><code>root@7b3024a542a2:/# php -v
PHP 7.0.30 (cli) (built: May 23 2018 23:04:32) ( NTS )
Copyright (c) 1997-2017 The PHP Group
Zend Engine v3.0.0, Copyright (c) 1998-2017 Zend Technologies</code></pre>
<p>Remember the path mapping, that we specified? Let's create a simple &quot;hello world&quot; script <strong>on the windows 10 host machine</strong>
at <code>C:\codebase\docker-php\app\hello-world.php</code> to make sure it works:</p>
<pre><code>cd "C:\codebase\docker-php\app"
echo '&lt;?php echo "Hello World (php)\n"; ?&gt;' &gt; hello-world.php</code></pre>
<p>Should look like this on the host machine:</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ ls -alh app
total 1,0K
drwxr-xr-x 1 Pascal 197121  0 Mai 28 12:29 ./
drwxr-xr-x 1 Pascal 197121  0 Mai 28 11:46 ../
-rw-r--r-- 1 Pascal 197121 49 Mai 28 12:30 hello-world.php</code></pre>
<p>And like this from within the container:</p>
<pre><code>root@7b3024a542a2:/# ls -alh /var/www
total 4.5K
drwxr-xr-x 2 root root  0 May 28 10:29 .
drwxr-xr-x 1 root root 4.0K May 28 10:00 ..
-rwxr-xr-x 1 root root   31 May 28 10:31 hello-world.php</code></pre>
<p>Let's run the script <strong>in the container</strong> via </p>
<pre><code>php /var/www/hello-world.php</code></pre>
<pre><code>root@7b3024a542a2:/# php /var/www/hello-world.php
Hello World</code></pre>
<p>Purrfect. We created the file on our host system and it's automatically available in the container. </p>
<h3><a id="xdebug-php"></a>Installing Xdebug in the PHP container</h3>
<p>Since we intend to use Docker for our local development setup, the ability to debug is mandatory. So let's extend our image with the xdebug extension.
The readme of the official Docker PHP repository does a good job at explaining
<a href="https://github.com/docker-library/docs/blob/master/php/README.md#how-to-install-more-php-extensions">how to install extensions</a>.
For xdebug, we'll use PECL. To install the extension, make sure to be logged into the container and run </p>
<pre><code>pecl install xdebug-2.6.0</code></pre>
<p>You should see an output like this:</p>
<pre><code>root@7b3024a542a2:/# pecl install xdebug-2.6.0
[...]
Build process completed successfully
Installing '/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so'
install ok: channel://pecl.php.net/xdebug-2.6.0
configuration option "php_ini" is not set to php.ini location
You should add "zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so" to php.ini</code></pre>
<p>The xdebug extension has been build and saved in <code>/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so</code>.
To actually activate it, run </p>
<pre><code>docker-php-ext-enable xdebug</code></pre>
<p>That helper command will place the file <code>docker-php-ext-xdebug.ini</code> in the directory for additional php ini files with the content</p>
<pre><code>zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so</code></pre>
<p>which enables the extension. Btw. you can locate the additional php ini files folder by running </p>
<pre><code>php -i | grep "additional .ini"</code></pre>
<p>Result:</p>
<pre><code>root@7b3024a542a2:/# php -i | grep "additional .ini"
Scan this dir for additional .ini files =&gt; /usr/local/etc/php/conf.d</code></pre>
<p>When we check the contents of that folder, we will indeed find the <code>xdebug.ini</code> file with the before mentioned content and <code>php -m</code> reveals,
that xdebug is actually active.</p>
<pre><code>root@7b3024a542a2:/# ls -alh /usr/local/etc/php/conf.d
total 12K
drwxr-sr-x 1 root staff 4.0K May 28 13:30 .
drwxr-sr-x 1 root staff 4.0K Apr 30 20:34 ..
-rw-r--r-- 1 root staff   81 May 28 13:30 docker-php-ext-xdebug.ini
root@7b3024a542a2:/# cat /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini
zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so
root@7b3024a542a2:/# php -m | grep xdebug
xdebug</code></pre>
<p>Now we'll log out of the container (type &quot;exit&quot; or hit <code>CTRL</code> +<code>D</code>) and stop the container via </p>
<pre><code>docker stop docker-php</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker stop docker-php
docker-php

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker ps -a
CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS                      PORTS               NAMES
7b3024a542a2        php:7.0-cli         "docker-php-entrypoiâ€¦"   2 hours ago        Exited (137) 7 seconds ago                      docker-php</code></pre>
<p>Now we start the container again via </p>
<pre><code>docker start docker-php</code></pre>
<p>log back in and check if xdebug is still there:</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker start docker-php
docker-php

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ winpty docker exec -it docker-php bash
root@7b3024a542a2:/# php -m | grep xdebug
xdebug</code></pre>
<p>And... it is! So the changes we made &quot;survived&quot; a restart of the container. But: They won't survive a &quot;rebuild&quot; of the container.
First we stop and remove the container via </p>
<pre><code>docker rm -f docker-php</code></pre>
<p>The <code>-f</code> flag forces the container to stop. Otherwise we would need an additional <code>docker stop docker-php</code> before.</p>
<p>Then we rebuild it, log in</p>
<pre><code>docker run -di --name docker-php -v "C:/codebase/docker-php/":/codebase php:7.0-cli
inpty docker exec -it docker-php bash</code></pre>
<p>and check for xdebug:</p>
<pre><code>php -m | grep xdebug</code></pre>
<p>... which won't be there anymore.</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker rm -f docker-php
docker-php

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker run -di --name docker-php -v "C:/codebase/docker-php/":/codebase php:7.0-cli
1da17524418f5327760eb113904b7ceec30f22b41e4b4bd77f9fa2f7b92b4ead

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ winpty docker exec -it docker-php bash
root@1da17524418f:/# php -m | grep xdebug
root@1da17524418f:/#</code></pre>
<p>Note the new container ID (before: <code>7b3024a542a2</code>; now: <code>1da17524418f</code>) and that <code>php -m | grep xdebug</code> doesn't yield anything.</p>
<h3><a id="dockerfile"></a>Persisting image changes with a Dockerfile</h3>
<p>Simply put, a <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile</a> describes the changes we make to a base image,
so we (and everybody else) can easily recreate the same environment. In our case,
we need to define the PHP base image that we used as well as instructions for installing and enabling xdebug.
To clearly separate infrastructure from code, we'll create a new directory at <code>C:/codebase/docker-php/php-cli/</code>.
Create a file named <code>Dockerfile</code> in this directory</p>
<pre><code>mkdir "C:/codebase/docker-php/php-cli/"
touch "C:/codebase/docker-php/php-cli/Dockerfile"</code></pre>
<p>and give it the following content:</p>
<pre><code>FROM php:7.0-cli
RUN pecl install xdebug-2.6.0 \
    &amp;&amp; docker-php-ext-enable xdebug</code></pre>
<p>Change to the <code>C:/codebase/docker-php/php-cli/</code> directory and build the image based on that Dockerfile</p>
<pre><code>cd "C:/codebase/docker-php/php-cli/"
docker build -t docker-php-image -f Dockerfile .</code></pre>
<p>The <code>-f Dockerfile</code> is actually optional as this is the default anyway. &quot;docker-php-image&quot; is the name of our new image. </p>
<p>If you encounter the following error </p>
<pre><code>"docker build" requires exactly 1 argument.
See 'docker build --help'.

Usage:  docker build [OPTIONS] PATH | URL | - [flags]

Build an image from a Dockerfile</code></pre>
<p>you probably missed the trailing <code>.</code> at the end of <code>docker build -t docker-php-image -f Dockerfile .</code> ;)</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker build -t docker-php-image -f Dockerfile .
Sending build context to Docker daemon   5.12kB
Step 1/2 : FROM php:7.0-cli
 ---&gt; da771ba4e565
Step 2/2 : RUN pecl install xdebug-2.6.0    &amp;&amp; docker-php-ext-enable xdebug
 ---&gt; Running in ff16ef56e648
downloading xdebug-2.6.0.tgz ...
Starting to download xdebug-2.6.0.tgz (283,644 bytes)
[...]
You should add "zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so" to php.ini
Removing intermediate container ff16ef56e648
 ---&gt; 12be27256b12
Successfully built 12be27256b12
Successfully tagged docker-php-image:latest
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have '-rwxr-xr-x' permissions. It is recommended to double check and reset permissions for sensitive files and directories.</code></pre>
<p>Note, that the building takes longer than before, because Docker now needs to do the extra work of installing xdebug.
Instead of using the base <code>php:7.0-cli</code> image, we'll now use our new, shiny <code>docker-php-image</code> image to start the container and check for xdebug.</p>
<pre><code>docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www docker-php-image</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www docker-php-image
C:\Program Files\Docker\Docker\Resources\bin\docker.exe: Error response from daemon: Conflict. The container name "/docker-php" is already in use by container "2e84cb536fc573142a9951331b16393e3028d9c6eff87f89cfda682279634a2b". You have to remove (or rename) that container to be able to reuse that name.
See 'C:\Program Files\Docker\Docker\Resources\bin\docker.exe run --help'.</code></pre>
<p>Aaaand we get an error, because we tried to use the same name (&quot;docker-php&quot;), that we used for the previous, still running container.
Sigh.. fortunately we already know how to solve that via</p>
<pre><code>docker rm -f docker-php</code></pre>
<p>Retry </p>
<pre><code>docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www docker-php-image</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker rm -f docker-php
docker-php

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www docker-php-image
f27cc1310c836b15b7062e1fd381f283250a85133fb379c4cf1f891dec63770b

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ winpty docker exec -it docker-php bash
root@f27cc1310c83:/# php -m | grep xdebug
xdebug</code></pre>
<p>Yep, all good. Btw. since we &quot;only&quot; want to check if xdebug was installed, we could also simply pass <code>-m</code> to the <code>docker run</code> command:</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker run docker-php-image php -m | grep xdebug
xdebug</code></pre>
<p>Be aware that this will create a new container every time it's run (, note the first entry with the wonderful name &quot;distracted_mclean&quot;):</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker ps -a
CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS                      PORTS               NAMES
abc9fec8a88b        docker-php-image    "docker-php-entrypoiâ€¦"   4 minutes ago      Exited (0) 4 minutes ago                        distracted_mclean
f27cc1310c83        docker-php-image    "docker-php-entrypoiâ€¦"   10 minutes ago     Exited (137) 6 minutes ago                      docker-php</code></pre>
<p>Before we move on, let's []stop and remove all containers via](<a href="https://coderwall.com/p/ewk0mq/stop-remove-all-docker-containers">https://coderwall.com/p/ewk0mq/stop-remove-all-docker-containers</a>).</p>
<pre><code>docker rm -f $(docker ps -aq)</code></pre>
<p>The <code>$(docker ps -aq)</code> part returns only the numeric ids of all containers and passes them to the <code>docker rm -f</code> command.</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker rm -f $(docker ps -aq)
abc9fec8a88b
f27cc1310c83</code></pre>
<h2><a id="webstack"></a>Setting up a web stack with php-fpm and nginx</h2>
<p>Since most people are probably not only working on CLI scripts but rather on web pages,
the next step in this tutorial is about setting up an nginx web server and connect it to php-fpm.</p>
<h3><a id="setup-nginx"></a>Setting up nginx</h3>
<p>We're gonna use the <a href="https://hub.docker.com/_/nginx/">official nginx image</a> and since we don't know anything about that image yet,
let's run and explore it a bit:</p>
<pre><code>docker run -di nginx:latest</code></pre>
<p>yields</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /
$ docker run -di nginx:latest
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
[...]
Status: Downloaded newer image for nginx:latest
15c6b8d8a2bff873f353d24dc9c40d3008da9396029b3f1d9db7caeebedd3f50</code></pre>
<p>Note that we only used the minimum number of arguments here. Since we did not specify a name, we will simply use the ID instead to log in
(so be sure to use the one that your shell returned - don't just copy the line below :P)</p>
<pre><code>$ winpty docker exec -it 15c6b8d8a2bff873f353d24dc9c40d3008da9396029b3f1d9db7caeebedd3f50 bash
root@15c6b8d8a2bf:/#</code></pre>
<p>We would expect that there is an nginx process running, but upon checking with <code>ps aux</code> we get </p>
<pre><code>bash: ps: command not found" as a response. </code></pre>
<p>This is common when using docker images, because they are usually kept as minimal as possible.
Although this is a good practice in production, it is kind of cumbersome in development.
So, let's install <code>ps</code> via </p>
<pre><code>apt-get update &amp;&amp; apt-get install -y procps</code></pre>
<p>and try again:</p>
<pre><code>root@15c6b8d8a2bf:/# apt-get update &amp;&amp; apt-get install -y procps
Get:1 http://security.debian.org/debian-security stretch/updates InRelease [94.3 kB]
[...] 
associated file /usr/share/man/man1/w.procps.1.gz (of link group w) doesn't exist
Processing triggers for libc-bin (2.24-11+deb9u3) ...
root@15c6b8d8a2bf:/# ps aux
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root          1  0.0  0.2  32608  5148 ?        Ss   06:46   0:00 nginx: master process nginx -g daemon off;
nginx         5  0.0  0.1  33084  2388 ?        S    06:46   0:00 nginx: worker process
root         14  0.0  0.1  18132  3272 pts/0    Ss   06:50   0:00 bash
root        259  0.0  0.1  36636  2844 pts/0    R+   06:53   0:00 ps aux
root@15c6b8d8a2bf:/#</code></pre>
<p>Ah. Much better. Lets dig a little deeper and see how the process is configured via <code>nginx -V</code></p>
<pre><code>root@15c6b8d8a2bf:/# nginx -V
nginx version: nginx/1.13.12
built by gcc 6.3.0 20170516 (Debian 6.3.0-18+deb9u1)
built with OpenSSL 1.1.0f  25 May 2017
TLS SNI support enabled
configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/ng
inx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path
=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-
http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module
 --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_
module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt='-g -O2 -fdebug-prefix-map=/data/builder/debuild/nginx-1.13.12/debian/debuild-base/nginx-
1.13.12=. -specs=/usr/share/dpkg/no-pie-compile.specs -fstack-protector-strong -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fPIC' --with-ld-opt='-specs=/usr/share/dpkg/no-pie-link.specs -Wl,-z,relr
o -Wl,-z,now -Wl,--as-needed -pie'</code></pre>
<p>Sweet, so the configuration file is placed in the default location at <code>/etc/nginx/nginx.conf</code>
(see <code>--conf-path=/etc/nginx/nginx.conf</code>). Checking that file will show us, where we need to place additional config files
(e.g. for the configuration of our web site). Run</p>
<pre><code>cat /etc/nginx/nginx.conf</code></pre>
<p>... and see</p>
<pre><code>root@15c6b8d8a2bf:/# cat /etc/nginx/nginx.conf

user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}</code></pre>
<p>Note the line <code>include /etc/nginx/conf.d/*.conf</code> at the end of the file. In this directory, we'll find the default nginx config:</p>
<pre><code>ls -alh /etc/nginx/conf.d/
cat /etc/nginx/conf.d/default.conf</code></pre>
<pre><code>root@15c6b8d8a2bf:/# ls -alh /etc/nginx/conf.d/
total 12K
drwxr-xr-x 2 root root 4.0K Apr 30 13:55 .
drwxr-xr-x 3 root root 4.0K Apr 30 13:55 ..
-rw-r--r-- 1 root root 1.1K Apr  9 16:01 default.conf
root@15c6b8d8a2bf:/# cat /etc/nginx/conf.d/default.conf
server {
    listen       80;
    server_name  localhost;

    #charset koi8-r;
    #access_log  /var/log/nginx/host.access.log  main;

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    # proxy the PHP scripts to Apache listening on 127.0.0.1:80
    #
    #location ~ \.php$ {
    #    proxy_pass   http://127.0.0.1;
    #}

    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    #
    #location ~ \.php$ {
    #    root           html;
    #    fastcgi_pass   127.0.0.1:9000;
    #    fastcgi_index  index.php;
    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
    #    include        fastcgi_params;
    #}

    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
}</code></pre>
<p>So the server is listening on port 80. Unfortunately, we cannot reach the web server from our windows host machine,
as there is currently (2018-05-31) an <a href="https://github.com/docker/for-win/issues/221">open bug for accessing container IPs from a windows host</a>
(don't worry, we'll fix that with port mappings in a second)).
So, in order to verify that the server is actually  working, we'll install <code>curl</code> inside the nginx container and fetch <code>127.0.0.1:80</code>:</p>
<pre><code>apt-get install curl -y
curl localhost:80</code></pre>
<p>Looks like this:</p>
<pre><code>root@15c6b8d8a2bf:/# apt-get install curl -y
Reading package lists... Done
Building dependency tree
[...]
Running hooks in /etc/ca-certificates/update.d...
done.
root@15c6b8d8a2bf:/# curl localhost:80
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>Looks good! Now let's customize some stuff:</p>
<ul>
<li>point the root to <code>/var/www</code></li>
<li>place a &quot;Hello world&quot; index file in <code>/var/www/index.html</code></li>
</ul>
<pre><code>sed -i "s#/usr/share/nginx/html#/var/www#" /etc/nginx/conf.d/default.conf
mkdir -p /var/www
echo "Hello world!" &gt; /var/www/index.html</code></pre>
<p>To make the changes become effective, we need to <a href="http://nginx.org/en/docs/beginners_guide.html#control">reload nginx</a> via </p>
<pre><code>nginx -s reload</code></pre>
<pre><code>root@15c6b8d8a2bf:/# nginx -s reload
2018/05/29 09:22:54 [notice] 351#351: signal process started</code></pre>
<p>Check with curl, et voilÃ¡:</p>
<pre><code>root@15c6b8d8a2bf:/# curl 127.0.0.1:80
Hello world!</code></pre>
<p>With all that new information we can set up our nginx image with the following folder structure on the host machine:</p>
<pre><code>C:\codebase\docker-php
+ nginx\
  + conf.d\
    - site.conf
  - Dockerfile
+ app\
  - index.html
  - hello-world.php</code></pre>
<p><code>nginx\Dockerfile</code></p>
<pre><code>FROM nginx:latest</code></pre>
<p><code>nginx\conf.d\site.conf</code></p>
<pre><code>server {
    listen      80;
    server_name localhost;
    root        /var/www;
}</code></pre>
<p><code>app\index.html</code></p>
<pre><code>Hello World</code></pre>
<p>Clean up the &quot;exploration&quot; nginx container, <code>cd</code> into <code>/c/codebase/docker-php/nginx</code> and build the new image: </p>
<pre><code>docker rm -f $(docker ps -aq)
cd /c/codebase/docker-php/nginx
docker build -t docker-nginx-image .</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker rm -f $(docker ps -aq)
15c6b8d8a2bf
Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ cd nginx
Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/nginx
$ docker build -t docker-nginx-image .
Sending build context to Docker daemon  3.584kB
Step 1/1 : FROM nginx:latest
 ---&gt; ae513a47849c
Successfully built ae513a47849c
Successfully tagged docker-nginx-image:latest
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have '-rwxr-xr-x' permissions. It is recommended to double check and reset permissions for sensitive files and directories.</code></pre>
<p>And then run the &quot;new&quot; container via </p>
<pre><code>docker run -di --name docker-nginx -p 8080:80 -v "C:\codebase\docker-php\nginx\conf.d":/etc/nginx/conf.d/ -v "C:\codebase\docker-php\app":/var/www docker-nginx-image</code></pre>
<p>where</p>
<pre><code>-p 8080:80                                                  // maps port 8080 on the windows host to port 80 in the container
-v "C:\codebase\docker-php\nginx\conf.d":/etc/nginx/conf.d/ // mounts the conf.d folder on the host to the correct directory in the container
-v "C:\codebase\docker-php\app":/var/www                    // mounts the "code" directory in the correct place</code></pre>
<p>Thanks to the port mapping we can now simply open <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a> in a browser on the host machine
and see the content of our <code>app\index.html</code> file.</p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-nginx.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-nginx.PNG" alt="nginx index file" /></a></p>
<p>If you want some more information about running nginx on Docker, check out
<a href="https://www.digitalocean.com/community/tutorials/how-to-run-nginx-in-a-docker-container-on-ubuntu-14-04">this tutorial</a>.</p>
<p>Before we move on, let's clean up</p>
<pre><code>docker stop docker-nginx</code></pre>
<h3><a id="setup-php-fpm"></a>Setting up php-fpm</h3>
<p>We are already familiar with the official docker PHP image but have only used the cli-only version so far.
FPM ones can be pulled in by using the <code>-fpm</code> tags (e.g. like <code>php:7.0-fpm</code>).
As with nginx, let's explore the php-fpm image first:</p>
<pre><code>docker run -di --name php-fpm-test php:7.0-fpm</code></pre>
<p>The first thing to note is, that the image automatically exposes port 9000 as a <code>docker ps</code> reveals:</p>
<pre><code>$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                  NAMES
c5d23b694563        php:7.0-fpm         "docker-php-entrypoiâ€¦"   4 hours ago         Up 4 hours                  9000/tcp               php-fpm-test</code></pre>
<p>When we examine the Dockerfile that was used to build the image
(click <a href="https://hub.docker.com/r/library/php/">here</a> and search for the &quot;7.0-fpm&quot; tag
that currently (2018-05-31) links <a href="https://github.com/docker-library/php/blob/27c65bbd606d1745765b89bf43f39b06efad1e43/7.0/stretch/fpm/Dockerfile">here</a>),
we can see that it contains an <code>EXPOSE 9000</code> at the bottom.</p>
<p>What else we can we figure out...</p>
<pre><code>winpty docker exec -it php-fpm-test bash</code></pre>
<p>First, will check where the configuration files are located via <code>php-fpm -i | grep config</code>:</p>
<pre><code>root@c5d23b694563:/var/www/html# php-fpm -i | grep config
Configure Command =&gt;  './configure'  '--build=x86_64-linux-gnu' '--with-config-file-path=/usr/local/etc/php' '--with-config-file-scan-dir=/usr/local/etc/php/conf.d' '--enable-option-checking=fatal' '--disable-c
gi' '--with-mhash' '--enable-ftp' '--enable-mbstring' '--enable-mysqlnd' '--with-curl' '--with-libedit' '--with-openssl' '--with-zlib' '--with-libdir=lib/x86_64-linux-gnu' '--enable-fpm' '--with-fpm-user=www-da
ta' '--with-fpm-group=www-data' 'build_alias=x86_64-linux-gnu'
fpm.config =&gt; no value =&gt; no value
[...]
</code></pre>
<p><code>--with-config-file-path=/usr/local/etc/php</code> is our suspect. So it is very likely,
that we will find the <a href="https://myjeeva.com/php-fpm-configuration-101.html#global-directives">global directives config file</a> at
<code>/usr/local/etc/php-fpm.conf</code> (unfortunately, we cannot resolve the location directly).
<code>grep</code>'ing this file for <code>include=</code> reveals the location for the
<a href="https://myjeeva.com/php-fpm-configuration-101.html#pool-directives">pool directives config</a>:</p>
<pre><code>grep "include=" /usr/local/etc/php-fpm.conf</code></pre>
<pre><code>root@c5d23b694563:/var/www/html# grep "include=" /usr/local/etc/php-fpm.conf
include=etc/php-fpm.d/*.conf</code></pre>
<p>Hm - a relative path. That looks kinda odd? Let's get a little more context with the <code>-C</code> option for <code>grep</code>:</p>
<pre><code>grep -C 6 "include=" /usr/local/etc/php-fpm.conf</code></pre>
<pre><code>root@c5d23b694563:/var/www/html# grep -C 6 "include=" /usr/local/etc/php-fpm.conf
; Include one or more files. If glob(3) exists, it is used to include a bunch of
; files from a glob(3) pattern. This directive can be used everywhere in the
; file.
; Relative path can also be used. They will be prefixed by:
;  - the global prefix if it's been set (-p argument)
;  - /usr/local otherwise
include=etc/php-fpm.d/*.conf</code></pre>
<p>Ah - that makes more sense. So we need to resolve <code>etc/php-fpm.d/*.conf</code> relative to <code>/usr/local</code>.
Resulting in <code>/usr/local/etc/php-fpm.d/*.conf</code> (usually you'll at least find a <code>www.conf</code> file in there).
The pool config determines amongst other things how php-fpm listens for connections (e.g. via Unix socket or via TCP IP:port).</p>
<pre><code>cat /usr/local/etc/php-fpm.d/www.conf</code></pre>
<pre><code>root@c5d23b694563:/var/www/html# cat /usr/local/etc/php-fpm.d/www.conf
[...]
; The address on which to accept FastCGI requests.
; Valid syntaxes are:
;   'ip.add.re.ss:port'    - to listen on a TCP socket to a specific IPv4 address on
;                            a specific port;
;   '[ip:6:addr:ess]:port' - to listen on a TCP socket to a specific IPv6 address on
;                            a specific port;
;   'port'                 - to listen on a TCP socket to all addresses
;                            (IPv6 and IPv4-mapped) on a specific port;
;   '/path/to/unix/socket' - to listen on a unix socket.
; Note: This value is mandatory.
listen = 127.0.0.1:9000
[...]</code></pre>
<p>php-fpm ist listening on port 9000 on 127.0.0.1 (localhost). So it makes total sense to expose port 9000.</p>
<h4><a id="php-fpm-xdebug"></a>Installing xdebug</h4>
<p>Since we probably also want to debug php-fpm, xdebug needs to be setup as well. The process is pretty much the same as for the cli image:</p>
<pre><code>pecl install xdebug-2.6.0
docker-php-ext-enable xdebug
php-fpm -m | grep xdebug</code></pre>
<p>Of course we'll also put that in its own Dockerfile:</p>
<pre><code>C:\codebase\docker-php
+ php-fpm\
  - Dockerfile</code></pre>
<p><code>php-fpm\Dockerfile</code></p>
<pre><code>FROM php:7.0-fpm
RUN pecl install xdebug-2.6.0 \
    &amp;&amp; docker-php-ext-enable xdebug</code></pre>
<p>Clean up the test container and build the new image</p>
<pre><code>docker rm -f php-fpm-test
cd /c/codebase/docker-php/php-fpm
docker build -t docker-php-fpm-image .</code></pre>
<h3><a id="connecting-nginx-php-fpm"></a>Connecting nginx and php-fpm</h3>
<p>Now that we have containers for nginx and php-fpm, we need to connect them.
To do so, we have to make sure that both containers are in the same network and can talk to each other
(<a href="https://stackoverflow.com/questions/29905953/how-to-correctly-link-php-fpm-and-nginx-docker-containers">which is a common problem</a>).
Docker provides so called
<a href="https://docs.docker.com/network/network-tutorial-standalone/#use-user-defined-bridge-networks">user defined bridge networks</a>
allowing <strong>automatic service discovery</strong>. That basically means,
that our nginx container can use <em>the name</em> of the php-fpm container to connect to it.
Otherwise we would have to figure out the containers <em>IP address</em> in the default network every time we start the containers.</p>
<pre><code>docker network ls</code></pre>
<p>reveals a list of the current networks</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /
$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
7019b0b37ba7        bridge              bridge              local
3820ad97cc92        host                host                local
03fecefbe8c9        none                null                loca</code></pre>
<p>Now let's add a new one called <code>web-network</code> for our web stack via </p>
<pre><code>docker network create --driver bridge web-network</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /
$ docker network create --driver bridge web-network
20966495e04e9f9df9fd64fb6035a9e9bc3aa6d83186dcd23454e085a0d97648

Pascal@Landau-Laptop MINGW64 /
$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
7019b0b37ba7        bridge              bridge              local
3820ad97cc92        host                host                local
03fecefbe8c9        none                null                local
20966495e04e        web-network         bridge              local</code></pre>
<p>Start the nginx container and connect it to the new network via</p>
<pre><code>docker start docker-nginx
docker network connect web-network docker-nginx</code></pre>
<p>Finally, we need to mount the local code folder <code>app\</code> we mounted to the nginx container at <code>/var/www</code>
also in the php-fpm container in the same location:</p>
<pre><code>docker run -di --name docker-php-fpm -v "C:\codebase\docker-php\app":/var/www --network web-network docker-php-fpm-image</code></pre>
<p>Note that we specified the network in the run command via the <code>--network</code> option.
We can verify that both containers are connected to the <code>web-network</code> by running </p>
<pre><code>docker network inspect web-network</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-fpm
$ docker network inspect web-network
[
    {
        "Name": "web-network",
        "Id": "20966495e04e9f9df9fd64fb6035a9e9bc3aa6d83186dcd23454e085a0d97648",
        "Created": "2018-05-30T06:39:44.3107066Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "3358e813423165880d59c8ebc2cb4c563ee8ad1d401595f8bfcf763ff5db8f4a": {
                "Name": "docker-php-fpm",
                "EndpointID": "d2f1d6285a0932817e1fb8839bef3a6d178f5306a2116307dba200038ea2a3a3",
                "MacAddress": "02:42:ac:12:00:03",
                "IPv4Address": "172.18.0.3/16",
                "IPv6Address": ""
            },
            "eaa5c05942788985e90a80fa000723286e9b4e7179d0f6f431c0f5109e012764": {
                "Name": "docker-nginx",
                "EndpointID": "274fa9a6868aff656078a72e19c05fb87e4e86b83aaf12be9b943890140a421d",
                "MacAddress": "02:42:ac:12:00:02",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]</code></pre>
<p>The &quot;Containers&quot; key reveals that the <code>docker-php-fpm</code> container has the IP address 172.18.0.3
and the docker-nginx container is reachable via 172.18.0.2.
But can we actually connect from nginx to php-fpm? Let's find out:</p>
<p>Log into the nginx container </p>
<pre><code>winpty docker exec -ti docker-nginx bash</code></pre>
<p>and ping the IP</p>
<pre><code>ping 172.18.0.3 -c 2</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-fpm
$ winpty docker exec -ti docker-nginx bash
root@eaa5c0594278:/# ping 172.18.0.3 -c 2
bash: ping: command not found</code></pre>
<p>.. well, after we make the command available by installing <code>iputils-ping</code>:</p>
<pre><code>apt-get update &amp;&amp; apt-get install iputils-ping -y
ping 172.18.0.3 -c 2</code></pre>
<pre><code>root@eaa5c0594278:/# apt-get update &amp;&amp; apt-get install iputils-ping -y
root@eaa5c0594278:/# ping 172.18.0.3 -c 2
PING 172.18.0.3 (172.18.0.3) 56(84) bytes of data.
64 bytes from 172.18.0.3: icmp_seq=1 ttl=64 time=0.142 ms
64 bytes from 172.18.0.3: icmp_seq=2 ttl=64 time=0.162 ms

--- 172.18.0.3 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1071ms
rtt min/avg/max/mdev = 0.142/0.152/0.162/0.010 ms</code></pre>
<p>We can ping the container - that's good. But we were also promised we could reach the container by its name <code>docker-php-fpm</code>:</p>
<pre><code>ping docker-php-fpm -c 2</code></pre>
<pre><code>root@eaa5c0594278:/# ping docker-php-fpm -c 2
PING docker-php-fpm (172.18.0.3) 56(84) bytes of data.
64 bytes from docker-php-fpm.web-network (172.18.0.3): icmp_seq=1 ttl=64 time=0.080 ms
64 bytes from docker-php-fpm.web-network (172.18.0.3): icmp_seq=2 ttl=64 time=0.131 ms

--- docker-php-fpm ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1045ms
rtt min/avg/max/mdev = 0.080/0.105/0.131/0.027 ms</code></pre>
<p>And we can - awesome! Now we need to tell nginx to pass all PHP related requests to php-fpm by changing the
<code>nginx\conf.d\site.conf</code> file on our windows host to </p>
<pre><code>server {
    listen      80;
    server_name localhost;
    root        /var/www;

   location ~ \.php$ {
        try_files $uri =404;
        fastcgi_pass docker-php-fpm:9000;
        include fastcgi_params;
        fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }
}</code></pre>
<p>Note the <code>fastcgi_pass docker-php-fpm:9000;</code> line that tells nginx how to reach our php-fpm service.
Because we mounted the <code>nginx\conf.d</code> folder, we just need to reload nginx:</p>
<pre><code>nginx -s reload</code></pre>
<p>and open <a href="http://127.0.0.1:8080/hello-world.php">http://127.0.0.1:8080/hello-world.php</a> on a browser on your host machine.</p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-php-fpm.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-php-fpm.PNG" alt="php-fpm hello world" /></a></p>
<p>Btw. there's also a good tutorial on geekyplatypus.com on how to
<a href="http://geekyplatypus.com/dockerise-your-php-application-with-nginx-and-php7-fpm/">Dockerise your PHP application with Nginx and PHP7-FPM</a>.
But since it's using docker-compose you might want to read the next chapter first :)</p>
<h2><a id="docker-compose"></a>Putting it all together: Meet docker-compose</h2>
<p>Lets sum up what we have do now to get everything up and running:</p>
<ol>
<li>start php-cli</li>
<li>start nginx</li>
<li>start php-fpm</li>
</ol>
<pre><code>docker run -di --name docker-php -v "C:\codebase\docker-php\app":/var/www --network web-network docker-php-image
docker run -di --name docker-nginx -p 8080:80 -v "C:\codebase\docker-php\nginx\conf.d":/etc/nginx/conf.d/ -v "C:\codebase\docker-php\app":/var/www  --network web-network docker-nginx-image
docker run -di --name docker-php-fpm -v "C:\codebase\docker-php\app":/var/www --network web-network docker-php-fpm-image</code></pre>
<p>Hm. That's alright I guess... but it also feels like &quot;a lot&quot;. Wouldn't it be much better to have everything neatly defined in one place?
I bet so! Let me introduce you to <a href="https://docs.docker.com/compose/">docker-compose</a></p>
<blockquote>
<p>Compose is a tool for defining and running multi-container Docker applications.
With Compose, you use a YAML file to configure your application's services.
Then, with a single command, you create and start all the services from your configuration.</p>
</blockquote>
<p>Lets do this step by step, starting with the php-cli container. Create the file <code>C:\codebase\docker-php\docker-compose.yml</code>:</p>
<pre><code># tell docker what version of the docker-compose.yml we're using
version: '3'

# define the network
networks:
  web-network:

# start the services section
services:
  # define the name of our service
  # corresponds to the "--name" parameter
  docker-php-cli:
    # define the directory where the build should happened,
    # i.e. where the Dockerfile of the service is located
    # all paths are relative to the location of docker-compose.yml
    build: 
      context: ./php-cli
    # reserve a tty - otherwise the container shuts down immediately
    # corresponds to the "-i" flag
    tty: true
    # mount the app directory of the host to /var/www in the container
    # corresponds to the "-v" option
    volumes:
      - ./app:/var/www
    # connect to the network
    # corresponds to the "--network" option
    networks:
      - web-network</code></pre>
<p>Before we get started, we're gonna clean up the old containers:</p>
<pre><code>docker rm -f $(docker ps -aq)</code></pre>
<p>To test the docker-compose.yml we need to run <code>docker-compose up -d</code> from <code>C:\codebase\docker-php</code></p>
<pre><code>cd "C:\codebase\docker-php"
docker-compose up -d</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker-compose up -d
Creating network "docker-php_web-network" with the default driver
Building docker-php-cli
Step 1/2 : FROM php:7.0-cli
 ---&gt; da771ba4e565
Step 2/2 : RUN pecl install xdebug-2.6.0     &amp;&amp; docker-php-ext-enable xdebug
 ---&gt; Using cache
 ---&gt; 12be27256b12
Successfully built 12be27256b12
Successfully tagged docker-php_docker-php-cli:latest
Image for service docker-php-cli was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.
Creating docker-php_docker-php-cli_1 ... done</code></pre>
<p>Note that the image is build from scratch when we run <code>docker-compose up</code> for the first time.
A <code>docker ps -a</code> shows that the container is running fine, we can log in and execute source code from the host machine.</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker ps -a
CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS               NAMES
adf794f27315        docker-php_docker-php-cli   "docker-php-entrypoiâ€¦"   3 minutes ago       Up 2 minutes                            docker-php_docker-php-cli_1</code></pre>
<p>Logging in</p>
<pre><code>winpty docker exec -it docker-php_docker-php-cli_1 bash</code></pre>
<p>and running </p>
<pre><code>php /var/www/hello-world.php</code></pre>
<p>works as before</p>
<pre><code>root@adf794f27315:/# php /var/www/hello-world.php
Hello World (php)</code></pre>
<p>Now log out of the container and run </p>
<pre><code>docker-compose down </code></pre>
<p>to shut the container down again:</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker-compose down
Stopping docker-php_docker-php-cli_1 ... done
Removing docker-php_docker-php-cli_1 ... done
Removing network docker-php_web-network</code></pre>
<p>Add the remaining services to the <code>docker-compose.yml</code> file:</p>
<pre><code># tell docker what version of the docker-compose.yml we're using
version: '3'

# define the network
networks:
  web-network:

# start the services section
services:
  # define the name of our service
  # corresponds to the "--name" parameter
  docker-php-cli:
    # define the directory where the build should happened,
    # i.e. where the Dockerfile of the service is located
    # all paths are relative to the location of docker-compose.yml
    build: 
      context: ./php-cli
    # reserve a tty - otherwise the container shuts down immediately
    # corresponds to the "-i" flag
    tty: true
    # mount the app directory of the host to /var/www in the container
    # corresponds to the "-v" option
    volumes:
      - ./app:/var/www
    # connect to the network
    # corresponds to the "--network" option
    networks:
      - web-network

  docker-nginx:
    build: 
      context: ./nginx
    # defines the port mapping
    # corresponds to the "-p" flag
    ports:
      - "8080:80"
    tty: true
    volumes:
      - ./app:/var/www
      - ./nginx/conf.d:/etc/nginx/conf.d
    networks:
      - web-network

  docker-php-fpm:
    build: 
      context: ./php-fpm
    tty: true
    volumes:
      - ./app:/var/www
    networks:
      - web-network</code></pre>
<p>And up again...</p>
<pre><code>docker-compose up -d</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker-compose up -d
Building docker-nginx
Step 1/1 : FROM nginx:latest
 ---&gt; ae513a47849c
Successfully built ae513a47849c
Successfully tagged docker-php_docker-nginx:latest
Image for service docker-nginx was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.
Building docker-php-fpm
Step 1/2 : FROM php:7.0-fpm
 ---&gt; a637000da5a3
Step 2/2 : RUN pecl install xdebug-2.6.0     &amp;&amp; docker-php-ext-enable xdebug
 ---&gt; Running in 4ec27516df54
downloading xdebug-2.6.0.tgz ...
Starting to download xdebug-2.6.0.tgz (283,644 bytes)
[...]
---&gt; 120c8472b4f3
Successfully built 120c8472b4f3
Successfully tagged docker-php_docker-php-fpm:latest
Image for service docker-php-fpm was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.
Creating docker-php_docker-nginx_1   ... done
Creating docker-php_docker-php-cli_1 ... done
Creating docker-php_docker-php-fpm_1 ... done</code></pre>
<p>Only nginx and php-fpm needed to be built because the php-cli one already existed.
Lets check if we can still open <a href="http://127.0.0.1:8080/hello-world.php">http://127.0.0.1:8080/hello-world.php</a> in a browser on the host machine:</p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-php-fpm.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-php-fpm.PNG" alt="php-fpm hello world" /></a></p>
<p>Yes we can! So instead of needing to run 3 different command with a bunch of parameters we're now down to
<code>docker-compose up -d</code>. Looks like an improvement to me ;)</p>
<h2><a id="tl-dr"></a>The tl;dr</h2>
<p>The whole article is a lot to take in and it is most likely not the most efficient approach when you &quot;just want to get started&quot;.
So in this section we'll boil it down to only the necessary steps without in depth explanations.</p>
<ul>
<li><a href="https://store.docker.com/editions/community/docker-ce-desktop-windows">Download Docker for Windows</a></li>
<li><a href="#setup-docker">Install Docker</a>
<ul>
<li>activate Hyper-V (Virtual Box will stop working) </li>
<li>enable Disk Sharing in the settings</li>
</ul></li>
<li>Set up the following folder structure
<pre><code>C:\codebase\docker-php
+ nginx\
  + conf.d\
    - site.conf
  - Dockerfile
+ php-cli\
  - Dockerfile
+ php-fpm\
  - Dockerfile
+ app\
  - index.html
  - hello-world.html
- docker-compose.yml</code></pre>
<ul>
<li>or simply <code>git clone git@github.com:paslandau/docker-php-tutorial.git docker-php &amp;&amp; git checkout part_1_setting-up-php-php-fpm-and-nginx-for-local-development-on-docker</code></li>
</ul></li>
<li>Open a shell at <code>C:\codebase\docker-php</code></li>
<li>run <code>docker-compose up -d</code></li>
<li>check in browser via
<ul>
<li>127.0.0.1:8080</li>
<li>127.0.0.1:8080/hello-world.php</li>
</ul></li>
<li>run <code>docker-compose down</code></li>
</ul>
<p>Your application code lives in the <code>app\</code> folder and changes are automatically available to the containers.
This setup denotes the end of the first tutorial. In the next part we will learn how to set up Docker in PHPStorm,
especially in combination with xdebug.</p>]]></description>
                                                    <pubDate>Sun, 08 Jul 2018 22:00:00 +0000</pubDate>
                                <link>https://www.pascallandau.com/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=development-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/</guid>
            </item>
                    <item>
                <title>How to setup Laravel with PHPUnit on Vagrant in PhpStorm [Tutorial Part 3]</title>
                <description><![CDATA[<p>In this third part we will set up a fresh Laravel installation and configure everything to run it on Vagrant, triggered by PhpStorm.
That includes:</p>
<ul>
<li>install Laravel and Laravel Homestead</li>
<li>configure Vagrant through Homestead</li>
<li>run PHPUnit unit tests via PhpStorm on Vagrant</li>
<li>enable Laravel-specific configurations in PhpStorm</li>
</ul>
<p>And just as a reminder, the first part is over at
<a href="http://www.pascallandau.com/blog/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/">Setting up PHP7 with Xdebug 2.4 for PhpStorm</a>, the second
at <a href="http://www.pascallandau.com/blog/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/">Setting up PhpStorm with Vagrant and Laravel Homestead</a>.</p>
<h2>Table of contents</h2>
<ul>
<li><a href="#setting-up-laravel">Setting up Laravel</a><ul>
<li> <a href="#install-laravel">Install laravel/laravel</a></li>
<li> <a href="#install-homestead">Install laravel/homestead</a></li>
<li> <a href="#convenience-commands">Convenience commands</a></li>
</ul></li>
<li> <a href="#configure-php-storm">Configure PhpStorm</a><ul>
<li> <a href="#setup-phpunit">Setup PHPUnit</a></li>
<li> <a href="#laravel-specific-settings-in-phpstorm">Laravel-specific settings in PhpStorm</a></li>
</ul></li>
<li> <a href="#housekeeping">Housekeeping</a><ul>
<li> <a href="#update-the-gitignore-file">Update the .gitignore file</a></li>
<li> <a href="#update-the-readme-md-file">Update the readme.md file</a></li>
</ul></li>
</ul>
<h2><a id="setting-up-laravel"></a>Setting up Laravel</h2>
<p>Now that we have the basics covered, you should have got a fairly decent understanding how vagrant and PhpStorm play together. But it's still all a little
hacky and doesn't feel &quot;right&quot;. In this section I'll make up for that by explaining how I set up a completely fresh installation of Laravel (5.2) and configure
it to run on a homestead vagrant box for a &quot;real world development&quot; scenario. For now let's assume, that we have no vagrant box configured
(i.e. there is no virtual machine running, yet).</p>
<h3><a id="install-laravel"></a>Install laravel/laravel</h3>
<ul>
<li>Create a new PhpStorm project via <code>File &gt; New Project...</code> and name it &quot;LaravelExample&quot;</li>
<li>Open the PhpStorm terminal and run <code>composer create-project laravel/laravel tmp</code>. This will initialize a fresh
Laravel installation including dependencies. This isn't optimal, since we're doing this from our local machine and not
from within the vagrant box we're using later on. This might be a problem when the local PHP setup is (vastly) different from
the one in the vagrant box since the downloaded packages might differ. But on the other hand it's not really a big deal since we
can just run composer update once the vagrant box is running (from within the box).</li>
</ul>
<h3><a id="install-homestead"></a>Install laravel/homestead</h3>
<ul>
<li>Unfortunately, <a href="https://github.com/composer/composer/issues/1135">composer cannot create a new project in an existing directory</a>, so we
need to copy the contents of &quot;tmp&quot; afterwards into the parent directory &quot;LaravelExample&quot; and delete the &quot;tmp&quot; directory manually.</li>
<li>Next, make sure the current working directory of the shell is the PhpStorm project folder</li>
<li>Run <code>composer require laravel/homestead --dev</code>. The <a href="https://github.com/laravel/homestead">laravel/homestead</a> package gives a
more convenient way to deal with the setup of the vagrant homestead box as it enables us to use an easy yaml syntax to
define the properties we really need.</li>
<li>Run <code>vendor/bin/homestead make</code> (if that fails, run <code>vendor/bin/homestead.bat make</code> instead), which yields:
<pre><code>$ vendor/bin/homestead make
Homestead Installed!</code></pre>
<p>The command also places a <code>Homestead.yaml</code> file as well as a <code>Vagrantfile</code> in the project directory.
<a href="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/laravel/homestead-make.PNG"><img src="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/laravel/homestead-make.PNG" alt="Project folder after running vendor/bin/homestead make" /></a>
Technically, that would be all you need to do,
because everything is configured to work out of the box (e.g. the configuration of shared folders), but I would like to go over some details
just to make sure it is clear whats going on here.</p></li>
<li>
<p>Open the <code>Homestead.yaml</code> file which should look similar to this:</p>
<pre><code>---
ip: "192.168.10.10"
memory: 2048
cpus: 1
hostname: laravelexample
name: laravelexample
provider: virtualbox

authorize: ~/.ssh/id_rsa.pub

keys:
  - ~/.ssh/id_rsa

folders:
  - map: "C:/Users/Pascal/PhpstormProjects/LaravelExample"
    to: "/home/vagrant/laravelexample"

sites:
  - map: homestead.app
    to: "/home/vagrant/laravelexample/public"

databases:
  - homestead</code></pre>
<p>There are a few things I would like to adjust:</p>
<ul>
<li>make sure the <code>ip</code> (<code>192.168.10.10</code> in the example above) is not already used in your local network.
This is the IP that is assigned to your virtual machine.</li>
<li>
<pre><code>folders:
  - map: "C:/Users/Pascal/PhpstormProjects/LaravelExample"
    to: "/home/vagrant/laravelexample"</code></pre>
<ul>
<li><code>map</code> should point to the absolute path to the repository on your <strong>local</strong> (host) machine.</li>
<li><code>to</code> denotes the path on your <strong>vagrant</strong> (remote) machine that is mapped to the above mentioned path on your local machine,
so that you can access your local files within the vagrant box.</li>
</ul>
</li>
<li>
<pre><code>sites:
  - map: homestead.app
    to: "/home/vagrant/laravelexample/public"</code></pre>
<ul>
<li><code>map: homestead.app</code> denotes the hostname that the nginx is looking for to serve content on
you <em>should</em> adjust that entry if you are going to have multiple projects (e.g. to laravelexample.app instead of homestead.app)
although it not strictly necessary since nginx will respond to other hostnames as well</li>
<li><code>to: "/home/vagrant/laravelexample/public"</code> denotes the absolute path within the vagrant box that the above mentioned hostname uses as lookup path for content.
This should be the path to the <code>public</code> folder of the repository on your <strong>vagrant machine</strong></li>
</ul>
</li>
<li>
<p>If you already have an SSH key pair that is located in the <code>.ssh</code> folder in your home directory, you can leave the following lines in place:</p>
<pre><code>authorize: ~/.ssh/id_rsa.pub

keys:
  - ~/.ssh/id_rsa</code></pre>
<p>Otherwise, you should delete them. They are responsible for a) making it possible to connect
to the box by using your own ssh key and b) letting vagrant use your private key (which might come in handy
if you need to open up an SSH tunnel for example - but that's another story ;))</p>
</li>
<li>
<p>Finally, to make your life a little easier, add <code>192.168.10.10 laravelexample.app</code> and  <code>192.168.10.10 www.laravelexample.app</code>
to the <code>host</code> file on your local machine.
The default location on Windows is <code>C:\Windows\System32\drivers\etc</code>. You will probably need to copy the file
to another location, edit it there and then copy it again to <code>C:\Windows\System32\drivers\etc</code>. The file should look like this:</p>
<pre><code># Copyright (c) 1993-2009 Microsoft Corp.
#
# This is a sample HOSTS file used by Microsoft TCP/IP for Windows.
#
# This file contains the mappings of IP addresses to host names. Each
# entry should be kept on an individual line. The IP address should
# be placed in the first column followed by the corresponding host name.
# The IP address and the host name should be separated by at least one
# space.
#
# Additionally, comments (such as these) may be inserted on individual
# lines or following the machine name denoted by a '#' symbol.
#
# For example:
#
#      102.54.94.97     rhino.acme.com          # source server
#       38.25.63.10     x.acme.com              # x client host

# localhost name resolution is handled within DNS itself.
# 127.0.0.1       localhost
# ::1             localhost

192.168.10.10 laravelexample.app
192.168.10.10 www.laravelexample.app</code></pre>
<p>This adjustment makes it possible to open a browser on your host machine and point it to <code>laravelexample.app</code>
or <code>www.laravelexample.app</code> which will serve the content of your laravel installation <em>running within the vagrant box</em>.
If there are any issues editing the <code>host</code> file, <a href="http://www.howtogeek.com/howto/27350/beginner-geek-how-to-edit-your-hosts-file/">How-to Geek comes to the rescue. Again.</a></p>
</li>
</ul>
</li>
<li>
<p><code>Homestead.yaml</code> should now look like this:</p>
<pre><code>---
ip: "192.168.10.10"
memory: 2048
cpus: 1
hostname: laravelexample
name: laravelexample
provider: virtualbox

folders:
    - map: "C:/Users/Pascal/PhpstormProjects/LaravelExample"
      to: "/home/vagrant/laravelexample"

sites:
    - map: homestead.app
      to: "/home/vagrant/laravelexample/public"

databases:
    - homestead</code></pre>
</li>
<li>Cool, now let's start vagrant via <code>vagrant up</code>.
<pre><code>$ vagrant up
Bringing machine 'default' up with 'virtualbox' provider...
==&gt; default: Importing base box 'laravel/homestead'...
==&gt; default: Matching MAC address for NAT networking...
==&gt; default: Checking if box 'laravel/homestead' is up to date...
==&gt; default: Setting the name of the VM: laravelexample
==&gt; default: Fixed port collision for 22 =&gt; 2222. Now on port 2200.
==&gt; default: Clearing any previously set network interfaces...
==&gt; default: Preparing network interfaces based on configuration...
  default: Adapter 1: nat
  default: Adapter 2: hostonly
==&gt; default: Forwarding ports...
  default: 80 =&gt; 8000 (adapter 1)
  default: 443 =&gt; 44300 (adapter 1)
  default: 3306 =&gt; 33060 (adapter 1)
  default: 5432 =&gt; 54320 (adapter 1)
  default: 22 =&gt; 2200 (adapter 1)
==&gt; default: Running 'pre-boot' VM customizations...
==&gt; default: Booting VM...
==&gt; default: Waiting for machine to boot. This may take a few minutes...
  default: SSH address: 127.0.0.1:2200
  default: SSH username: vagrant
  default: SSH auth method: private key
  default: Warning: Connection timeout. Retrying...
  default:
  default: Vagrant insecure key detected. Vagrant will automatically replace
  default: this with a newly generated keypair for better security.
  default:
  default: Inserting generated public key within guest...
  default: Removing insecure key from the guest if it's present...
  default: Key inserted! Disconnecting and reconnecting using new SSH key...
==&gt; default: Machine booted and ready!
==&gt; default: Checking for guest additions in VM...
==&gt; default: Setting hostname...
==&gt; default: Configuring and enabling network interfaces...
==&gt; default: Mounting shared folders...
  default: /vagrant =&gt; C:/Users/Pascal/PhpstormProjects/LaravelExample
  default: /home/vagrant/laravelexample =&gt; C:/Users/Pascal/PhpstormProjects/LaravelExample
==&gt; default: Running provisioner: shell...
  default: Running: C:/Users/Pascal/AppData/Local/Temp/vagrant-shell20160627-11412-1e33p4n.sh
==&gt; default: Running provisioner: shell...
  default: Running: C:/Users/Pascal/AppData/Local/Temp/vagrant-shell20160627-11412-bun3u6.sh
==&gt; default: nginx stop/waiting
==&gt; default: nginx start/running, process 2202
==&gt; default: php7.0-fpm stop/waiting
==&gt; default: php7.0-fpm start/running, process 2220
==&gt; default: Running provisioner: shell...
  default: Running: C:/Users/Pascal/AppData/Local/Temp/vagrant-shell20160627-11412-8xmse3.sh
==&gt; default: mysql:
==&gt; default: [Warning] Using a password on the command line interface can be insecure.
==&gt; default: Running provisioner: shell...
  default: Running: C:/Users/Pascal/AppData/Local/Temp/vagrant-shell20160627-11412-ct1lb2.sh
==&gt; default: createdb: database creation failed: ERROR:  database "homestead" already exists
==&gt; default: Running provisioner: shell...
  default: Running: C:/Users/Pascal/AppData/Local/Temp/vagrant-shell20160627-11412-lhjib5.sh
==&gt; default: Running provisioner: shell...
  default: Running: inline script
==&gt; default: You are running composer with xdebug enabled. This has a major impact on runtime performance. See https://getcomposer.org/xdebug
==&gt; default: Updating to version 1.1.3.
==&gt; default:     Downloading: Connecting...
==&gt; default:
==&gt; default:     Downloading: 100%
==&gt; default:
==&gt; default:
==&gt; default: Use composer self-update --rollback to return to version 1.0.0</code></pre>
<p>Please note, that this will create a <code>.vagrant</code> folder in the directory of your laravel app.</p></li>
<li>
<p>We should now be able to ssh into the virtual machine by using <code>vagrant ssh</code></p>
<pre><code>$ vagrant ssh
Welcome to Ubuntu 14.04.4 LTS (GNU/Linux 3.19.0-25-generic x86_64)

 * Documentation:  https://help.ubuntu.com/
vagrant@laravelexample:~$</code></pre>
</li>
<li>Navigate to the application root directory via <code>cd /home/vagrant/laravelexample/</code> which should look like this:
<pre><code>vagrant@laravelexample:~/laravelexample$ cd /home/vagrant/laravelexample/
vagrant@laravelexample:~/laravelexample$ ll
total 157
drwxrwxrwx 1 vagrant vagrant   4096 Jun 26 22:04 ./
drwxr-xr-x 7 vagrant vagrant   4096 Jul 17 13:27 ../
drwxrwxrwx 1 vagrant vagrant   4096 Jun 26 13:40 app/
-rwxrwxrwx 1 vagrant vagrant   1646 Jun 26 13:40 artisan*
drwxrwxrwx 1 vagrant vagrant      0 Jun 26 13:40 bootstrap/
-rwxrwxrwx 1 vagrant vagrant   1309 Jun 26 13:43 composer.json*
-rwxrwxrwx 1 vagrant vagrant 114898 Jun 26 13:44 composer.lock*
drwxrwxrwx 1 vagrant vagrant   4096 Jun 26 13:40 config/
drwxrwxrwx 1 vagrant vagrant   4096 Jun 26 13:40 database/
-rwxrwxrwx 1 vagrant vagrant    423 Jun 26 13:40 .env.example*
-rwxrwxrwx 1 vagrant vagrant     61 Jun 26 13:40 .gitattributes*
-rwxrwxrwx 1 vagrant vagrant     73 Jun 26 13:40 .gitignore*
-rwxrwxrwx 1 vagrant vagrant    503 Jun 26 13:40 gulpfile.js*
-rwxrwxrwx 1 vagrant vagrant    332 Jun 26 22:04 Homestead.yaml*
drwxrwxrwx 1 vagrant vagrant   4096 Jun 26 13:23 .idea/
-rwxrwxrwx 1 vagrant vagrant    212 Jun 26 13:40 package.json*
-rwxrwxrwx 1 vagrant vagrant   1026 Jun 26 13:40 phpunit.xml*
drwxrwxrwx 1 vagrant vagrant   4096 Jun 26 13:40 public/
-rwxrwxrwx 1 vagrant vagrant   1918 Jun 26 13:40 readme.md*
drwxrwxrwx 1 vagrant vagrant      0 Jun 26 13:40 resources/
-rwxrwxrwx 1 vagrant vagrant    567 Jun 26 13:40 server.php*
drwxrwxrwx 1 vagrant vagrant      0 Jun 26 13:40 storage/
drwxrwxrwx 1 vagrant vagrant      0 Jun 26 13:40 tests/
drwxrwxrwx 1 vagrant vagrant      0 Jun 26 21:56 .vagrant/
-rwxrwxrwx 1 vagrant vagrant    900 Jun 26 13:51 Vagrantfile*
drwxrwxrwx 1 vagrant vagrant   4096 Jun 26 13:46 vendor/</code></pre></li>
</ul>
<p>Before we move on, let's follow the remaining <a href="https://laravel.com/docs/5.2">installation instructions in the laravel docs</a>, that is:</p>
<ul>
<li>Create a <code>.env</code> file via <code>cp .env.example .env</code>
<pre><code>vagrant@laravelexample:~/laravelexample$ cp .env.example .env</code></pre></li>
<li>Generate an application key via <code>php artisan key:generate</code>
<pre><code>vagrant@laravelexample:~/laravelexample$ php artisan key:generate
Application key [base64:OhVwfzcFp40LaboJyCQAGS1briBwhYDupgvWJD/YYFE=] set successfully.</code></pre></li>
</ul>
<p>If we did everything right, we should now be able to open a browser and point it to <a href="http://laravelexample.app">http://laravelexample.app</a> and see the
Laravel welcome screen:
<a href="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/laravel/laravel-welcome-screen.PNG"><img src="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/laravel/laravel-welcome-screen.PNG" alt="Laravel welcome screen" /></a></p>
<p>Let's take a step back and think about what we did and what it means:
So we basically set up a new Laravel installation (code-wise) and configured a vagrant homestead box via Laravel Homestead.
And all we need to do to get started, is to navigate into the directory of our app and run <code>vagrant up</code>. Seems not too shabby.
But what if we could make this even more comfortable?</p>
<h3><a id="convenience-commands"></a>Convenience commands</h3>
<p>Since we're using git bash, we can make use of <a href="https://wiki.ubuntuusers.de/alias/">command aliases</a>. This is pretty straight forward:</p>
<ul>
<li>Open up a new bash on your host machine</li>
<li>Type <code>cd ~</code> to navigate to your home directory</li>
<li>Type <code>vi .bashrc</code> to open up the vi editor with your <a href="https://wiki.ubuntuusers.de/Bash/bashrc/"><code>.bashrc</code></a> file (that is basically a configuration file for bash)</li>
<li>Add an alias like this:
<pre><code>alias aliasname='command'</code></pre>
<p>which makes <code>aliasname</code> available to bash and will execute <code>command</code>.</p></li>
<li>After you are finished modifying the file, hit the <code>ESC</code> key and type <code>:wq</code> to save and close vi. Of course, you can also use another editor ;) If you have any problems,
<a href="http://superuser.com/a/602896">this post</a> might help</li>
<li>Now you need to either close and open your current bash session or type <code>. ~/.bashrc</code> (which is the same as <code>source ~/.bashrc</code>) to reload the changes</li>
</ul>
<p>I usually define the following aliases for a new project:</p>
<pre><code>alias ledir='cd "C:\\Users\\Pascal\\PhpstormProjects\\LaravelExample"'
alias leup='ledir &amp;&amp; vagrant up'
alias ledown='ledir &amp;&amp; vagrant halt'
alias lessh='ledir &amp;&amp; vagrant ssh'
alias lein='leup &amp;&amp; lessh'</code></pre>
<p>where the <code>le</code>-prefix is just an abbreviation for &quot;LaravelExample&quot; and <code>"C:\\Users\\Pascal\\PhpstormProjects\\LaravelExample"</code> is the directory of the
LaravelExample app on my host machine. So now, all I need to do when I start to work on that project is:</p>
<ul>
<li>open a new bash &quot;anywhere&quot;</li>
<li>type <code>lein</code>
and that will start vagrant for the &quot;LaravelExample&quot; project and ssh into it :)</li>
</ul>
<h2><a id="configure-php-storm"></a>Configure PhpStorm</h2>
<p>Now that we have successfully set up vagrant, it's time to configrue PhpStorm to use the virtual machine. I've explained all the necessary
steps to do that in the second part of this series
(<a href="http://www.pascallandau.com/blog/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/#configuring-phpstorm-to-use-the-vagrant-box">Setting up PhpStorm with Vagrant and Laravel Homestead</a>)
so I'll keep this rather short.</p>
<ol>
<li>Make sure your vagrant box is running</li>
<li>Open the PhpStorm Settings, search for &quot;Deyployment&quot; and choose &quot; &quot;Deployment&quot; under &quot;Build, Execution, Deployment&quot;
from the resulting list. Now click on the green &quot;+&quot; at the top left, enter &quot;Vagrant (LaravelExamle)&quot;
as name and choose &quot;SFTP&quot; as type. </li>
<li>In the &quot;Connection&quot; tab, enter the following information:
<ul>
<li>SFTP host: laravelexample.app</li>
<li>Port: 22</li>
<li>User name: vagrant</li>
<li>Auth type: Password</li>
<li>Password: vagrant</li>
<li>check the &quot;Save password&quot; checkbox
<a href="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpstorm-deployment-configuration-connection.PNG"><img src="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpstorm-deployment-configuration-connection.PNG" alt="PhpStorm Deployment Configuration Connection settings" /></a>
Please note, that we are connecting directly to the vagrant box using its hostname and port 22 (<code>laravelexample.app</code> is the host
file entry, set we set up earlier.) This is different from the example in the previous
article (where we used 127.0.0.1 and the tunneled port 2222) but allows us to easily run multiple vagrant instances
simultaneously and identify them via host name.</li>
</ul></li>
<li>Next, open the &quot;Mappings&quot; tab and enter the following information:
<ul>
<li>Local path: [path to your local PhpStorm project - this should already be set] </li>
<li>Deployment path on server 'Vagrant (LaravelExample)': /home/vagrant/laravelexample
<a href="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpstorm-deployment-configuration-mappings.PNG"><img src="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpstorm-deployment-configuration-mappings.PNG" alt="PhpStorm Deployment Configuration Mappings settings" /></a>
This corresponds to the <code>folders:</code> setup that we defined in the Homestead.yml file earlier.
Hit &quot;OK&quot; to apply the changes</li>
</ul></li>
<li>Open the PhpStorm Settings again, enter the search box at the top left, type &quot;PHP&quot; and choose the entry named &quot;PHP&quot; from the resulting list.
Set the language level to PHP 7 to get the correct syntax highlighting and click on the &quot;...&quot; to open the &quot;Interpreter&quot; dialog.
Click on the &quot;+&quot; in the top left corner and choose &quot;Remote...&quot;. In the upcoming dialog choose &quot;Deployment Configuration&quot; and select
the 'Vagrant (LaravelExample)' entry.
<a href="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpstorm-interpreter-settings.PNG"><img src="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpstorm-interpreter-settings.PNG" alt="PhpStorm Interpreter settings" /></a></li>
<li>Hit &quot;OK&quot; to confirm your selection. PhpStorm will now try to connect via SSH on port 22 to <code>laravelexample.app</code>.
Since this is the first time you will be doing that, you should be prompted to confirm the RSA key fingerprint.
<a href="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpstorm-remote-host-verification.PNG"><img src="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpstorm-remote-host-verification.PNG" alt="PhpStorm remote host RSA key fingerprint verification" /></a>
In short,
you need to do this once in the beginning to <em>manually</em> verify that you are really connecting to correct server. Since
we are only using this for local development, it doesn't really matter and you could just confirm the dialog. But that
wouldn't be fun, would it? So, to confirm that the shown RSA key fingerprint matches the one of our vagrant box, log into
the box and type <code>ssh-keygen -lf /etc/ssh/ssh_host_rsa_key.pub</code>. That should display the same key as shown in the popup:
<pre><code>vagrant@laravelexample:~/.ssh$ ssh-keygen -lf /etc/ssh/ssh_host_rsa_key.pub
2048 6d:4f:59:b6:9a:82:4d:20:e9:4d:b3:a0:e7:68:a6:9f  root@vagrant (RSA)</code></pre>
<p>For more information, please refer to the article <a href="http://www.phcomp.co.uk/Tutorials/Unix-And-Linux/ssh-check-server-fingerprint.html">Checking ssh public key fingerprints</a>.</p></li>
<li>Rename the newly created interpreter to &quot;Vagrant (LaravelExample) PHP 7&quot; and confirm the &quot;Interpreters&quot; as well as all remaining
dialogs with &quot;OK&quot;.
<a href="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpstorm-vagrant-interpreter.PNG"><img src="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpstorm-vagrant-interpreter.PNG" alt="PhpStorm Vagrant interpreter" /></a></li>
</ol>
<p>Great, PhpStorm should now be able to use our homestead vagrant box. To verify that everything is working correctly, you could run the file
<code>artisan</code> in the base folder of your laravel installation. Simply right-click on the file and choose &quot;Run&quot;. This should generate something
like this:</p>
<pre><code>sftp://vagrant@laravelexample.app:22/usr/bin/php /home/vagrant/laravelexample/artisan
Laravel Framework version 5.2.39

Usage:
  command [options] [arguments]

Options:
  -h, --help            Display this help message
  -q, --quiet           Do not output any message
  -V, --version         Display this application version
      --ansi            Force ANSI output
      --no-ansi         Disable ANSI output
...</code></pre>
<p>The first line <code>sftp://vagrant@laravelexample.app:22/usr/bin/php /home/vagrant/laravelexample/artisan</code> confirms, that PhpStorm actually
uses the remote interpreter and the remote path to run.</p>
<h3><a id="setup-phpunit"></a>Setup PHPUnit</h3>
<p>Setting up PHPUnit is pretty straight forward.</p>
<ul>
<li>Open the settings via <code>File &gt; Settings...</code>, search vor &quot;PHPUnit&quot;, choose the entry under &quot;Language &amp; Frameworks&quot; &gt; &quot;PHP&quot;
and click on the green &quot;+&quot; in the top left and choose &quot;By Remote Interpreter...&quot;
<a href="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpunit-remote-interpreter.png"><img src="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpunit-remote-interpreter.png" alt="PHPUnit remote interpreter" /></a></li>
<li>Choose the &quot;Vagrant (LaravelExample)&quot; entry
<a href="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpunit-remote-interpreter-vagrant.png"><img src="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpunit-remote-interpreter-vagrant.png" alt="PHPUnit vagrant remote interpreter" /></a></li>
<li>Select &quot;Use custom autoloader&quot; and fill in the required paths (as they appear on the remote server):
<ul>
<li>Path to script: <code>/home/vagrant/laravelexample/vendor/autoload.php</code> (the path to the autoloader as generated by Composer)</li>
<li>Default configuration file: <code>/home/vagrant/laravelexample/phpunit.xml</code>
<a href="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpunit-path-settings.png"><img src="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpunit-path-settings.png" alt="PHPUnit path settings" /></a></li>
</ul></li>
<li>Confirm with &quot;OK&quot;</li>
</ul>
<p>To verify that everything works as expected, right-click on the file &quot;test/ExampleTest.php&quot; in PhpStorm and choose &quot;Run&quot; &gt; &quot;ExampleTest&quot;.
<a href="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/run-phpunit-example-test.png"><img src="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/run-phpunit-example-test.png" alt="Run PHPUnit ExampleTest" /></a>
The test should succeed with the following output:
<a href="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpunit-successful-test.PNG"><img src="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/phpunit-successful-test.PNG" alt="Successful PHPUnit test" /></a></p>
<p>Great, now we can run unit tests from within PhpStorm :) This becomes incredibly useful when tests fail and you need to quickly debug them in
order to find the error. At a later point, you might want to have a look at the <code>&lt;php&gt;</code> section of the <code>phpunit.xml</code> configuration, as that enables
you to override the default settings defined by the &quot;.env&quot; file, which is pretty useful when you want to have specific settings when running unit tests.
I like to setup a dedicated testing database, for instance. To make Laravel use this out of the box, all I need to do is set the corresponding ENV
variable in the phpunit.xml file. Please refer to <a href="http://stackoverflow.com/a/34838187/413531">my comment on Stackoverflow</a>
for some more insight in how .env files work in Laravel.</p>
<h3><a id="laravel-specific-settings-in-phpstorm"></a>Laravel-specific settings in PhpStorm</h3>
<p>I strongly believe in optimizing the everyday workflow as much as possible. When working with Laravel in PhpStorm, there are two things
that really made my life easier:</p>
<ul>
<li>
<p>The Laravel Plugin (Open the settings, search for &quot;plugin&quot; and then for &quot;Laravel Plugin&quot;).
I personally really like the code completion when using the <code>config()</code> helper. You can find a full description
at the <a href="https://plugins.jetbrains.com/plugin/7532?pr=">plugin page</a> and in <a href="https://blog.jetbrains.com/phpstorm/2015/01/laravel-development-using-phpstorm/">this blog article</a>.</p>
<p>One thing to note: The plugin has to be activated <strong>per project</strong>. That means it's not enough to install it, but you
have to enable it in the settings for the current PhpStorm project. Open the settings, search for &quot;Laravel&quot; and choose
the &quot;Laravel Plugin&quot; entry under &quot;Other settings. Now activate the checkbox that says &quot;Enable plugin for this project&quot;
and confirm with &quot;OK&quot;.
<a href="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/enable-laravel-plugin.PNG"><img src="/img/laravel-with-phpunit-on-vagrant-in-phpstorm/phpstorm/enable-laravel-plugin.PNG" alt="Enable the Laravel plugin" /></a></p>
</li>
<li>The <a href="https://github.com/barryvdh/laravel-ide-helper">Laravel IDE helper project by barryvdh</a>.
To install it, log into your vagrant machine and navigate to you project folder. Now run
<code>composer require barryvdh/laravel-ide-helper</code> to download the dependency in your vendor folder (and add it to your composer.json)
and add <code>Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class</code> to your <code>config/app.php</code> file in the <code>'providers' =&gt; [...]</code> section.
Now generate the helper files for PhpStorm by running two artisan commands:
<ul>
<li><code>php artisan ide-helper:generate</code> 
<pre><code>vagrant@laravelexample:~/laravelexample$ php artisan ide-helper:generate
A new helper file was written to _ide_helper.php</code></pre>
<p>This enables code-completion for <a href="https://laravel.com/docs/5.2/facades">Facades</a>, for example. Another nice feature is the
<code>Eloquent</code> meta class that you can use as &quot;meta mixin&quot; for your models. See <a href="https://github.com/barryvdh/laravel-ide-helper/issues/74#issuecomment-143770037">my comment at issue 74</a> for a complete example.</p></li>
<li><code>php artisan ide-helper:meta</code>  
<pre><code>vagrant@laravelexample:~/laravelexample$ php artisan ide-helper:meta
A new meta file was written to .phpstorm.meta.php</code></pre>
<p>This enables the automatic recognition of entities, that are resolved from the <a href="https://laravel.com/docs/5.2/container">dependency injection container</a>.</p></li>
</ul></li>
</ul>
<h2><a id="housekeeping"></a>Housekeeping</h2>
<p>Our project is setup, it runs on vagrant and we can even run PHPUnit tests. Regarding the local development, we are pretty much all set.
But chances are, you're gonna commit your code to some remote repository. (If not, you really should!). To make this as smooth as possible,
we should do some cleanup before.</p>
<h3><a id="update-the-gitignore-file"></a>Update the .gitignore file</h3>
<p>We added quite some files to the bare Laravel installation which might not be suitable for a remote repository. To prevent them from being
committed, we need to update the <code>.gitignore</code> file in the base directory of the application. The file <em>should</em> currently look like this:</p>
<pre><code>/vendor
/node_modules
/public/storage
Homestead.yaml
Homestead.json
.env</code></pre>
<p>The <code>Homestead.yaml</code> and <code>Homestead.json</code> entries have been added automatically when we ran <code>vendor/bin/homestead make</code>. That's nice, but we
should also add a <code>.vagrant/</code> entry, because this folder will be created automatically, once we run <code>vagrant up</code>. Further, the ide-helper
Plugin created two files that are only relevant if you're using an IDE so they shouldn't necessarily be in the repo. So let's add entries for
<code>.phpstorm.meta.php</code> and <code>_ide_helper*</code> (I'm using the wildcard here, because there might be more files later with that prefix, e.g. <code>_ide_helper_models.php</code>).
Plus, PhpStorm also generates some meta files itself that really shouldn't be in the repository, so let's add <code>.idea/</code> as well.</p>
<p>The <code>.gitignore</code> file should now look like this:</p>
<pre><code>/vendor
/node_modules
/public/storage
Homestead.yaml
Homestead.json
.env
.vagrant/
.phpstorm.meta.php
_ide_helper*
.idea/</code></pre>
<h3><a id="update-the-readme-md-file"></a>Update the readme.md file</h3>
<p>The <code>readme.md</code> file in the base directory of your application currently contains the default readme of the Laravel framework. So let's delete
the old content and put some general information in there on how other developers can setup their development environment and get started quickly.
Here's an example that you can use as blueprint:</p>
<pre><code># LaravelExample
## Setup
- download/clone the git repository from
  - `git clone https://github.com/paslandau/laravelexample.git`
- navigate into the project folder
  - `cd laravelexample`
- make sure not to work directly on the master branch  
  - `git checkout -b my_local_branch`
- to prepare the vagrant configuration, run
  - `vendor/bin/homestead make` or `vendor/bin/homestead.bat make` on Windows
- adjust the `hosts` file and the newly created `Homestead.yaml` in the root of the repo according to your needs. Usually that includes:
  - adjust `ip`
    - make sure the `ip` is not already used in your local network
  - add an entry to your host file
    - `[IP] laravelexample.app` (e.g. `192.168.33.111 laravelexample.app`)
    - location on Unix: `/etc/hosts`
    - location on Windows: `C:\Windows\System32\drivers\etc`
- adjust `folders` and `sites` mapping (optional; it should be set up correctly by default if you followed the steps above).
  Watch out for the following:
  - the `folders: - map: "[PATH]"` should point to the absolute path to the `cube` repository on your **local** machine
  - the `folders: to: "[PATH]"` denotes the path on your **vagrant** machine that is mapped to the above mentioned path on your local machine,
    so that you can access your local files within the vagrant box.
  - the `sites: - map: "[HOSTNAME]"` denotes the hostname that the nginx is looking for to serve content on
    - you _should_ adjust that to the hostname chosen for your hostfile (e.g. `laravelexample.app`) although it not necessary since nginx will even respond to another hostname
  - the `sites: - to: "[PATH]"` denotes the absolute path withing the vagrant box that the above mentioned hostname uses as `root` path for content.
    This should be the path to the `public` folder of this repository
- start the vagrant box with `vagrant up`, ssh into it with `vagrant ssh`, switch to the project folder (by default, this should be `cd /home/vagrant/laravelexample/`) and install the 
  project's dependencies
  - `composer install`
- setup laravel by generating an application key and setting up the .env file:
  - php artisan key:generate
  - `cp .env.example .env`
- generate the meta data files for better code completion
  - `php artisan ide-helper:meta`
  - `php artisan ide-helper:generate`
  - `php artisan ide-helper:model`

You should now be able to open http://laravelexample.app/ in your browser and see the Laravel welcome page :)</code></pre>
<p>Cool, now we are basically done and could <a href="https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line/">upload our project e.g. on Github</a>.
I actually <a href="https://github.com/paslandau/laravelexample">went ahead and did exactly that with the &quot;LaravelExample&quot; project</a> I used in this tutorial.</p>]]></description>
                                                    <pubDate>Sun, 07 Aug 2016 16:00:00 +0000</pubDate>
                                <link>https://www.pascallandau.com/blog/laravel-with-phpunit-on-vagrant-in-phpstorm/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=development-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/blog/laravel-with-phpunit-on-vagrant-in-phpstorm/</guid>
            </item>
                    <item>
                <title>How to setup PhpStorm with Vagrant and Laravel Homestead [Tutorial  Part 2]</title>
                <description><![CDATA[<p>In this second part we're going to cover the setup of Vagrant as local development environment. In the end we'll learn how to</p>
<ul>
<li>install and configure VirtualBox, Vagrant and Laravel Homestead</li>
<li>setup Vagrant in PhpStorm for (remote) PHP execution and debugging</li>
</ul>
<p>And just as a reminder, the first part is over at
<a href="http://www.pascallandau.com/blog/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/">Setting up PHP7 with Xdebug 2.4 for PhpStorm</a>,
the third at <a href="http://www.pascallandau.com/blog/laravel-with-phpunit-on-vagrant-in-phpstorm/">Setting up Laravel with PHPUnit on Vagrant in PhpStorm</a></p>
<h2>Table of contents</h2>
<ul>
<li><a href="#setting-up-the-software">Setting up the software</a><ul>
 <li><a href="#git-and-git-bash">Git and Git Bash</a></li>
 <li><a href="#oracle-virtualbox">Oracle VirtualBox</a></li>
 <li><a href="#vagrant">Vagrant</a></li>
 <li><a href="#homestead">Homestead</a></li>
</ul></li>
<li><a href="#configuring-phpstorm-to-use-the-vagrant-box">Configuring PhpStorm to use the vagrant box</a></li>
</ul>
<h2><a id="setting-up-the-software"></a>Setting up the software</h2>
<h3><a id="git-and-git-bash"></a>Git and Git Bash</h3>
<p>First of all, we're going to install a decent terminal on windows, because we will have to do some stuff on the command line and once you're
working with vagrant you'll have to do this via SSH and it's just convenient to have a similar tool set available on Windows as on Unix (e.g. history search).</p>
<ul>
<li>Download the current Git version from the <a href="https://git-scm.com/download/win">Git download page for Windows</a>. Download should start automatically
when you open the link.</li>
<li>Open the file to start the installation</li>
<li>When you hit the &quot;Select Components&quot; step, make sure the checkbox next to &quot;Git Bash here&quot; is checked. That option enables a new entry in the
context menu when right-clicking in a windows folder to open a Git Bash at this directory.
<a href="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/git-bash/git-select-components.PNG"><img src="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/git-bash/git-select-components.PNG" alt="Git Bash select components" /></a></li>
<li>During the installation we'll have the convenient opportunity that the installation wizard adjusts our <code>PATH</code> variable automatically,
so that we can access the <code>git</code> commands globally. I prefer to go with the middle option &quot;Use Git from Windows Command Prompt&quot;.
<a href="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/git-bash/git-adjust-path.PNG"><img src="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/git-bash/git-adjust-path.PNG" alt="Git Bash adjust PATH" /></a></li>
<li>When being asked for the preferred way to handle line endings, I would advise to go for the middle option again. &quot;Checkout as-is, commit
Unix-style line endings&quot;. Since we're using PhpStorm we don't need to have CRLF as line ending - just LF does fine and is cross-plattform
compatible. Just be advised that only LF line endings are not not shown as new lines when using the &quot;normal&quot; windows text editor.
<a href="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/git-bash/git-configure-line-endings.PNG"><img src="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/git-bash/git-configure-line-endings.PNG" alt="Git Bash configure line endings" /></a></li>
<li>When being asked for the terminal emulator make sure to choose &quot;Use MinTTY (the default terminal of MYSY2)&quot;.
<a href="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/git-bash/git-terminal-emulator.PNG"><img src="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/git-bash/git-terminal-emulator.PNG" alt="Git Bash terminal emulator" /></a></li>
<li>Confirm the remaining steps with &quot;Next&quot; and finish the installation</li>
<li>Open a new Git Bash shell and do the most basic setup step:
<pre><code>$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com</code></pre>
<p><a href="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/git-bash/git-initial-setup.PNG"><img src="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/git-bash/git-initial-setup.PNG" alt="Git initial setup" /></a></p></li>
</ul>
<p>Cool, we now have a much prettier (and more powerful) shell to work with. I won't get any deeper into Git itself as
there are <a href="https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control">much better introductions/tutorials on Git</a>
out there than I could possibly write :) </p>
<h3><a id="oracle-virtualbox"></a>Oracle VirtualBox</h3>
<p>VirtualBox is the software that runs the virtual machine that we can use to run our code on. Using a virtual machine
makes it possible to use the environment/infrastructure of a production system during local development and thus
minimizes the error potential when finally going to production. When you're just starting out, those benefits probably
aren't immediately clear to you, but once you begin to design whole systems with multiple components like databases,
caches, web servers etc., this approach becomes incredibly helpful. </p>
<ul>
<li>Download the latest version of VirtualBox from the <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox download page</a>.
As of writing this tutorial, the current version is &quot;VirtualBox 5.0.20 for Windows hosts&quot;.</li>
<li>Run the downloaded file and follow the installation instructions. There's actually nothing to explain ;)</li>
</ul>
<h3><a id="vagrant"></a>Vagrant</h3>
<p>Technically, we wouldn't even need vagrant for our development as the &quot;heavy lifting&quot; is done by VirtualBox and once
we've got our virtual machine up and running, we can start running code on it. But getting the setup right is actually not an
easy task and requires manual involvement. We don't want that. We want a simple, reproducible, formalized way of defining
our virtual machine. Vagrant does exactly that: It gives us a simple configuration language that fulfills those requirements
and makes it even sharable with other team members to get them started quickly.</p>
<ul>
<li>
<p>Download the 1.7.4 version of Vagrant from the <a href="https://releases.hashicorp.com/vagrant/1.7.4/">Vagrant download archive page</a>
(the <a href="https://releases.hashicorp.com/vagrant/1.7.4/vagrant_1.7.4.msi">vagrant_1.7.4.msi file</a> is the installer for Windows)
As of writing this tutorial, the current version is 1.8.5 but that didn't work for me. (More concrete, I got the error</p>
<blockquote>
<p>The box 'laravel/homestead' could not be found</p>
</blockquote>
<p>when trying to set up homestead.)</p>
</li>
<li>Run the downloaded file and follow the installation instructions. Again, nothing fancy here but you'll probably
need to restart your system after the installation.</li>
</ul>
<p>Vagrant will automatically be added to the <code>PATH</code> variable, so it can be called globally. To confirm that the
installation was successful, run &quot;vagrant -v&quot;, which should yield a similar output to this:</p>
<pre><code>$ vagrant -v
Vagrant 1.7.4</code></pre>
<h3><a id="homestead"></a>Homestead</h3>
<p>Homestead is a vagrant base box that is maintained by the creator of Laravel, Taylor Otwell. There's actually a chapter
on <a href="https://laravel.com/docs/5.2/homestead">Homestead in the Laravel documentation</a> that does a pretty good job explaining
how to set homestead up, so I'll keep this section rather short.</p>
<p>Since we've already installed VirtualBox and Vagrant, all we need to do is running <code>vagrant box add laravel/homestead --box-version 0.4.4</code>.
That command will download <a href="https://atlas.hashicorp.com/laravel/boxes/homestead/versions/0.4.4">the homestead box version v0.4.4 from the vagrant catalogue</a>
to (by default) <code>~/.vagrant.d/boxes</code> or in Windows terms <code>C:\Users\&lt;Username&gt;\.vagrant.d\boxes</code>. You can change this location
by setting the <code>VAGRANT_HOME</code> path variable as explained <a href="http://stackoverflow.com/a/10226134/413531">here</a>.</p>
<p><strong>Caution:</strong> We specified the concrete version because a simple <code>vagrant box add laravel/homestead</code> would download the
<em>latest</em> version of homestead which is (at the time of this writing) v0.5.0 and contains the newest Ubuntu release 16.04.
If you want to go with that version, make sure to also download and install the <em>latest</em> vagrant version (currently 1.8.5).
It is possible ot have multiple versions of a vagrant box on your host machine, but it requires some additional
setup to choose the right box. Please refer to this <a href="http://laravel.io/forum/02-03-2016-install-specific-laravel-homestead-version-and-502-bad-gateway-nginx-solved?page=1#reply-29937">answer</a>
for further information.</p>
<p><em>Note:</em> You might encounter the following error message:</p>
<blockquote>
<p>$ vagrant box add laravel/homestead
==&gt; box: Loading metadata for box 'laravel/homestead'
box: URL: <a href="https://atlas.hashicorp.com/laravel/homestead">https://atlas.hashicorp.com/laravel/homestead</a>
Vagrant is attempting to interface with the UI in a way that requires
a TTY. Most actions in Vagrant that require a TTY have configuration
switches to disable this requirement. Please do that or run Vagrant
with TTY.</p>
</blockquote>
<p>Explanation: The homestead box can work with either VMware or VirtualBox and Vagrant leaves this decision to you. The error
indicates that Vagrant doesn't understand which terminal (TTY) you are using and thus cannot display the options for you to
choose from.</p>
<p>Solution (as found <a href="http://stackoverflow.com/a/32398981">here</a>): Define the new environment variable
<code>VAGRANT_DETECTED_OS=cygwin</code>. </p>
<p><a href="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/homestead/vagrant-detected-os-environment-variable.PNG"><img src="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/homestead/vagrant-detected-os-environment-variable.PNG" alt="VAGRANT_DETECTED_OS=cygwin" /></a></p>
<p>Open up a new shell and run <code>vagrant box add laravel/homestead</code> again. The output should look like this:</p>
<pre><code>$ vagrant box add laravel/homestead
==&gt; box: Loading metadata for box 'laravel/homestead'
    box: URL: https://atlas.hashicorp.com/laravel/homestead
This box can work with multiple providers! The providers that it
can work with are listed below. Please review the list and choose
the provider you will be working with.

1) virtualbox
2) vmware_desktop

Enter your choice: </code></pre>
<p>Type <code>1</code> and press <code>Enter</code>. This might take some time but should in the end look like this:</p>
<pre><code>Enter your choice: 1
==&gt; box: Adding box 'laravel/homestead' (v0.4.4) for provider: virtualbox
    box: Downloading: https://atlas.hashicorp.com/laravel/boxes/homestead/versions/0.4.4/providers/virtualbox.box
    box:
==&gt; box: Successfully added box 'laravel/homestead' (v0.4.4) for 'virtualbox'!</code></pre>
<p>Let's make sure everything works as expected by following these steps:</p>
<ul>
<li>create a new directory and <code>cd</code> into it
<pre><code>$ mkdir test &amp;&amp; cd test</code></pre></li>
<li>Run <code>vagrant init laravel/homestead</code> to create an initial <code>Vagrantfile</code> with our new homestead box as base in the <code>test</code> directory
<pre><code>$ vagrant init laravel/homestead
A `Vagrantfile` has been placed in this directory. You are now
ready to `vagrant up` your first virtual environment! Please read
the comments in the Vagrantfile as well as documentation on
`vagrantup.com` for more information on using Vagrant.</code></pre>
<p>The <code>Vagrantfile</code> holds the configuration options for the vagrant box, but we don't need to change anything in there for now
(unless you have a device on your network that is occupying the 192.169.10.10 IP address,
which is the default IP that vagrant will assign to the VM)</p></li>
<li>
<p>Run <code>vagrant up</code> to start the virtual machine</p>
<pre><code>$ vagrant up
Bringing machine 'default' up with 'virtualbox' provider...
==&gt; default: Importing base box 'laravel/homestead'...
==&gt; default: Matching MAC address for NAT networking...
==&gt; default: Checking if box 'laravel/homestead' is up to date...
==&gt; default: Setting the name of the VM: test_default_1466931613297_29944
==&gt; default: Clearing any previously set network interfaces...
==&gt; default: Preparing network interfaces based on configuration...
  default: Adapter 1: nat
  default: Adapter 2: hostonly
==&gt; default: Forwarding ports...
  default: 22 =&gt; 2222 (adapter 1)
==&gt; default: Booting VM...
==&gt; default: Waiting for machine to boot. This may take a few minutes...
  default: SSH address: 127.0.0.1:2222
  default: SSH username: vagrant
  default: SSH auth method: private key
  default: Warning: Remote connection disconnect. Retrying...</code></pre>
<p>Caution: The boot process might get stuck at </p>
<pre><code>default: Warning: Remote connection disconnect. Retrying..</code></pre>
<p>and finally become</p>
<pre><code>Timed out while waiting for the machine to boot. This means that
Vagrant was unable to communicate with the guest machine within
the configured ("config.vm.boot_timeout" value) time period.

If you look above, you should be able to see the error(s) that
Vagrant had when attempting to connect to the machine. These errors
are usually good hints as to what may be wrong.

If you're using a custom box, make sure that networking is properly
working and you're able to connect to the machine. It is a common
problem that networking isn't setup properly in these boxes.
Verify that authentication configurations are also setup properly,
as well.

If the box appears to be booting properly, you may want to increase
the timeout ("config.vm.boot_timeout") value.</code></pre>
<p>Trying to login from the VirtualBox GUI reveals:</p>
<blockquote>
<p>VT-x/AMD-V hardware acceleration is not available on your system</p>
</blockquote>
<p><a href="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/homestead/vt-x-hardware-virtualization-error.PNG"><img src="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/homestead/vt-x-hardware-virtualization-error.PNG" alt="VT-x hardware virtualization error" /></a>
There's actually even a note in the <a href="https://laravel.com/docs/5.2/homestead#introduction">docs</a>:</p>
<blockquote>
<p>Note: If you are using Windows, you may need to enable hardware virtualization (VT-x). It can usually be enabled via your BIOS. If you are using Hyper-V on a UEFI system you may additionally need to disable Hyper-V in order to access VT-x.</p>
</blockquote>
<p>Please refer to the article <a href="http://www.howtogeek.com/213795/how-to-enable-intel-vt-x-in-your-computers-bios-or-uefi-firmware/">How to Enable Intel VT-x in Your Computerâ€™s BIOS or UEFI Firmware</a>
which does a great job explaining exactly how to enable the hardware virtualization. <em>Note</em>: the most easy way for me to get to the BIOS
was simply to hit the WIN key and search for &quot;Advanced Startup&quot; and then clicking on the &quot;Restart now&quot; button. In the upcoming screens I chose
<code>Troubleshoot &gt; Advanced options &gt; UEFI Firmware Settings</code>. If you still have problems to get into the BIOS, read on <a href="http://www.howtogeek.com/126016/three-ways-to-access-the-windows-8-boot-options-menu/">here</a></p>
</li>
</ul>
<p><em>Note: So far, I used my own virtual machine for this tutorial so I could install everything &quot;from scratch&quot; to get the screenshots and a run into the
<em>actual</em> problems that can occur. Unfortunately, I will now have to switch to my &quot;real&quot; laptop because currently it is not possible to run a 64-bit vagrant box
within a virtual machine (yeah, talk about virtualiception ;)). Reason: I can't enable VT-x/AMD-x in the virtual machine. More in depth info on that problem
can be found <a href="http://superuser.com/a/760318">here</a> and <a href="https://www.virtualbox.org/ticket/4032">here</a></em>.</p>
<ul>
<li>Run <code>vagrant up</code> again to start the virtual machine
<pre><code>$ vagrant up
Bringing machine 'default' up with 'virtualbox' provider...
==&gt; default: Importing base box 'laravel/homestead'...
==&gt; default: Matching MAC address for NAT networking...
==&gt; default: Checking if box 'laravel/homestead' is up to date...
==&gt; default: Setting the name of the VM: test_default_1466937242196_51857
==&gt; default: Clearing any previously set network interfaces...
==&gt; default: Preparing network interfaces based on configuration...
  default: Adapter 1: nat
==&gt; default: Forwarding ports...
  default: 22 =&gt; 2222 (adapter 1)
==&gt; default: Booting VM...
==&gt; default: Waiting for machine to boot. This may take a few minutes...
  default: SSH address: 127.0.0.1:2222
  default: SSH username: vagrant
  default: SSH auth method: private key
  default: Warning: Connection timeout. Retrying...
  default:
  default: Vagrant insecure key detected. Vagrant will automatically replace
  default: this with a newly generated keypair for better security.
  default:
  default: Inserting generated public key within guest...
  default: Removing insecure key from the guest if it's present...
  default: Key inserted! Disconnecting and reconnecting using new SSH key...
==&gt; default: Machine booted and ready!
==&gt; default: Checking for guest additions in VM...
==&gt; default: Mounting shared folders...
  default: /vagrant =&gt; C:/Users/Pascal/Desktop/test</code></pre></li>
<li>SSH into the machine
<pre><code>$ vagrant ssh</code></pre></li>
</ul>
<p>You should now see something like this:</p>
<pre><code>Welcome to Ubuntu 14.04.4 LTS (GNU/Linux 3.19.0-25-generic x86_64)

 * Documentation:  https://help.ubuntu.com/
vagrant@homestead:~$</code></pre>
<p>Congratulations, you've successfully overcome every obstacle and are now the proud owner
of a working vagrant homestead setup.</p>
<h2><a id="configuring-phpstorm-to-use-the-vagrant-box"></a>Configuring PhpStorm to use the vagrant box</h2>
<p>Setting up PhpStorm to work with your newly created vagrant box can be a little tricky, as the process is not really
that straight forward. But in the end it's just a matter of &quot;knowing where to click&quot; (and having a little bit of background
info on what's happening behind the scenes is also helpful ;)). And it will <em>not</em> work as expected, but I think it's still
helpful to explain why that is the case and how to work around it.</p>
<p>PS: There is also a <a href="https://confluence.jetbrains.com/display/PhpStorm/Working+with+Advanced+Vagrant+features+in+PhpStorm">Working with Advanced Vagrant features in PhpStorm</a>
tutorial. Although their approach is a little different, so take it as a nice to know :)</p>
<ul>
<li>open up PhpStorm and open the settings via <code>File &gt; Settings...</code></li>
<li>enter the search box at the top left, type &quot;PHP&quot; and choose the entry named &quot;PHP&quot; under &quot;Laguages &amp; Frameworks&quot; from the resulting list
<a href="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/phpstorm/select-php-interpreter.PNG"><img src="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/phpstorm/select-php-interpreter.PNG" alt="Select a new PHP interpreter in PhpStorm" /></a></li>
<li>click on the &quot;...&quot; next to &quot;Interpreter&quot;. This opens the interpreter settings for PhpStorm</li>
<li>click on the green &quot;+&quot; on the top left and choose &quot;Remote...&quot; to add a new interpreter. Technically, vagrant is a
&quot;remote&quot; interpreter as we're going to access it via SSH over our local network. </li>
<li>in the pop up window choose &quot;Vagrant&quot; and select the directory that your &quot;Vagrantfile&quot; is in
<a href="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/phpstorm/add-vagrant-remote.PNG"><img src="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/phpstorm/add-vagrant-remote.PNG" alt="Add vagrant as remote interpreter" /></a>
After clicking &quot;OK&quot;, PhpStorm will perform some checks (e.g. connect via SSH to vagrant and look for PHP).</li>
<li>
<p>The &quot;Interpreters&quot; window now contains a new entry with the newly generated vagrant remote interpreter.
<a href="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/phpstorm/vagrant-no-path-mappings.PNG"><img src="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/phpstorm/vagrant-no-path-mappings.PNG" alt="Vagrant interpreter" /></a>
By default, it should be named something like &quot;Remote PHP 7&quot; which I would recommend renaming to &quot;Vagrant PHP 7&quot;.
Also note the warning that says </p>
<blockquote>
<p>No path mapping were found. Please, configure them at Vagrantfile</p>
</blockquote>
<p>Since we didn't touch the <code>Vagrantfile</code>, it's true that we didn't configure any path mapping. That means, we did not tell vagrant which folder of
our host machine should be made available to the virtual machine. Why do we need this? Well, we're going to execute the source code that we are editing
within PhpStorm in the <em>host</em> system in the virtual machine (the <em>remote</em> system), so we need to make it available to the <em>remote</em> system. </p>
</li>
<li>Open up your <code>Vagrantfile</code> in the <code>test</code> directory. There's a lot of stuff in there, but it is mostly commented out and just serves as a blueprint
if you need to change the defaults. You can actually delete all of it and replace it with the following content:
<pre><code>Vagrant.configure(2) do |config|
config.vm.box = "laravel/homestead"
config.vm.synced_folder "C:\\Users\\Pascal\\PhpstormProjects\\untitled", "/vagrant_data"
end</code></pre>
<p>where <code>C:\\Users\\Pascal\\PhpstormProjects\\untitled</code> is the path to my PhpStorm project. You can easily get that path if you right-click
on the project folder within PhpStorm and select <code>Copy as path</code> from the context menu. Please make sure to use double <code>\\</code> instead of single <code>\</code> within the path!
This makes the project folder on your host machine available to the virtual machine at the directory <code>/vagrant_data</code></p></li>
<li>To enable the changes, we need to restart the vagrant box via <code>vagrant reload</code>. Run the command on your host machine in the directory that holds the
<code>Vagrantfile</code>. If you are still logged into the virtual machine, press CTRL + D to logout.
<pre><code>$ vagrant reload
==&gt; default: Attempting graceful shutdown of VM...
==&gt; default: Checking if box 'laravel/homestead' is up to date...
==&gt; default: Clearing any previously set forwarded ports...
==&gt; default: Clearing any previously set network interfaces...
==&gt; default: Preparing network interfaces based on configuration...
  default: Adapter 1: nat
==&gt; default: Forwarding ports...
  default: 22 =&gt; 2222 (adapter 1)
==&gt; default: Booting VM...
==&gt; default: Waiting for machine to boot. This may take a few minutes...
  default: SSH address: 127.0.0.1:2222
  default: SSH username: vagrant
  default: SSH auth method: private key
  default: Warning: Connection timeout. Retrying...
==&gt; default: Machine booted and ready!
==&gt; default: Checking for guest additions in VM...
==&gt; default: Mounting shared folders...
  default: /vagrant =&gt; C:/Users/Pascal/Desktop/test
  default: /vagrant_data =&gt; C:/Users/Pascal/PhpstormProjects/untitled
==&gt; default: Machine already provisioned. Run `vagrant provision` or use the `--provision`
==&gt; default: flag to force provisioning. Provisioners marked to run always will still run.</code></pre>
<p>Please note the line <code>default: /vagrant_data =&gt; C:/Users/Pascal/PhpstormProjects/untitled</code> which tells us that the path mapping is in place.
Also, take note of the lines</p>
<pre><code>==&gt; default: Forwarding ports...
    default: 22 =&gt; 2222 (adapter 1)
==&gt; default: Booting VM...
==&gt; default: Waiting for machine to boot. This may take a few minutes...
    default: SSH address: 127.0.0.1:2222</code></pre>
<p>That basically means, that the port 22 on the virtual machine is tunneled to port 2222 on the host machine.
2222 is the vagrant default but we could override this setting in the Vagrantfile.</p></li>
<li>
<p>Ok, let's get back to the &quot;Interpreters&quot; window in PhpStorm. In case you closed it, just repeat the first steps of this section.
But: <strong>The warning still isn't gone!</strong> That is the part that always through me off in the beginning, because I would have expected PhpStorm
to figure the path mappings out automagically. But if we run <code>test.php</code> right now, we get the following result:</p>
<pre><code>vagrant://C:/Users/Pascal/Desktop/test/usr/bin/php C:\Users\Pascal\PhpstormProjects\untitled\test.php
bash: line 0: cd: C:/Users/Pascal/PhpstormProjects/untitled: No such file or directory
Could not open input file: C:UsersPascalPhpstormProjectsuntitledtest.php

Process finished with exit code 1</code></pre>
<p>PhpStorm has no idea where to look within the virtual machine. How can we still get this to work?</p>
</li>
<li>Well, here's how: Enter the search box at the top left, type &quot;Deployment&quot; and choose the entry named &quot;Deployment&quot; from the resulting list.
Now click on the green &quot;+&quot; at the top left, enter &quot;Vagrant&quot; as name and choose &quot;SFTP&quot; as type.
<a href="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/phpstorm/vagrant-deployment-settings.PNG"><img src="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/phpstorm/vagrant-deployment-settings.PNG" alt="Add vagrant via sftp deployment" /></a>
Actually, the name doesn't matter, you can enter what ever you want there ;)</li>
<li>
<p>in the &quot;Connection&quot; tab, enter the following information:</p>
<ul>
<li>SFTP host: 127.0.0.1</li>
<li>Port: 2222</li>
<li>User name: vagrant</li>
<li>Auth type: Password</li>
<li>Password: vagrant</li>
<li>check the &quot;Save password&quot; checkbox</li>
</ul>
<p><a href="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/phpstorm/vagrant-deployment-connection.PNG"><img src="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/phpstorm/vagrant-deployment-connection.PNG" alt="Deployment connection settings for vagrant" /></a>
So what does that mean? Those settings tell PhpStorm to connect via SFTP to our vagrant box by using the port 2222 on our host machine -
which tunnels to port 22 on the virtual machine as mentioned above. To do so, it uses the username &quot;vagrant&quot; and the password &quot;vagrant&quot;
for authentication. Again, those credentials are the default values for vagrant (and will be used &quot;behind the scenes&quot; if you use <code>vagrant ssh</code>
to ssh into a vagrant machine).</p>
</li>
<li>
<p>Next, open the &quot;Mappings&quot; tab and enter the following information:</p>
<ul>
<li>Local path: [path to your local PhpStorm project - this should already be set]</li>
<li>Deployment path on server 'Vagrant': /vagrant_data </li>
</ul>
<p><a href="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/phpstorm/vagrant-path-mappings.PNG"><img src="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/phpstorm/vagrant-path-mappings.PNG" alt="Path mappings for vagrant" /></a>
We're basically telling PhpStorm what we told vagrant via the Vagrantfile:
<code>C:/Users/Pascal/PhpstormProjects/untitled</code> (in my case) maps to <code>/vagrant_data</code></p>
</li>
<li>Confirm with &quot;OK&quot; and go back to the &quot;Interpreters&quot; window in PhpStorm. Repeat the first steps of this section to get there.
Choose the remote interpreter we added before but instead of the &quot;Vagrant&quot; radio button, check the &quot;Deployment configuration&quot; radio button.
Choose the &quot;Vagrant&quot; configuration we just created and hit &quot;Apply&quot;. There should be no warnings left.
<a href="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/phpstorm/interpreter-vagrant-via-deployment.PNG"><img src="/img/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/phpstorm/interpreter-vagrant-via-deployment.PNG" alt="Run vagrant via deployment" /></a></li>
<li>
<p>Hit &quot;OK&quot; in all open windows to save the changes we just made and run the &quot;test.php&quot; file.
This should generate the following output:</p>
<pre><code>sftp://vagrant@127.0.0.1:2222/usr/bin/php /vagrant_data/test.php
1

Process finished with exit code 0</code></pre>
<p>The line <code>sftp://vagrant@127.0.0.1:2222/usr/bin/php /vagrant_data/test.php</code> verifies, that we are actually using the php interpreter within the vagrant box:</p>
<ul>
<li>via <code>sftp://</code></li>
<li>with username <code>vagrant</code></li>
<li>on <code>127.0.0.1:2222</code></li>
<li>using <code>/usr/bin/php</code></li>
<li>to execute <code>/vagrant_data/test.php</code></li>
</ul>
</li>
</ul>
<p>Whoop whoop, that's it :) Oh and because homestead comes pre-installed with Xdebug, we could even set a breakpoint and halt the execution <em>within the virtual
machine</em> - now is that something or what? Before we go on let's shut down the VM by running <code>vagrant halt</code> on the host machine. This will simply shut down
the VM but all changes we made to it stay in place. If you want to make a completely fresh start, use <code>vagrant destroy</code> and confirm that you really want
to &quot;destroy&quot; the VM.</p>]]></description>
                                                    <pubDate>Sun, 07 Aug 2016 13:00:00 +0000</pubDate>
                                <link>https://www.pascallandau.com/blog/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=development-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/blog/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/</guid>
            </item>
                    <item>
                <title>How to setup PHP7 with Xdebug 2.4 for PhpStorm [Tutorial Part 1]</title>
                <description><![CDATA[<p>In this tutorial I'll show my typical procedure when setting up a new development environment on a fresh Windows 10 laptop.
It's not like I do this every day (as 'typical' might suggest) but when I started my current job, I had to do it
several times for me (switched my laptop) as well as for some of my co-workers. I'm going to cover this step-by-step
and will include (hopefully) all necessary information for you to get this setup running as well.</p>
<p>This is the first part of a three-part tutorial, focusing on the development on Windows. In the second part I will
explain how to make the shift to using a virtual machine and in the third we'll setup a fresh Laravel installation
and put it all together.</p>
<p>The second part is over at
<a href="http://www.pascallandau.com/blog/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/">Setting up PhpStorm with Vagrant and Laravel Homestead</a>,
the third at <a href="http://www.pascallandau.com/blog/laravel-with-phpunit-on-vagrant-in-phpstorm/">Setting up Laravel with PHPUnit on Vagrant in PhpStorm</a></p>
<p>Let's get to it, shall we?</p>
<h2>Table of contents</h2>
<ul>
<li><a href="#setup-php-7">Setup PHP 7</a><ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#the-path-variable">The `PATH` variable</a></li>
</ul></li>
<li><a href="#setup-phpstorm">Setup PhpStorm</a><ul>
<li><a href="#setup-for-local-php-development">Setup for local PHP development</a></li>
</ul></li>
<li><a href="#installing-xdebug">Installing Xdebug</a></li>
<li><a href="#setup-composer">Setup Composer</a><ul>
<li><a href="#enabling-the-openssl-php-extension">Enabling the openssl PHP extension</a></li>
</ul></li>
<li><a href="#phrase-express">Phrase Express</a><ul>
<li><a href="#clipboard-cache">Clipboard cache</a></li>
<li><a href="#text-expansion">Text expansion</a></li>
</ul>
<h2><a id="setup-php-7"></a>Setup PHP 7</h2>
<p>I do almost all of my development in a virtual machine because the final product usually runs on a unix server, but
from time to time I find it helpful to have a local setup available as well.</p>
<h3><a id="installation"></a>Installation</h3>
<ul>
<li>Download the current version of PHP 7 from the <a href="http://windows.php.net/download/">PHP download page for Windows</a>.
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/php/download-php.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/php/download-php.PNG" alt="Download PHP 7" title="Download PHP 7" /></a>
Simply take the version at the top of the right panel which should be the latest NTS (non thread safe) build.
If you have 64-bit system, choose the <em>VC14 x64 Non Thread Safe</em> variant.
Click on the link labeled &quot;zip&quot; to start the download. </li>
<li>create a new folder named <code>php7</code> in your Program Files directory (e.g. <code>C:\Program Files</code>) and unzip the downloaded archive there
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/php/install-php.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/php/install-php.PNG" alt="Install PHP 7" title="Install PHP 7" /></a></li>
<li>double-click the file &quot;php.exe&quot; to confirm no error message shows up. You might encounter the error
<em>Unable to start the program as VCRUNTIME140.dll is missing on your computer. Try reinstalling the program to fix this problem.</em>
It can be fixed by downloading and installing the corresponding file from <a href="https://www.microsoft.com/en-us/download/details.aspx?id=48145">here</a>
(found at <a href="http://stackoverflow.com/a/30826746">stackoverflow</a>)
Please make sure you pick the architecture (x64/x86) that matches the previously downloaded PHP7 version!</li>
</ul>
<p>We're almost done, but we should modify the <code>PATH</code> variable in order to make PHP globally available.</p>
<h3><a id="the-path-variable"></a>The <code>PATH</code> variable</h3>
<p>Simply put, the <code>PATH</code> variable defines where Windows looks for executable files when the specified file is not found
in the current directory. So lets say you would like to know the current PHP version on your system, then
<a href="http://stackoverflow.com/a/15517857/413531">stackoverflow</a> will tell you something along the lines of</p>
<pre><code>C:\&gt;php -v</code></pre>
<p>But you will probably get this</p>
<blockquote>
<p>php: command not found</p>
</blockquote>
<p>or this</p>
<blockquote>
<p>'php' is not recognized as an internal or external command,
operable program or batch file.</p>
</blockquote>
<p><a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/php/php-command-not-found.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/php/php-command-not-found.PNG" alt="php command not found" title="php command not found" /></a></p>
<p>That command would only work if our current working directory (the location from where we executed the <code>php -v</code> command) would
contain the correct php.exe file. In other words: Calling the command is not location-agnostic yet. To make it, though,
we need to modify the <code>PATH</code> environment variable and make it aware of the location PHP is installed at.</p>
<p>To do so, we need to modify the System Properties... and might as well learn some nifty shortcuts to get there along the way :)</p>
<ul>
<li>open the &quot;run&quot; window by pressing <code>WIN + R</code></li>
<li>type <code>SystemPropertiesAdvanced</code> and hit Enter</li>
<li>click on &quot;Environment Variables...&quot; at the bottom of the window
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/path/SystemPropertiesAdvanced.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/path/SystemPropertiesAdvanced.PNG" alt="SystemPropertiesAdvanced" title="SystemPropertiesAdvanced" /></a></li>
<li>select the <code>PATH</code> entry in the list of system variables (lower half) and click &quot;Edit...&quot;
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/path/environment-variables.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/path/environment-variables.PNG" alt="Environment variables" title="Environment variables" /></a></li>
<li>hit the &quot;New&quot; button and enter the full path to the directory that should be used to look up commands/programs.
So in the case of PHP that's the directory containing the php.exe file.
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/path/new-environment-variable.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/path/new-environment-variable.PNG" alt="New environment variable" title="New environment variable" /></a></li>
<li>confirm with &quot;OK&quot;</li>
<li>open a new shell by hitting <code>WIN + R</code>, type <code>cmd</code> and confirm with Enter
<ul>
<li><em>Caution:</em> Any existing shell will <em>not</em> be aware of the changes in the environment variables so you need to restart a new one!</li>
</ul></li>
<li>running <code>php -v</code> again should now yield something like this:
<pre><code>C:\&gt;php -v
PHP 7.0.7 (cli) (built: May 25 2016 13:08:31) ( NTS )
Copyright (c) 1997-2016 The PHP Group
Zend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies</code></pre></li>
</ul>
<p>Cool, now on to the IDE.</p>
<h2><a id="setup-phpstorm"></a>Setup PhpStorm</h2>
<h3><a id="installation"></a>Installation</h3>
<ul>
<li>Download the current version of PhpStorm from the <a href="https://www.jetbrains.com/phpstorm/download/">PhpStorm download page</a>
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/download.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/download.PNG" alt="Download PhpStorm" title="Download PhpStorm" /></a>
<ul>
<li>Yes, it's paid but so far the best IDE I've come across + you get a 30 day free trial ;)</li>
</ul></li>
<li>Double-click the downloaded file (probably something like PhpStorm-2016.1.2.exe) and follow the instructions.
Nothing fancy there.</li>
<li>After the installation finished, run PhpStorm. You should be greeted with the question for importing previous settings.
We'll go with the &quot;I do not have a previous version of PhpStorm or I do not want to import my settings&quot; option as we
can always do that later.</li>
<li>After accepting the Privacy Policy you'll be prompted for the license activation. Unless you have a valid license,
go with the &quot;Evaluation for free for 30 days&quot; option and accept the license agreement afterwards.
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/evaluate.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/evaluate.PNG" alt="PhpStorm license" title="PhpStorm license" /></a></li>
<li>PhpStorm will now start and ask you for the Initial Configuration - that is Keymap scheme, IDE theme and colors/fonts.
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/initial-configuration.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/initial-configuration.PNG" alt="Initial configuration" title="Initial configuration" /></a>
Unless you have anything to change a that point, go with the defaults and hit OK.</li>
<li>In the following New Project screen choose &quot;PHP Empty Project&quot; in the left hand list and hit &quot;Create&quot;</li>
</ul>
<p>That'll conclude the installation :)</p>
<h3><a id="setup-for-local-php-development"></a>Setup for local PHP development</h3>
<p>First, let's create a new PHP file by right-clicking on the project folder and choosing <code>New &gt; PHP File</code>.
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/new-file.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/new-file.PNG" alt="Create new PHP file" title="Create new PHP file" /></a></p>
<p>Name the file <code>test.php</code> and give it the following content:</p>
<pre><code>&lt;?php
$i = 1;
echo $i."\n";</code></pre>
<p>Now select <code>Run &gt; Run...</code> and choose the test.php with the small PHP icon in the front.
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/run.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/run.PNG" alt="Run PHP file" title="Run PHP file" /></a></p>
<p>A new window should appear because we did not specify a PHP interpreter yet so PhpStorm doesn't know how to run the file.
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/no-interpreter.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/no-interpreter.PNG" alt="Interpreter error" title="Interpreter error" /></a></p>
<p>A click on the &quot;Fix&quot; button with the red exclamation mark will open up the PHP interpreter settings. You can get to the
same screen via <code>File &gt; Settings... &gt; Languages &amp; Frameworks &gt; PHP</code>. First, choose <em>7 (return types,
scalar type hints, etc.)</em> as PHP language level so that scalar type hints won't get marked as an error, for instance.
Second, hit the <code>...</code> button to specify an new (local) PHP interpreter and click on the green &quot;+&quot; icon on the top left.
Since we installed PHP 7 before, PhpStorm should automatically provide that as an option. Otherwise choose &quot;Other Local...&quot;
and select the php.exe file from the install location of PHP on your system.
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/select-interpreter.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/select-interpreter.PNG" alt="Select interpreter" title="Select interpreter" /></a></p>
<p>A little warning sign should appear, stating that the</p>
<blockquote>
<p>Configuration php.ini file does not exist</p>
</blockquote>
<p><a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/php-no-ini.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/php-no-ini.PNG" alt="No php.ini warning" title="No php.ini warning" /></a></p>
<p>Clicking on the &quot;How To Fix&quot; help link reveals, that PHP expects a file called php.ini in either its installation directory
or at C:\Windows. But we'll come to that in a moment. For now, we can just confirm all dialogs with &quot;OK&quot; and should now
be able to run the PHP file - either by right-click + selecting &quot;Run&quot; or (by default) hitting <code>Shift + F10</code>.
The console window of PhpStorm should open at the bottom and show something like this</p>
<pre><code>"C:\Program Files\php7\php.exe" C:\Users\IEUser\PhpstormProjects\untitled\test.php
1

Process finished with exit code 0</code></pre>
<p><a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/run-output.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/phpstorm/run-output.PNG" alt="Run output" title="Run output" /></a></p>
<p>Splendid, PhpStorm is now up and running with PHP7 :)</p>
<h2><a id="installing-xdebug"></a>Installing Xdebug</h2>
<p>Debugging is an invaluable asset during development as it lets you walk step-by-step through the source code, showing
exactly what is happening. <code>var_dump()</code> on freakin' steroids! Choose <code>Run &gt; Debug 'test.php'</code> (or hit <code>Shift + F9</code>) -
and be greeted by a little error message at the bottom that goes like this:</p>
<blockquote>
<p>Connection was no established: debug extension is not installed. </p>
</blockquote>
<p><a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/debug-extension-not-installed.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/debug-extension-not-installed.PNG" alt="Debug extension not installed" title="Debug extension not installed" /></a></p>
<p>Unfortunately, the  help link &quot;Update interpreter info&quot; is not really useful at that point... So what's actually going on?
In order enable debugging, we need to install the Xdebug extension. To do so, go to the
<a href="https://xdebug.org/download.php">Xdebug download page</a> and download the appropriate installer for your PHP version...
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/xdebug-versions.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/xdebug-versions.PNG" alt="Download Xdebug" title="Download Xdebug" /></a></p>
<p>Just kidding, of course I'm going to explain how to find the right one ;) Actually it's pretty straight forward:
We installed PHP 7 NTS, probably in the 64 bit version, so the link &quot;PHP 7.0 VC14 (64bit)&quot; should be the correct one.
But since I tend forget the exact version I installed, I would like to point to
<a href="https://xdebug.org/wizard.php">Xdebug's fantastic installation wizard</a> which simply requires us to print, copy and
paste some information of our PHP installation. And here's how we gonna do that:</p>
<ul>
<li>click on the test.php file in the left pane of your PhpStorm window and select &quot;Show in Explorer&quot;
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/show-in-explorer.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/show-in-explorer.PNG" alt="Show in Explorer" title="Show in Explorer" /></a>
<ul>
<li>a new window opens up at the location of the file</li>
</ul></li>
<li>press (and hold) Shift while right-clicking on an empty space within the opened folder. A new option
called &quot;Open command window here&quot; shows up. Click on it.
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/open-command-window-here.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/open-command-window-here.PNG" alt="Open CMD at path" title="Open CMD at path" /></a>
<ul>
<li>a new shell opens at the location of the folder (I know.. neat, right?)</li>
</ul></li>
<li>type <code>php -i</code>... and be overwhelmed by too much output. Since we need to copy and paste the output,
echoing on the command line is somewhat cumbersome.</li>
<li>type <code>php -i &gt; phpinfo.txt</code> instead to redirect the output to the file <code>phpinfo.txt</code> (that will be created at
the location of the shell which conveniently is also the location of our PhpStorm project).
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/phpinfo-output.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/phpinfo-output.PNG" alt="Capture php -i output" title="Capture php -i output" /></a>
If the file doesn't show up in PhpStorm after some seconds you can right-click
on the parent folder and select &quot;Synchronize [foldername]` ([foldername] is &quot;untitled&quot; in my example) to make
PhpStorm aware of changes in the filesystem.</li>
<li>open <code>phpinfo.txt</code>, hit <code>CTRL + A</code> to select everything and <code>CTRL + C</code> to copy. </li>
<li>hurry back to the Xdebug installation wizard, paste everything in the textarea and click the &quot;Analyse my phpinfo() output&quot; button.
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/xdebug-installation-wizard.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/xdebug-installation-wizard.PNG" alt="Xdebug wizard" title="Xdebug wizard" /></a>
The wizard will provide you with exact installation instructions for your system. For me, it looks like this:
<ol>
<li>Download <a href="http://xdebug.org/files/php_xdebug-2.4.0-7.0-vc14-nts-x86_64.dll">php_xdebug-2.4.0-7.0-vc14-nts-x86_64.dll</a></li>
<li>Move the downloaded file to <code>C:\php\ext</code></li>
<li>Create php.ini in the same folder as where php.exe is and add the line
<code>zend_extension = C:\php\ext\php_xdebug-2.4.0-7.0-vc14-nts-x86_64.dll</code></li>
</ol></li>
</ul>
<p>You <em>could</em> follow those instructions directly, but I would recommend to change the directory of the extension. <code>C:\php\ext</code> is
the default directory for PHP to look for extensions if not specified otherwise in <em>drumroll</em>  the <code>php.ini</code> - that we
shall create now. To do so, open you PHP installation directory (just as a reminder: mine was at <code>C:\Program Files\php7</code>), look for the file
<code>php.ini-development</code> copy and rename it to <code>php.ini</code> and open that file. Search for &quot;extension_dir&quot; which should lead
you to a passage that looks like this:</p>
<pre><code>; Directory in which the loadable extensions (modules) reside.
; http://php.net/extension-dir
; extension_dir = "./"
; On windows:
; extension_dir = "ext"</code></pre>
<p>Remove the leading  &quot;;&quot; in front of the &quot;extension_dir&quot; directive and set the path to the &quot;ext&quot; folder in your PHP installation
directory as value. For me, the line now looks like this:</p>
<pre><code>extension_dir = "C:\Program Files\php7\ext"</code></pre>
<p><em>Hint:</em> If you don't find any &quot;extension_dir&quot; string in your original php.ini file just add it at the end of the file.
Also, don't forget to save the file.</p>
<p>When re-running the <code>php -i &gt; phpinfo.txt</code> step including the Xdebug wizard, the instructions now look like this:
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/xdebug-installation-wizard-result.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/xdebug-installation-wizard-result.PNG" alt="Xdebug wizard installation instructions" title="Xdebug wizard installation instructions" /></a></p>
<ol>
<li>Download <a href="http://xdebug.org/files/php_xdebug-2.4.0-7.0-vc14-nts-x86_64.dll">php_xdebug-2.4.0-7.0-vc14-nts-x86_64.dll</a></li>
<li>Move the downloaded file to &quot;C:\Program Files\php7\ext&quot;</li>
<li>Edit C:\Program Files\php7\php.ini and add the line
<code>zend_extension = "C:\Program Files\php7\ext\php_xdebug-2.4.0-7.0-vc14-nts-x86_64.dll"</code></li>
</ol>
<p>You can add the &quot;zend_extension&quot; line simply at the end of the php.ini.</p>
<p>Now we should be good to go - or better to debug. Open up the test.php file in PhpStorm and click on the
little green bug icon on the top right to run the file in debug mode.
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/debug-mode.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/debug-mode.PNG" alt="Run in debug mode" title="Run in debug mode" /></a></p>
<p>The console window pops up again and yields something like this:</p>
<pre><code>"C:\Program Files\php7\php.exe" -dxdebug.remote_enable=1 -dxdebug.remote_mode=req -dxdebug.remote_port=9000 -dxdebug.remote_host=127.0.0.1 C:\Users\IEUser\PhpstormProjects\untitled\test.php
1

Process finished with exit code 0</code></pre>
<p>Please note the <code>-dxdebug</code> parameters following the php.exe call. To actually <em>use</em> the debugger, set a breakpoint in the
second line of the script (that says <code>$i = 1;</code>) by left-clicking on the little margin on the left of said line (you can
unset the breakpoint by simply clicking on it again).
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/set-breakpoint.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/xdebug/set-breakpoint.PNG" alt="Set breakpoint" title="Set breakpoint" /></a></p>
<p>Running the script now (again in debug mode) will stop the execution at that position.</p>
<p>Phew. Glad we got that thing working :)</p>
<h2><a id="setup-composer"></a>Setup Composer</h2>
<p>Next in line: PHP's beloved dependency manager Composer. I deeply believe that there's hardly a way around
this wonderful tool when it comes to modern PHP development. </p>
<h3><a id="installation"></a>Installation</h3>
<ul>
<li>download the current Windows installer from the <a href="https://getcomposer.org/download/">Composer download page</a>
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/composer/download-installer.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/composer/download-installer.PNG" alt="Download Composer installer" title="Download Composer installer" /></a></li>
<li>double-click the file to start the installation</li>
<li>choose the PHP version you want composer to use. The installation wizard should already show you
the installed PHP 7 php.exe file.
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/composer/choose-php-version.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/composer/choose-php-version.PNG" alt="Choose PHP version" title="Choose PHP version" /></a></li>
<li>next, you might get a security warning because the open-ssl extension is not activated and
composer can't connect via https to download some some necessary files.
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/composer/openssl-warning.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/composer/openssl-warning.PNG" alt="Openssl warning" title="Openssl warning" /></a></li>
</ul>
<p>So let's quickly take care of this before we continue. (We could also ignore this requirement by checking
the checkbox but I'll take this opportunity to show you how extensions are enabled for PHP).</p>
<h3><a id="enabling-the-openssl-php-extension"></a>Enabling the openssl PHP extension</h3>
<p>Open up the php.ini file in your PHP installation directory and search for &quot;php_openssl&quot;. You should now see
a line like this:</p>
<pre><code>;extension=php_openssl.dll</code></pre>
<p>The <code>php_openssl.dll</code> file should already come pre-installed in the &quot;ext&quot; directory within your PHP installation
directory. (It's starting to make sense that we adjusted the &quot;extension_dir&quot;, doesn't id ;)). So you can simply
remove the &quot;;&quot; in front of this line. To verify that the extension is actually loaded, open up a shell and type
<code>php -m</code> to list all enabled modules. The list should contain an item that says <code>openssl</code>.
<a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/composer/openssl-module.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/composer/openssl-module.PNG" alt="Show PHP modules" title="Show PHP modules" /></a></p>
<p>Cool. Now that that's working we shall continue with the installation process. Try hitting the &quot;&lt; Back&quot; button
once to get back to the PHP executable selection. Upon clicking &quot;Next &gt;&quot;, the openssl warning should be gone.
If not, cancel and restart the setup. You can ignore the Proxy Settings dialog and just hit &quot;Next &gt;&quot; and &quot;Install&quot;.
Since we installed Xdebug before, Composer will show a warning that this slows down Composer but that's nothing
to worry about. Just keep hitting &quot;Next &gt;&quot; and &quot;Finish&quot;. Composer will add itself automatically to your <code>PATH</code>
environment variable so you can call it globally. As mentioned before, this will only affect freshly opened shells,
so let's do a quick <code>WIN + R</code> and a <code>cmd</code>.</p>
<p>Type <code>composer -V</code> to print the Composer version, which should generate something along the lines of </p>
<pre><code>C:\Users\IEUser&gt;composer -V
You are running composer with xdebug enabled. This has a major impact on runtime performance. See https://getcomposer.org/xdebug
Composer version 1.1.1 2016-05-17 12:25:44</code></pre>
<p><a href="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/composer/composer-version.PNG"><img src="/img/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/composer/composer-version.PNG" alt="Show Composer version" title="Show composer version" /></a></p>
<p>Aaaand we're done.</p>
<h2><a id="phrase-express"></a>Phrase Express</h2>
<p>This is more of bonus since it's a somewhat opinionated software but I've grown very fond of it over the last
couple of years. Phrase Express is a clipboard manager / text expander for Windows. You can download the
tool for free at the <a href="http://www.phraseexpress.com/download.php">Phrase Express download page</a> (Download Client).</p>
<p>There's actually not much to tell about the installation process so I'm just gonna outline my major use cases.</p>
<h3><a id="clipboard-cache"></a>Clipboard cache</h3>
<p>This one is a biggie: Phrase Express saves everything you copy to the clipboard in a cache that can be accessed
via <code>CRTL + ALT + V</code> (by default). I cannot emphasize how incredibly handy that is.</p>
<h3><a id="text-expansion"></a>Text expansion</h3>
<p>There's a couple of things I have to type frequently (or at least from time to time) and it's just cumbersome
to either write them out in full length or to look them up. Here's my short list to give you an idea:</p>
<table>
<thead>
<tr>
<th>auto text</th>
<th></th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>mee</td>
<td></td>
<td><em>my email address</em></td>
</tr>
<tr>
<td>myssh</td>
<td></td>
<td><em>my public ssh key</em></td>
</tr>
<tr>
<td>mytax</td>
<td></td>
<td><em>my tax id</em></td>
</tr>
<tr>
<td>myserver</td>
<td></td>
<td><em>ip address of my server</em></td>
</tr>
<tr>
<td>ts</td>
<td></td>
<td><em>the current timestamp in Y-m-d format</em></td>
</tr>
<tr>
<td>tsf</td>
<td></td>
<td><em>the current timestamp in Y-m-d H:i:s format</em></td>
</tr>
<tr>
<td>*shrug</td>
<td></td>
<td>Â¯\_(ãƒ„)_/Â¯</td>
</tr>
<tr>
<td>*party</td>
<td></td>
<td>(ãƒ„)_\m/</td>
</tr>
<tr>
<td>cmark</td>
<td></td>
<td>âœ“</td>
</tr>
<tr>
<td>killphp</td>
<td></td>
<td><code>ps aux | grep php | awk '{print $2}' | sudo xargs kill</code></td>
</tr>
</tbody>
</table>]]></description>
                                                    <pubDate>Sun, 07 Aug 2016 10:00:00 +0000</pubDate>
                                <link>https://www.pascallandau.com/blog/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=development-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/blog/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/</guid>
            </item>
            </channel>
</rss>