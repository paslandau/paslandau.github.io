<?xml version = "1.0" encoding = "UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>pascallandau.com</title>
        <description>Personal website of Pascal Landau</description>
        <link>https://www.pascallandau.com</link>
        <atom:link href="https://www.pascallandau.com/feed.xml" rel="self" type="application/rss+xml"/>
        <pubDate>Sat, 20 Jun 2020 15:47:48 +0000</pubDate>
        <lastBuildDate>Sat, 20 Jun 2020 15:47:48 +0000</lastBuildDate>
        <language>en</language>
                    <item>
                <title>BigQuery: Calculate the MEDIAN in BigQuery</title>
                <description><![CDATA[<p>There is no <code>MEDIAN()</code> function in Google BigQuery, but we can still calculate the MEDIAN
with the
<a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#percentile_cont"><code>PERCENTILE_CONT(x, 0.5)</code></a> or
<a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#percentile_disc"><code>PERCENTILE_DISC(x, 0.5)</code></a>
functions. The difference between those two functions is the linear interpolation that is applied
when using <code>PERCENTILE_CONT(x, 0.5)</code> - so that's probably what you want when dealing with numeric
values. Take the numbers <code>1,2,3,4</code> for example:</p>
<ul>
<li><code>PERCENTILE_CONT(x, 0.5)</code> yields <code>2.5</code> (as the 50% percentile is exactly between 2 and 3)</li>
<li><code>PERCENTILE_DISC(x, 0.5)</code> yields <code>2</code> (as the 50% percentile is &gt;= 2)</li>
</ul>
<h2>Example</h2>
<pre><code>SELECT 
  PERCENTILE_CONT(x, 0.5) OVER() AS median_cont,
  PERCENTILE_DISC(x, 0.5) OVER() AS median_disc
FROM
  UNNEST([1,2,3,4]) as x 
LIMIT 1</code></pre>
<p><strong>Result</strong></p>
<table>
<thead>
<tr>
<th style="text-align: right;">median_cont</th>
<th style="text-align: right;">median_disc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: right;">2.5</td>
<td style="text-align: right;">2</td>
</tr>
</tbody>
</table>
<p><strong>Caution</strong>: As of today (2020-06-20), BigQuery only supports <code>PERCENTILE_CONT</code> and <code>PERCENTILE_DISC</code> for window functions
(hence the <code>OVER()</code> clause and the <code>LIMIT 1</code> in the example above):</p>
<blockquote>
<p>PERCENTILE_CONT is under development, and we will publish the documentation once it is GA. We will support it as analytic function first, and we plan to support it as aggregate function (allowing GROUP BY) later.</p>
</blockquote>
<p>Source: <a href="https://stackoverflow.com/a/45579962/413531">SO: percentile functions with GROUPBY in BigQuery</a></p>
<p>The more common use case is probably to calculate the median as a result of a <code>GROUP BY</code> statement.
I.e. I would <em>like</em> to write something like this to get the median of <code>quantity</code> per <code>product_id</code>.</p>
<pre><code>SELECT
  product_id, 
  PERCENTILE_CONT(quantity, 0.5) AS median
GROUP BY
  product_id</code></pre>
<p>Right now, that is only possible for the average via
<a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#avg"><code>AVG()</code></a>
but not for the median. But we can still work around that limitation by using the
<code>PERCENTILE_CONT</code> function on a window partitioned by <code>product_id</code>, then group by the <code>product_id</code>
(to get only one row per <code>product_id</code>)
and resolve a single median value via <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#any_value"><code>ANY_VALUE()</code></a>.</p>
<h2>Working Example</h2>
<script src="https://gist.github.com/paslandau/14940ec0fd34dc30b36377886c308ab3.js"><script src="https://gist.github.com/paslandau/14940ec0fd34dc30b36377886c308ab3.js"></script></script>
<h2>Run on BigQuery</h2>
<p><a href="https://console.cloud.google.com/bigquery?sq=580364496687:0c40a54f0d044cbebdc2745860a75490">Open in BigQuery UI</a></p>
<p><a href="/img/bigquery-snippets/calculate-median/calculate-median-bigquery-example.png"><img src="/img/bigquery-snippets/calculate-median/calculate-median-bigquery-example.png" alt="BigQuery UI: MEDIAN in BigQuery example" title="BigQuery UI: MEDIAN in BigQuery example" /></a></p>
<h2>Links</h2>
<ul>
<li><a href="https://stackoverflow.com/a/29095240/413531">Answer to &quot;How to calculate median of a numeric sequence in Google BigQuery efficiently?&quot; on Stackoverflow</a></li>
</ul>
<h2>Notes</h2>
<p>There is also the <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#approx_quantiles"><code>APPROX_QUANTILES()</code></a>
function (mentioned <a href="https://stackoverflow.com/a/39843565/413531">here</a>) that <em>can</em> by applied to a <code>GROUP BY</code>. I didn't have a practical use case for approximate functions
yet, though. Thus, I don't know the implications of &quot;not using an exact calculation&quot; and rather mention
this for the sake of completeness. Example:</p>
<pre><code>SELECT
  product_id, 
  APPROX_QUANTILES(quantity, 100)[OFFSET(50)] as approx_median
GROUP BY
  product_id</code></pre>]]></description>
                <pubDate>Sat, 20 Jun 2020 12:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/bigquery-snippets/calculate-median/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/bigquery-snippets/calculate-median/</guid>
            </item>
                    <item>
                <title>BigQuery: Use expression subqueries for querying nested and repeated fields</title>
                <description><![CDATA[<p>BigQuery allows to define <a href="https://cloud.google.com/bigquery/docs/nested-repeated">nested and repeated fields</a>
in a table. Although this is very powerful, it makes it much more complex to retrieve the
data if one is not used to such structures. Especially beginners tend to use an
<a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/arrays#flattening_arrays"><code>UNNEST</code> statement</a>
on the nested fields, followed by a huge
<code>GROUP BY</code> statement on the not-originally-repeated fields. Imho, using
<a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/expression_subqueries?hl=en">expression subqueries</a>
is oftentimes the better approach here.</p>
<h2>Code</h2>
<pre><code>SELECT
  id,
  (SELECT value from t.repeated_fields LIMIT 1)
FROM
  table t  </code></pre>
<p><strong>Caution</strong>: When using expression subqueries, you need to make sure that the result is a single value (scalar or array), otherwise you will
get the error message</p>
<blockquote>
<p>Scalar subquery produced more than one element</p>
</blockquote>
<p>In the example code above this is ensured by enforcing one result via <code>LIMIT 1</code>.</p>
<h2>Working Example</h2>
<script src="https://gist.github.com/paslandau/03c73ee5eef2ce217af82a8f7edcb125.js"><script src="https://gist.github.com/paslandau/03c73ee5eef2ce217af82a8f7edcb125.js"></script></script>
<h2>Run on BigQuery</h2>
<p><a href="https://console.cloud.google.com/bigquery?sq=106862046541:a3ca0564513344a2981ac658365112c1">Open in BigQuery Console</a></p>
<p><a href="/img/bigquery-snippets/expression-subqueries-for-nested-repeated-fields/expression-subquery-example.png"><img src="/img/bigquery-snippets/expression-subqueries-for-nested-repeated-fields/expression-subquery-example.png" alt="BigQuery Console: How to use expression subqueries for nested and repeated fields example" title="BigQuery Console: How to use expression subqueries for nested and repeated fields example" /></a></p>
<h2>Links</h2>
<ul>
<li><a href="https://gist.github.com/paslandau/03c73ee5eef2ce217af82a8f7edcb125">Gist on Github</a></li>
<li><a href="https://console.cloud.google.com/bigquery?sq=106862046541:a3ca0564513344a2981ac658365112c1">Example on BigQuery</a></li>
</ul>
<h2>Use cases</h2>
<p>The most prominent use case is probably the <a href="https://support.google.com/analytics/answer/3437719?hl=en">BigQuery export schema of Google Analytics</a>.
To be honest, I also feel that the schema is not very friendly for newcomers with its ~30 RECORD-type (nested) fields and 300+ columns.</p>
<p>In a nutshell, each row represents one <a href="https://support.google.com/analytics/answer/2731565?hl=en">session</a>.
A session consists of multiple hits. Those hits are also available in the nested and repeated <code>hits</code> field. But wait, there is more...
Each hit can have a number of so called <code>customDimensions</code> (meta data that can be attached to each hit). So the resulting table structue looks something
like this:</p>
<pre><code>- field_1
- field_2
- hits
  - field_1 
  - field_2
  - customDimensions
    - index 
    - value </code></pre>
<p>The following example uses the public <a href="https://support.google.com/analytics/answer/7586738?hl=en">Google Analytics sample dataset for BigQuery</a> and shows
a couple of sample expression subqueries</p>
<pre><code>SELECT 
  fullVisitorId,
  visitStartTime,
  TIMESTAMP_SECONDS(visitStartTime) as started_at,
  TIMESTAMP_SECONDS(visitStartTime + CAST( (SELECT time from t.hits ORDER BY hitNumber DESC LIMIT 1) /1000 AS INT64)) as ended_at,
  (SELECT COUNT(*) from t.hits) as hit_count,
  (SELECT page.hostname || page.pagePath from t.hits WHERE isEntrance = TRUE) as landing_page,
  (
    SELECT  
      (SELECT COUNT(*) from h.customDimensions) 
    FROM 
      t.hits h
    WHERE 
      hitNumber = 1
   ) as customDimension_count_of_first_hit, 
FROM 
  `bigquery-public-data.google_analytics_sample.ga_sessions_20170801` t
ORDER BY
  visitStartTime asc</code></pre>]]></description>
                <pubDate>Fri, 29 May 2020 14:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/bigquery-snippets/expression-subqueries-for-nested-repeated-fields/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/bigquery-snippets/expression-subqueries-for-nested-repeated-fields/</guid>
            </item>
                    <item>
                <title>BigQuery: Use &quot;temporary tables&quot; via WITH (named subqueries)</title>
                <description><![CDATA[<p>In Google BigQuery we can define named subqueries via <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax?hl=en#with_clause"><code>WITH</code> clauses</a>.
Those <code>WITH</code> clauses are a very comfortable way to structure complex queries as it allows to reference those queries like actual tables later on.</p>
<p><strong>Note</strong>: BigQuery also supports <em>actcual</em> temporary tables via <code>CREATE TEMPORARY TABLE</code>. See the official documention on
<a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#temporary_tables">temporary tables</a> for further infos.
This is out of scope for this snippet, though.</p>
<h2>Code</h2>
<pre><code>WITH filtered_data as (
  SELECT 
    id
  FROM
    table
  WHERE
    id BETWEEN 5 and 10
)
SELECT
  *
FROM
  filtered_data  </code></pre>
<h2>Working Example</h2>
<script src="https://gist.github.com/paslandau/662a42456dc9dc77b6cbdb1d6acb8c99.js"><script src="https://gist.github.com/paslandau/662a42456dc9dc77b6cbdb1d6acb8c99.js"></script></script>
<h2>Run on BigQuery</h2>
<p><a href="https://console.cloud.google.com/bigquery?sq=106862046541:96765412c1ea44a8b5a85cb697c3c945">Open in BigQuery Console</a></p>
<p><a href="/img/bigquery-snippets/use-temporary-tables-with-named-subquery/use-temporary-tables-via-with-named-subqueries-example.png"><img src="/img/bigquery-snippets/use-temporary-tables-with-named-subquery/use-temporary-tables-via-with-named-subqueries-example.png" alt="BigQuery Console: How to use temporay tables via WITH named subqueries example" title="BigQuery Console: How to use temporay tables via WITH named subqueries example" /></a></p>
<h2>Links</h2>
<ul>
<li><a href="https://gist.github.com/paslandau/662a42456dc9dc77b6cbdb1d6acb8c99">Gist on Github</a></li>
<li><a href="https://console.cloud.google.com/bigquery?sq=106862046541:96765412c1ea44a8b5a85cb697c3c945">Example on BigQuery</a></li>
<li><a href="https://stackoverflow.com/a/38149549/413531">Answer to &quot;How to create temporary table in Google BigQuery&quot; on Stackoverflow</a></li>
</ul>
<h2>Use cases</h2>
<p>Named subqueries are a great way to structure complex queries and give sub-results a meaningful name.
When working with partitioned tables, I always use temporary tables via WITH to make sure I restrict the query to
scan only a limited number of partitions.</p>
<p>Conceptual example:</p>
<pre><code>DECLARE from_date TIMESTAMP DEFAULT "2018-04-09";
DECLARE to_date TIMESTAMP DEFAULT "2018-04-10";

WITH huge_table_partition as(
  SELECT 
    *
  FROM 
    huge_table
  WHERE
    _PARTITIONTIME BETWEEN from_date AND to_date
)

SELECT 
  *
FROM
  huge_table_partition</code></pre>]]></description>
                <pubDate>Fri, 29 May 2020 13:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/bigquery-snippets/use-temporary-tables-with-named-subquery/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/bigquery-snippets/use-temporary-tables-with-named-subquery/</guid>
            </item>
                    <item>
                <title>BigQuery: Using Variables in BigQuery</title>
                <description><![CDATA[<p>Variables are a good way to keep a query &quot;clean&quot; and separate parameters from code.
In Google BigQuery, we can use variables in standard sql by defining them with a
<a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/scripting#declare"><code>DECLARE</code> statement</a>,
e.g. </p>
<pre><code>DECLARE foo STRING DEFAULT "foo";

#DECLARE &lt;variable&gt; &lt;type&gt; DEFAULT &lt;value&gt;;</code></pre>
<p>with <code>&lt;type&gt;</code> being one of the <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types">BigQuery's built-in standard-sql data types</a></p>
<p>This is equivalent to variables of other SQL databases, e.g.</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/user-variables.html">MySQL variables</a>: 
<pre><code>SET @foo = 'bar';</code></pre></li>
<li><a href="https://www.postgresql.org/docs/9.1/plpgsql-declarations.html">PostgreSQL variables</a>:
<pre><code>foo varchar := 'bar';</code></pre></li>
</ul>
<h2>Code</h2>
<pre><code>DECLARE foo_var STRING DEFAULT "foo";

SELECT foo_var</code></pre>
<h2>Working Example</h2>
<script src="https://gist.github.com/paslandau/0cb51ba9e532a71fff5108f156afd2f5.js"><script src="https://gist.github.com/paslandau/0cb51ba9e532a71fff5108f156afd2f5.js"></script></script>
<h2>Run on BigQuery</h2>
<p><a href="https://console.cloud.google.com/bigquery?sq=106862046541:200d3282989c48b7893b3c3145b46a6d">Open in BigQuery Console</a></p>
<p><a href="/img/bigquery-snippets/use-variables/use-variables-example.png"><img src="/img/bigquery-snippets/use-variables/use-variables-example.png" alt="BigQuery Console: How to declare and use variables example" title="BigQuery Console: How to declare and use variables example" /></a></p>
<h2>Links</h2>
<ul>
<li><a href="https://gist.github.com/paslandau/0cb51ba9e532a71fff5108f156afd2f5">Gist on Github</a></li>
<li><a href="https://console.cloud.google.com/bigquery?sq=106862046541:200d3282989c48b7893b3c3145b46a6d">Example on BigQuery</a></li>
<li><a href="https://stackoverflow.com/a/58227996/413531">Answer to &quot;Setting Big Query variables like mysql&quot; on Stackoverflow</a></li>
</ul>
<h2>Use cases</h2>
<p>Hardcoding variables is generally considered a bad practice as it makes it harder to understand and modify a query.
A frequent use case for me is the definition of date ranges (from and to dates) that are used for querying partitioned tables:</p>
<pre><code>DECLARE from_date DATE DEFAULT DATE("2018-04-09");
DECLARE to_date DATE DEFAULT DATE("2018-04-10");

WITH data as(
  SELECT 
    1 as id,
    DATE("2018-04-08") AS date,
  UNION ALL SELECT 2, DATE("2018-04-09") 
  UNION ALL SELECT 3, DATE("2018-04-10") 
  UNION ALL SELECT 4, DATE("2018-04-11") 
)

SELECT 
    id, 
    date
FROM
    data
WHERE
    date BETWEEN from_date AND to_date</code></pre>]]></description>
                <pubDate>Fri, 29 May 2020 12:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/bigquery-snippets/use-variables/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/bigquery-snippets/use-variables/</guid>
            </item>
                    <item>
                <title>BigQuery: Using multiple cursors / rectangular selection in BigQuery UI</title>
                <description><![CDATA[<p>Multiple keyboard shortcuts usable in the <a href="https://console.cloud.google.com/bigquery">BigQuery UI</a> are listed in the
<a href="https://cloud.google.com/bigquery/docs/bigquery-web-ui?hl=en#keyboard_shortcuts">official documentation</a>, though the one for
using multiple cursors is missing:</p>
<div class="center-div" style="font-size:2em">
    <code>ALT + left-mouse-button-drag</code>
</div>
<p><a href="/img/bigquery-snippets/multiple-cursors-big-query-ui/bigquery-multiple-cursors.gif"><img src="/img/bigquery-snippets/multiple-cursors-big-query-ui/bigquery-multiple-cursors.gif" alt="Using multiple cursors in the BigQuery UI via ATL + left mouse drag" /></a></p>
<h2>Instructions</h2>
<ul>
<li>keep the <code>ALT</code> key pressed first and then click the left mouse button and drag it up or down vertically</li>
<li>the same hotkeys can be used to draw a <strong>rectangular selection</strong> (aka column selection)
<a href="/img/bigquery-snippets/multiple-cursors-big-query-ui/bigquery-rectangular-column-selection.png"><img src="/img/bigquery-snippets/multiple-cursors-big-query-ui/bigquery-rectangular-column-selection.png" alt="Rectangular / column selection in BigQuery" /></a></li>
<li>using <code>ALT + LEFT</code> and <code>ALT + RIGHT</code> will position one (or all) cursors at the beginning respectively end of the line</li>
</ul>
<h2>Use cases</h2>
<p>We often deal with multiple datasets and tables that have the exact same structure, e.g. due to sharding. In those cases it's
often required to modify different parts of the query in the exact same way so that multiple cursors come in handy.</p>]]></description>
                <pubDate>Thu, 19 Dec 2019 18:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/bigquery-snippets/multiple-cursors-big-query-ui/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/bigquery-snippets/multiple-cursors-big-query-ui/</guid>
            </item>
                    <item>
                <title>How to build a Docker development setup for PHP Projects [Tutorial Part 3]</title>
                <description><![CDATA[<p>In the third part of this tutorial series on developing PHP on Docker we'll lay the fundamentals to
build a complete development infrastructure and explain how to &quot;structure&quot; the Docker setup as part
of a PHP project. Structure as in </p>
<ul>
<li>folder structure (&quot;what to put where&quot;)</li>
<li>Dockerfile templates</li>
<li>solving common problems (file permissions, runtime configuration, ...)</li>
</ul>
<p>We will also create a minimal container setup consisting of php-fpm, nginx and a workspace container that we
refactor from the previous parts of this tutorial.</p>
<div class="center-div">
<iframe width="560" height="315" src="https://www.youtube.com/embed/YYI5mTjFDuA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2>Published parts of the Docker PHP Tutorial</h2>
<ul>
<li><a href="/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/">Setting up PHP, PHP-FPM and NGINX for local development on Docker</a>
(2018-07-08)</li>
<li><a href="/blog/setup-phpstorm-with-xdebug-on-docker/">Setting up PhpStorm with Xdebug for local development on Docker</a>
(2018-08-06)</li>
<li><a href="/blog/structuring-the-docker-setup-for-php-projects/">Structuring the Docker setup for PHP Projects</a>
(2019-05-20)</li>
</ul>
<p>All code samples are publicly available in my
<a href="https://github.com/paslandau/docker-php-tutorial">Docker PHP Tutorial repository on github</a>.
The branch for this tutorial is
<a href="https://github.com/paslandau/docker-php-tutorial/tree/part_3_structuring-the-docker-setup-for-php-projects">part_3_structuring-the-docker-setup-for-php-projects</a>.</p>
<p>If you want to follow along, please subscribe to the <a href="/feed.xml">RSS feed</a> or <a href="#newsletter">via email</a>
to get automatic notifications when the next part comes out :)</p>
<h2>Acknowledgements</h2>
<p>Shout out to <a href="https://www.xing.com/profile/Nils_Meyer7">Nils Meyer</a>
for giving the final &quot;[...] nichts offensichtlich falsch&quot; (&quot;nothing obviously wrong&quot;) :)</p>
<h2>Table of contents</h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#structuring-the-repository">Structuring the repository</a>
<ul>
<li><a href="#the-docker-folder">The .docker folder</a></li>
<li><a href="#shared-folder">The <code>.shared</code> folder</a></li>
<li><a href="#"><code>docker-test.sh</code></a></li>
<li><a href="#env-example-and-docker-compose-yml"><code>.env.example</code> and <code>docker-compose.yml</code></a></li>
<li><a href="#the-makefile">The Makefile</a></li>
</ul></li>
<li><a href="#defining-services-php-fpm-nginx-and-workspace">Defining services: php-fpm, nginx and workspace</a>
<ul>
<li><a href="#php-fpm">php-fpm</a>
<ul>
<li><a href="#modifying-the-pool-configuration">Modifying the pool configuration</a></li>
<li><a href="#custom-entrypoint">Custom ENTRYPOINT</a></li>
</ul></li>
<li><a href="#nginx">nginx</a></li>
<li><a href="#workspace-formerly-php-cli">workspace (formerly php-cli)</a></li>
</ul></li>
<li><a href="#setting-up-docker-compose">Setting up docker-compose</a> 
<ul>
<li><a href="#docker-compose-yml">docker-compose.yml</a></li>
<li><a href="#env-example">.env.example</a></li>
<li><a href="#building-and-running-the-containers">Building and running the containers</a></li>
<li><a href="#testing-if-everything-works">Testing if everything works</a></li>
</ul></li>
<li><a href="#makefile-and-bashrc">Makefile and <code>.bashrc</code></a>
<ul>
<li><a href="#using-make-as-central-entry-point">Using <code>make</code> as central entry point</a></li>
<li><a href="#install-make-on-windows-mingw">Install make on Windows (MinGW)</a></li>
<li><a href="#easy-container-access-via-din-bashrc-helper">Easy container access via <code>din</code> .bashrc helper</a></li>
</ul></li>
<li><a href="#fundamentals-on-building-the-containers">Fundamentals on building the containers</a>
<ul>
<li><a href="#understanding-build-context">Understanding build context</a></li>
<li><a href="#dockerfile-template">Dockerfile template</a></li>
<li><a href="#setting-the-timezone">Setting the timezone</a></li>
<li><a href="#synchronizing-file-and-folder-ownership-on-shared-volumes">Synchronizing file and folder ownership on shared volumes</a></li>
<li><a href="#modifying-configuration-files">Modifying configuration files</a>
<ul>
<li><a href="#providing-additional-config-files">Providing additional config files</a></li>
<li><a href="#changing-non-static-values">Changing non-static values</a></li>
</ul></li>
<li><a href="#installing-php-extensions">Installing php extensions</a></li>
<li><a href="#installing-common-software">Installing common software</a></li>
<li><a href="#cleaning-up">Cleaning up</a></li>
<li><a href="#using-entrypoint-for-pre-run-configuration">Using <code>ENTRYPOINT</code> for pre-run configuration</a>
<ul>
<li><a href="#providing-host-docker-internal-for-linux-host-systems">Providing <code>host.docker.internal</code> for linux host systems</a></li>
</ul></li>
</ul></li>
<li><a href="#wrapping-up">Wrapping up</a></li>
</ul>
<h2><a id="introduction"></a>Introduction</h2>
<p>When I started my current role as Head of Marketing Technology at ABOUT YOU back in 2016, we heavily
relied on <a href="/blog/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/">Vagrant (namely: Homestead) as our development infrastructure</a>.
Though that was much better than
working on our local machines, we've run into a couple of problems along the way (e.g. diverging software,
bloated images, slow starting times, complicated readme for onboarding, upgrading php, ...).</p>
<p>Today, everything that we need for the infrastructure is under source control and committed in the same repository
that we use for our main application. In effect we get <strong>the same infrastructure for every developer</strong> including automatic
updates &quot;for free&quot;. It is extremely easy to tinker around with updates / new tools due to the ephemeral nature of docker
as tear down and rebuild only take one command and a couple of minutes.</p>
<p>To get a feeling for how the process <em>feels</em> like, simply execute the following commands.</p>
<pre><code>git clone https://github.com/paslandau/docker-php-tutorial.git
cd docker-php-tutorial
git checkout part_3_structuring-the-docker-setup-for-php-projects
make docker-clean
make docker-init
make docker-build-from-scratch
make docker-test</code></pre>
<p>You should now have a running docker environment to develop PHP on docker (unless
<a href="#building-and-running-the-containers">something is blocking your port 80/443</a>
or
<a href="#install-make-on-windows-mingw">you don't have make installed</a>
;))</p>
<h2><a id="structuring-the-repository"></a>Structuring the repository</h2>
<p>While playing around with docker I've tried different ways to &quot;structure&quot; files and folders and ended up with the following
concepts:</p>
<ul>
<li>everything related to docker is <strong>placed in a <code>.docker</code> directory on on the same level as the main application</strong></li>
<li>in this directory
<ul>
<li>each service gets its own subdirectory for configuration</li>
<li>is a <strong><code>.shared</code> folder containing scripts and configuration</strong> required by multiple services</li>
<li>is an <strong><code>.env.example</code></strong> file containing variables for the <strong><code>docker-compose.yml</code></strong></li>
<li>is a <strong><code>docker-test.sh</code></strong> file containing high level tests to validate the docker containers</li>
</ul></li>
<li>a <strong>Makefile</strong> with common instructions to control Docker is placed in the repository root</li>
</ul>
<p>The result looks roughly like this:</p>
<pre><code>&lt;project&gt;/
├── .docker/
|   ├── .shared/
|   |   ├── config/
|   |   └── scripts/
|   ├── php-fpm/
|   |   └── Dockerfile
|   ├── ... &lt;additional services&gt;/
|   ├── .env.example
|   ├── docker-compose.yml
|   └── docker-test.sh
├── Makefile
├── index.php
└──  ... &lt;additional app files&gt;/</code></pre>
<h3><a id="the-docker-folder"></a>The .docker folder</h3>
<p>As I mentioned, for me it makes a lot of sense to keep the <strong>infrastructure definition close to the codebase</strong>, because
it is immediately available to every developer. For bigger projects with multiple components there will be a
code-infrastructure-coupling anyways
(e.g. in my experience it is usually not possible to simply switch MySQL for PostgreSQL without any other changes)
and for a library it is a very convenient (although opinionated) way to get started. </p>
<p>I personally find it rather
frustrating when I want to contribute to an open source project but find myself spending a significant amount of time
setting the environment up correctly instead of being able to just work on the code.</p>
<p>Ymmv, though (e.g. because you don't want everybody with write access to your app repo also to be able to change your
infrastructure code). We actually went a different route previously and had a second repository (&quot;<app>-inf&quot;)
that would contain the contents of the <code>.docker</code> folder: </p>
<pre><code>&lt;project-inf&gt;/
├── .shared/
|   ├── config/
|   └── scripts/
├── php-fpm/
|   └── Dockerfile
├── ... &lt;additional services&gt;/
├── .env.example
└──  docker-compose.yml

&lt;project&gt;/
├── index.php
└──  ... &lt;additional app files&gt;/</code></pre>
<p>Worked as well, but we often ran into situations where
the contents of the repo would be stale for some devs, plus it was simply additional overhead with not other benefits
to us at that point. Maybe <a href="https://medium.com/@porteneuve/mastering-git-submodules-34c65e940407">git submodules</a> will
enable us to get the best of both worlds - I'll blog about it once we try ;)</p>
<h3><a id="shared-folder"></a>The <code>.shared</code> folder</h3>
<p>When dealing with multiple services, chances are high that some of those services will be configured similarly, e.g. for</p>
<ul>
<li>installing common software </li>
<li>setting up unix users (with the same ids)</li>
<li>configuration (think php-cli for workers and php-fpm for web requests)</li>
</ul>
<p>To avoid duplication, I place scripts (simple bash files) and config files in the <code>.shared</code> folder and make it available in
the build context for each service. I'll explain the process in more detail under
<a href="#understanding-build-context">providing the correct build context</a>.</p>
<h3><a id=""></a><code>docker-test.sh</code></h3>
<p>Is really just a simple bash script that includes some high level tests to make sure that the containers are
built correctly. See section <a href="#testing-if-everything-works">Testing if everything works</a>.</p>
<h3><a id="env-example-and-docker-compose-yml"></a><code>.env.example</code> and <code>docker-compose.yml</code></h3>
<p><code>docker-compose</code> uses a <a href="https://docs.docker.com/compose/environment-variables/#the-env-file"><code>.env</code> file</a>
for a convenient way to define and
<a href="https://docs.docker.com/compose/compose-file/#variable-substitution"><code>substitute environment variables</code></a>.
Since this <code>.env</code> file is environment specific, it is <strong>NOT</strong>
part of the repository (i.e. ignored via <code>.gitignore</code>). Instead, we provide a <code>.env.example</code> file that contains
the required environment variables including reasonable default values. A new dev would usually run
<code>cp .env.example .env</code> after checking out the repository for the first time.
See section <a href="#env-example">.env.example</a>.</p>
<h3><a id="the-makefile"></a>The Makefile</h3>
<p><code>make</code> and <code>Makefile</code>s are among those things that I've heard about occasionally but never really cared to
understand (mostly because I associated them with C). Boy, did I miss out. I was comparing different strategies
to provide code quality tooling (style checkers, static analyzers, tests, ...) and went from custom bash scripts
over <a href="https://getcomposer.org/doc/articles/scripts.md">composer scripts</a> to finally end up at <code>Makefile</code>s.</p>
<p>The <code>Makefile</code> serves as a central entry point and simplifies the management of the docker containers, e.g. for
(re-)building, starting, stopping, logging in, etc. See section <a href="#makefile-and-bashrc">Makefile and .bashrc</a>.</p>
<h2><a id="defining-services-php-fpm-nginx-and-workspace"></a>Defining services: php-fpm, nginx and workspace</h2>
<p>Let's have a look at a real example and &quot;refactor&quot; the
<a href="#workspace-formerly-php-cli">php-cli</a>,
<a href="#php-fpm">php-fpm</a>
and
<a href="#nginx">nginx</a>
containers from the <a href="/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/">first part of this tutorial series</a>. </p>
<p>This is the folder structure:</p>
<pre><code>&lt;project&gt;/
├── .docker/
|   ├── .shared/
|   |   ├── config/
|   |   |   └── php/ 
|   |   |       └── conf.d/
|   |   |           └── zz-app.ini
|   |   └── scripts/
|   |       └── docker-entrypoint/
|   |           └── resolve-docker-host-ip.sh
|   ├── nginx/
|   |   ├── sites-available/
|   |   |   └── default.conf
|   |   ├── Dockerfile
|   |   └── nginx.conf
|   ├── php-fpm/
|   |   ├── php-fpm.d/
|   |   |   └── pool.conf
|   |   └── Dockerfile
|   ├── workspace/ (formerly php-cli)
|   |   ├── .ssh/
|   |   |   └── insecure_id_rsa
|   |   |   └── insecure_id_rsa.pub
|   |   └── Dockerfile
|   ├── .env.example
|   ├── docker-compose.yml
|   └── docker-test.sh
├── Makefile
└── index.php</code></pre>
<h3><a id="php-fpm"></a>php-fpm</h3>
<p>Click here to <a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects/.docker/php-fpm/Dockerfile">see the full php-fpm Dockerfile</a>.</p>
<p>Since we will be having two PHP containers, we need to place the common .ini settings in the <code>.shared</code> directory.</p>
<pre><code>|   ├── .shared/
|   |   ├── config/
|   |   |   └── php/ 
|   |   |       └── conf.d/
|   |   |           └── zz-app.ini</code></pre>
<p>For now, <code>zz-app.ini</code> will only contain our
<a href="https://www.scalingphpbook.com/blog/2014/02/14/best-zend-opcache-settings.html">opcache setup</a>:</p>
<pre><code>; enable opcache
opcache.enable_cli = 1
opcache.enable = 1
opcache.fast_shutdown = 1
; revalidate everytime (effectively disabled for development)
opcache.validate_timestamps = 0</code></pre>
<p>The pool configuration is only relevant for php-fpm, so it goes in the directory of the service. Btw. I highly
recommend <a href="https://serversforhackers.com/c/lemp-php-fpm-config">this video on PHP-FPM Configuration</a> if your
php-fpm foo isn't already over 9000.</p>
<pre><code>|   ├── php-fpm/
|   |   ├── php-fpm.d/
|   |   |   └── pool.conf</code></pre>
<h4><a id="modifying-the-pool-configuration"></a>Modifying the pool configuration</h4>
<p>We're using the <a href="#changing-non-static-values"><code>modify_config.sh</code> script</a> to set the user and group that owns the php-fpm processes.</p>
<pre><code># php-fpm pool config
COPY ${SERVICE_DIR}/php-fpm.d/* /usr/local/etc/php-fpm.d
RUN /tmp/scripts/modify_config.sh /usr/local/etc/php-fpm.d/zz-default.conf \
    "__APP_USER" \
    "${APP_USER}" \
 &amp;&amp; /tmp/scripts/modify_config.sh /usr/local/etc/php-fpm.d/zz-default.conf \
    "__APP_GROUP" \
    "${APP_GROUP}" \
;</code></pre>
<h4><a id="custom-entrypoint"></a>Custom ENTRYPOINT</h4>
<p>Since php-fpm needs to be debuggable, we need to ensure that the <code>host.docker.internal</code> DNS entry exists,
so we'll use the <a href="#providing-host-docker-internal-for-linux-host-systems">corresponding ENTRYPOINT</a> to do that.</p>
<pre><code># entrypoint
RUN mkdir -p /bin/docker-entrypoint/ \
 &amp;&amp; cp /tmp/scripts/docker-entrypoint/* /bin/docker-entrypoint/ \
 &amp;&amp; chmod +x -R /bin/docker-entrypoint/ \
;

ENTRYPOINT ["/bin/docker-entrypoint/resolve-docker-host-ip.sh","php-fpm"]</code></pre>
<h3><a id="nginx"></a>nginx</h3>
<p>Click here to <a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects/.docker/nginx/Dockerfile">see the full nginx Dockerfile</a>.</p>
<p>The nginx setup is even simpler. There is no shared config, so that everything we need resides in</p>
<pre><code>|   ├── nginx/
|   |   ├── sites-available/
|   |   |   └── default.conf
|   |   ├── Dockerfile
|   |   └── nginx.conf</code></pre>
<p>Please note, that nginx only has the <code>nginx.conf</code> file for configuration (i.e. there is no <code>conf.d</code> directory or so),
so we need to define the <strong>full</strong> config in there. </p>
<pre><code>user __APP_USER __APP_GROUP;
worker_processes 4;
pid /run/nginx.pid;
daemon off;

http {
  # ...

  include /etc/nginx/sites-available/*.conf;

  # ...
}</code></pre>
<p>There are two things to note:</p>
<ul>
<li>user and group are modified dynamically</li>
<li>we specify <code>/etc/nginx/sites-available/</code> as the directory that holds the config files for the individual files via
<code>include /etc/nginx/sites-available/*.conf;</code></li>
</ul>
<p>We need to keep the last point in mind, because we must use the same directory in the Dockerfile:</p>
<pre><code># nginx app config
COPY ${SERVICE_DIR}/sites-available/* /etc/nginx/sites-available/</code></pre>
<p>The site's config file
<a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects/.docker/nginx/sites-available/default.conf"><code>default.conf</code></a>
has a variable (<code>__NGINX_ROOT</code>) for the <code>root</code> directive and we &quot;connect&quot; it with the fpm-container via
<code>fastcgi_pass php-fpm:9000;</code></p>
<pre><code>server {
    # ...
    root __NGINX_ROOT;
    # ...

    location ~ \.php$ {
        # ...
        fastcgi_pass php-fpm:9000;
    }
}</code></pre>
<p><code>php-fpm</code> will resolve to the <code>php-fpm</code> container, because we use php-fpm as the service name in the docker-compose
file, so it will be <a href="https://docs.docker.com/compose/compose-file/#aliases">automatically used as the hostname</a>:</p>
<blockquote>
<p>Other containers on the same network can use either the service name or [an] alias to connect to one of the service’s containers.</p>
</blockquote>
<p>In the Dockerfile, we use</p>
<pre><code>ARG APP_CODE_PATH
RUN /tmp/scripts/modify_config.sh /etc/nginx/sites-available/default.conf \
    "__NGINX_ROOT" \
    "${APP_CODE_PATH}" \
;</code></pre>
<p><code>APP_CODE_PATH</code> will be passed via docker-compose when we build the container and mounted as a shared directory
from the host system. </p>
<h3><a id="workspace-formerly-php-cli"></a>workspace (formerly php-cli)</h3>
<p>Click here to <a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects/.docker/workspace/Dockerfile">see the full workspace Dockerfile</a>.</p>
<p>We will use the former <code>php-cli</code> container and make it our <code>workspace</code> as introduced in part 2 of this tutorial under
<a href="https://www.pascallandau.com/blog/setup-phpstorm-with-xdebug-on-docker/#preparing-the-workspace-container">Preparing the &quot;workspace&quot; container</a>.</p>
<p>This will be the container we use to point our IDE to, e.g. to execute tests. Its Dockerfile looks almost identical
to the one of the <code>php-fpm</code> service, apart from the SSH setup:</p>
<pre><code># set up ssh
RUN apt-get update -yqq &amp;&amp; apt-get install -yqq openssh-server \
 &amp;&amp; mkdir /var/run/sshd \
;

# add default public key to authorized_keys
USER ${APP_USER}
COPY ${SERVICE_DIR}/.ssh/insecure_id_rsa.pub /tmp/insecure_id_rsa.pub
RUN mkdir -p ~/.ssh \
 &amp;&amp; cat /tmp/insecure_id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys \
 &amp;&amp; chown -R ${APP_USER}: ~/.ssh \
 &amp;&amp; chmod 700 ~/.ssh \
 &amp;&amp; chmod 600 ~/.ssh/authorized_keys \
;
USER root</code></pre>
<h2><a id="setting-up-docker-compose"></a>Setting up docker-compose</h2>
<p>In order to orchestrate the build process, we'll use docker-compose.</p>
<h3><a id="docker-compose-yml"></a>docker-compose.yml</h3>
<p>See the full
<a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects/.docker/docker-compose.yml">docker-compose.yml file in the repository</a></p>
<p>Things to note:</p>
<ul>
<li>each service uses <code>context: .</code> so it has access to the <code>.shared</code> folder.
The context is always <a href="https://docs.docker.com/compose/extends/#understanding-multiple-compose-files">relative to the location of the first docker-compose.yml file</a></li>
<li>all arguments that we used in the Dockerfiles are defined in the <code>args:</code>
section via
<pre><code>args:
- APP_CODE_PATH=${APP_CODE_PATH_CONTAINER}
- APP_GROUP=${APP_GROUP}
- APP_GROUP_ID=${APP_GROUP_ID}
- APP_USER=${APP_USER}
- APP_USER_ID=${APP_USER_ID}
- TZ=${TIMEZONE}</code></pre></li>
<li>the codebase is synced from the host in all containers via
<pre><code>volumes:
- ${APP_CODE_PATH_HOST}:${APP_CODE_PATH_CONTAINER}</code></pre></li>
<li>the <code>nginx</code> service exposes ports on the host machine so that we can
access the containers from &quot;outside&quot; via
<pre><code>ports:
- "${NGINX_HOST_HTTP_PORT}:80"
- "${NGINX_HOST_HTTPS_PORT}:443"</code></pre></li>
<li>all services are part of the <code>backend</code> network so they can talk to each
other. The <code>nginx</code> service has an additional alias that allows us to
define an arbitrary host name via
<pre><code>networks:
backend:
  aliases:
    - ${APP_HOST}</code></pre>
<p>I prefer to have a dedicated hostname per project (e.g. <code>docker-php-tutorial.local</code>)
instead of using <code>127.0.0.1</code> or <code>localhost</code> directly</p></li>
</ul>
<h3><a id="env-example"></a>.env.example</h3>
<p>To fill in all the required variables / arguments, we're using a <code>.env.example</code> file with the following content:</p>
<pre><code># Default settings for docker-compose
COMPOSE_PROJECT_NAME=docker-php-tutorial
COMPOSE_FILE=docker-compose.yml
COMPOSE_CONVERT_WINDOWS_PATHS=1

# build
PHP_VERSION=7.3
TIMEZONE=UTC
NETWORKS_DRIVER=bridge

# application
APP_USER=www-data
APP_GROUP=www-data
APP_USER_ID=1000
APP_GROUP_ID=1000
APP_CODE_PATH_HOST=../
APP_CODE_PATH_CONTAINER=/var/www/current

# required so we can reach the nginx server from other containers via that hostname
APP_HOST=docker-php-tutorial.local

# nginx
NGINX_HOST_HTTP_PORT=80
NGINX_HOST_HTTPS_PORT=443

# workspace
WORKSPACE_HOST_SSH_PORT=2222</code></pre>
<p>The <code>COMPOSE_</code> variables in the beginning set some reasonable
<a href="https://docs.docker.com/compose/reference/envvars/#compose_file">defaults for docker-compose</a>.</p>
<h3><a id="building-and-running-the-containers"></a>Building and running the containers</h3>
<p>By now, we should have everything we need set up to get our dockerized PHP development up and running. If
you haven't done it already, now would be a great time to clone
<a href="https://github.com/paslandau/docker-php-tutorial">the repository</a>
and checkout the
<a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects"><code>part_3_structuring-the-docker-setup-for-php-projects</code> branch</a>:</p>
<pre><code>git clone https://github.com/paslandau/docker-php-tutorial.git
cd docker-php-tutorial
git checkout part_3_structuring-the-docker-setup-for-php-projects</code></pre>
<p>Now copy the <code>.env.exmaple</code> to <code>.env</code>. All the default values  should work out of the box - unless you already have something
running on port <code>80</code> or <code>443</code>. In that case you have to change <code>NGINX_HOST_HTTP_PORT / NGINX_HOST_HTTP_PORT</code> to a free port.</p>
<pre><code>cp .env.example .env</code></pre>
<p>We can examine the &quot;final&quot; docker-compose.yml <strong>after</strong> the variable substitution via</p>
<pre><code>docker-compose -f .docker/docker-compose.yml --project-directory .docker config</code></pre>
<pre><code>networks:
  backend:
    driver: bridge
services:
  nginx:
    build:
      args:
        APP_CODE_PATH: /var/www/current
        APP_GROUP: www-data
        APP_GROUP_ID: '1000'
        APP_USER: www-data
        APP_USER_ID: '1000'
        TZ: UTC
      context: D:\codebase\docker-php-tutorial\.docker
      dockerfile: ./nginx/Dockerfile
    image: php-docker-tutorial/nginx
    networks:
      backend:
        aliases:
        - docker-php-tutorial.local
    ports:
    - published: 80
      target: 80
    - published: 443
      target: 443
    volumes:
    - /d/codebase/docker-php-tutorial:/var/www/current:rw
  php-fpm:
// ...</code></pre>
<p>Note, that this command is run from <code>./docker-php-tutorial</code>. If we would run this from <code>./docker-php-tutorial/.docker</code>,
we could simply use <code>docker-compose config</code> - but since we'll define that in a Makefile later anyway, the additional
&quot;verbosity&quot; won't matter ;)</p>
<p>This command is also a great way to check the various paths that are resolved to their absolute form, e.g. </p>
<pre><code>context: D:\codebase\docker-php-tutorial\.docker</code></pre>
<p>and</p>
<pre><code>volumes:
- /d/codebase/docker-php-tutorial:/var/www/current:rw</code></pre>
<p>The actual build is triggered via</p>
<pre><code>docker-compose -f .docker/docker-compose.yml --project-directory .docker build --parallel</code></pre>
<p>Since we have more than one container, it makes sense to build with
<a href="https://docs.docker.com/compose/reference/build/"><code>--parallel</code></a>.</p>
<p>To start the containers, we use</p>
<pre><code>docker-compose -f .docker/docker-compose.yml --project-directory .docker up -d</code></pre>
<p>and should see  </p>
<pre><code>$ docker-compose -f .docker/docker-compose.yml --project-directory .docker up -d
Starting docker-php-tutorial_nginx_1     ... done
Starting docker-php-tutorial_workspace_1 ... done
Starting docker-php-tutorial_php-fpm_1   ... done</code></pre>
<h3><a id="testing-if-everything-works"></a>Testing if everything works</h3>
<p>After rewriting our own docker setup a couple of times, I've come to appreciate a structured way to test if
&quot;everything&quot; works. Everything as in:</p>
<ul>
<li>are all containers running?</li>
<li>does &quot;host.docker.internal&quot; exist?</li>
<li>do we see the correct output when sending a request to nginx/php-fpm?</li>
<li>are all required php extensions installed?</li>
</ul>
<p>This might seem superfluous (after all, we just defined excatly that in the Dockerfiles), but there will come a time
when you (or someone else) need to make changes (new PHP version, new extensions, etc.) and having something that runs
automatically and informs you about obvious flaws is a real time saver. </p>
<p>You can see
<a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects/.docker/docker-test.sh">the full test file in the repository</a>.
Since my bash isn't the best, I try to keep it as simple as possible. The tests can be run via</p>
<pre><code>sh .docker/docker-test.sh</code></pre>
<p>and should yield something like this:</p>
<pre><code>Testing service 'workspace'
=======
Checking if 'workspace' has a running container
OK
Testing PHP version '7.3' on 'workspace' for 'php' and expect to see 'PHP 7.3'
OK
Testing PHP module 'xdebug' on 'workspace' for 'php'
OK
Testing PHP module 'Zend OPcache' on 'workspace' for 'php'
OK
Checking 'host.docker.internal' on 'workspace'
OK

Testing service 'php-fpm'
=======
...</code></pre>
<h2><a id="makefile-and-bashrc"></a>Makefile and <code>.bashrc</code></h2>
<p>In the previous sections I have introduced a couple of commands, e.g. for building and running containers. And to be honest,
I find it kinda challenging to keep them in mind without having to look up the exact options and arguments. I would
usually create a helper function or an alias in my local <code>.bashrc</code> file in a situation like that - but that wouldn't
be available to other members of the team then and it would be very specific to this one project.
Instead we'll provide a <code>Makefile</code> as a central reference point.</p>
<h3><a id="using-make-as-central-entry-point"></a>Using <code>make</code> as central entry point</h3>
<p>Please refer
<a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects/Makefile">to the repository for the full <code>Makefile</code></a>.</p>
<p>Going into the details of <code>make</code> is a little out of scope for this article,
so I kindly refer to some articles that helped me get started:</p>
<ul>
<li><a href="https://localheinz.com/blog/2018/01/24/makefile-for-lazy-developers/">Makefile for lazy developers</a></li>
<li><a href="https://blog.theodo.fr/2018/05/why-you-need-a-makefile-on-your-project/">Why you Need a Makefile on your Project</a></li>
</ul>
<p>Both are written with a PHP context in mind.
Tip: If you are using PhpStorm, give the <a href="https://plugins.jetbrains.com/plugin/9333-makefile-support">Makefile support plugin</a>
a try. And don't forget the number one rule:
<a href="https://stackoverflow.com/q/14109724">A <code>Makefile</code> requires tabs</a>!</p>
<p>Note: If you are using Windows, <code>make</code> is probably not available. See
<a href="#install-make-on-windows-mingw">Install make on Windows (MinGW)</a> for instructions to set it up.</p>
<p>The <code>Makefile</code> ist located in the root of the application. Since we use a <code>help</code> target that makes the
<a href="https://suva.sh/posts/well-documented-makefiles/"><code>Makefile</code> self-documenting</a>, we can simply run <code>make</code> to
see all the available commands:</p>
<pre><code>$ make

Usage:
  make &lt;target&gt;

[Docker] Build / Infrastructure
  docker-clean                 Remove the .env file for docker
  docker-init                  Make sure the .env file exists for docker
  docker-build-from-scratch    Build all docker images from scratch, without cache etc. Build a specific image by providing the service name via: make docker-build CONTAINER=&lt;service&gt;
  docker-build                 Build all docker images. Build a specific image by providing the service name via: make docker-build CONTAINER=&lt;service&gt;
  docker-up                    Start all docker containers. To only start one container, use CONTAINER=&lt;service&gt;
  docker-down                  Stop all docker containers. To only stop one container, use CONTAINER=&lt;service&gt;
  docker-test                  Run the infrastructure tests for the docker setup</code></pre>
<p>As a new developer, your &quot;onboarding&quot; to get a running infrastructure should now look like this:</p>
<pre><code>make docker-clean
make docker-init
make docker-build-from-scratch
make docker-test</code></pre>
<h3><a id="install-make-on-windows-mingw"></a>Install make on Windows (MinGW)</h3>
<p><code>make</code> doesn't exist on Windows and is also not part of the standard installation of MinGW
(click here <a href="/blog/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/#git-and-git-bash">to learn how to setup MinGW</a>)
Setting is up is straight forward but as with &quot;everything UI&quot; it's easier if you can
actually &quot;see what I'm doing&quot; - so here's a video:</p>
<div class="center-div">
<iframe width="560" height="315" src="https://www.youtube.com/embed/taCJhnBXG_w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<p>The steps are as follows:</p>
<ul>
<li>Set up <code>mingw-get</code>
<ul>
<li>Instructions: <a href="http://www.mingw.org/wiki/getting_started#toc5">http://www.mingw.org/wiki/getting_started#toc5</a></li>
<li>Download: <a href="https://sourceforge.net/projects/mingw/files/Installer/mingw-get-setup.exe/download">https://sourceforge.net/projects/mingw/files/Installer/mingw-get-setup.exe/download</a></li>
<li>Install and <a href="/blog/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/#the-path-variable">add the <code>bin/</code> directory to <code>PATH</code> (shortcut <code>systempropertiesadvanced</code>)</a>.
Notes: 
<ul>
<li>Do not use an installation path that contains spaces!</li>
<li>The installation path can be different from your MinGW location</li>
</ul></li>
</ul></li>
<li>Install <code>mingw32-make</code> via
<pre><code>mingw-get install mingw32-make</code></pre>
<ul>
<li>create the file <code>bin/make</code> with the content
<pre><code>mingw32-make.exe $*</code></pre></li>
<li>Note: Sometimes Windows won't recognize non-.exe files - so instead of <code>bin/make</code> you might need to name the file
<code>bin/make.exe</code> (with the same content)</li>
</ul></li>
<li>Open a new shell and type <code>make</code>. The output should look something like this
<pre><code>$ make
mingw32-make: *** Keine Targets angegeben und keine ¦make¦-Steuerdatei gefunden.  Schluss.</code></pre></li>
</ul>
<h3><a id="easy-container-access-via-din-bashrc-helper"></a>Easy container access via <code>din</code> .bashrc helper</h3>
<p>I've got one last goodie for working with Docker that I use all the time: </p>
<p>Logging into a running container via <a href="https://docs.docker.com/engine/reference/commandline/exec/#run-docker-exec-on-a-running-container"><code>docker exec</code></a>
and the <code>din / dshell</code> helper.</p>
<p><a href="/img/structuring-the-docker-setup-for-php-projects/easy-docker-login-din.gif.png"><img src="/img/structuring-the-docker-setup-for-php-projects/easy-docker-login-din.gif" alt="Log into any running docker container via din helper" /></a></p>
<p>To make this work, put the following code in your <code>.bashrc</code> file</p>
<pre><code>function din() {
  filter=$1

  user=""
  if [[ -n "$2" ]];
  then
    user="--user $2"
  fi

  shell="bash"
  if [[ -n "$3" ]];
  then
    shell=$3
  fi

  prefix=""
  if [[ "$(expr substr $(uname -s) 1 5)" == "MINGW" ]]; then
    prefix="winpty"
  fi
  ${prefix} docker exec -it ${user} $(docker ps --filter name=${filter} -q | head -1) ${shell}
}</code></pre>
<p>The <code>$(docker ps --filter name=${filter} -q | head -1)</code> part will find partial matches on running containers
for the first argument and pass the result to the <code>docker exec</code> command. In effect, we can log into any container
by only providing a minimal matching string on the container name. E.g. to log in the <code>workspace</code> container
I can now simply type <code>din works</code> from <em>anywhere</em> on my system.</p>
<h2><a id="fundamentals-on-building-the-containers"></a>Fundamentals on building the containers</h2>
<p>Since we have now &quot;seen&quot; the end result, let's take a closer look behind the scenes.
I assume that you are already somewhat familiar with <code>Dockerfile</code>s and have used <code>docker-compose</code> to orchestrate multiple
services (if not, check out
<a href="blog/php-php-fpm-and-nginx-on-docker-in-windows-10/#dockerfile">Persisting image changes with a Dockerfile</a> and
<a href="blog/php-php-fpm-and-nginx-on-docker-in-windows-10/#docker-compose">Putting it all together: Meet docker-compose</a>). But
there are some points I would like to cover in a little more detail.</p>
<h3><a id="understanding-build-context"></a>Understanding build context</h3>
<p>There are two essential parts when building a container:</p>
<ul>
<li>the Dockerfile</li>
<li>the build context</li>
</ul>
<p>You can read about the official description in the <a href="http://docs.docker.com/engine/reference/builder/#usage">Dockerfile reference</a>.
You'll usually see something like this:</p>
<pre><code>docker build .</code></pre>
<p>which assumes that you use the current directory as build context and that there is a Dockerfile in the same directory.</p>
<p>But you can also start the build via</p>
<pre><code>docker build .docker -f .docker/nginx/Dockerfile
                 |      |
                 |      └── use the Dockerfile at ".docker/nginx/Dockerfile"
                 |
                 └── use the .docker subdirectory as build context</code></pre>
<p>For me, the gist is this: The build context defines the files and folders (recursively) on your machine that are send
from the <a href="https://docs.docker.com/engine/reference/commandline/cli/">Docker CLI</a> to
the <a href="https://docs.docker.com/engine/reference/commandline/dockerd/">Docker Daemon</a> that executes the build process
of a container so that you can reference those files in the Dockerfile (e.g. via <code>COPY</code>). Take the following structure for example:</p>
<pre><code>&lt;project&gt;/
├── .docker/
    ├── .shared/
    |   └── scripts/
    |       └── ...
    └── nginx/
        ├── nginx.conf
        └── Dockerfile</code></pre>
<p>Assume, that the current working directory is <code>&lt;project&gt;/</code>. If we started a build via</p>
<pre><code>docker build .docker/nginx -f .docker/nginx/Dockerfile</code></pre>
<p>the context would <strong>not</strong> include the <code>.shared</code> folder so we wouldn't be able to <code>COPY</code> the <code>scripts/</code> subfolder.
If we ran</p>
<pre><code>docker build .docker -f .docker/nginx/Dockerfile</code></pre>
<p>however, that would make the <code>.shared</code> folder available. In the Dockerfile itself, I need to know what the build context
is, because I need to adjust the paths accordingly. Concrete example for the folder structure above and build
triggered via <code>docker build .docker -f .docker/nginx/Dockerfile</code>:</p>
<pre><code>FROM:nginx

# build context is .docker ...

# ... so the following COPY refers to .docker/.shared
COPY ./.shared /tmp

# ... so the following COPY refers to .docker/nginx/nginx.conf
COPY ./nginx/nginx.conf /tmp</code></pre>
<p>The build context for all of our containers will be the <code>.docker</code> directory,
so that all build processes have access to the <code>.shared</code> scripts and config.
Yes, that also means that the <code>php-fpm</code> container has access to files that are only relevant to the <code>mysql</code> container (for
instance), but the performance penalty is absolutely neglectable. Plus, as long as we don't actively <code>COPY</code> those irrelevant
files, they won't bloat up our images.</p>
<p>A couple of notes:</p>
<ul>
<li>I used to think that the build context is <em>always</em> tied to the location of the Dockerfile but that's only the default,
it can be any directory</li>
<li>the build context is <strong>actually send</strong> to the build process - i.e. you should avoid unnecessary files / folders as this might
affect performance, especially on big files (iaw: don't use <code>/</code> as context!)</li>
<li>similar to <code>git</code>, Docker knows the concept of a <a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file"><code>.dockerignore</code> file</a>
to exclude files from being included in the build context</li>
</ul>
<h3><a id="dockerfile-template"></a>Dockerfile template</h3>
<p>The Dockerfiles for the containers roughly follow the structure outlined below:</p>
<pre><code>FROM ...

# path to the directory where the Dockerfile lives relative to the build context
ARG SERVICE_DIR="./service"

# get the scripts from the build context and make sure they are executable
COPY .shared/scripts/ /tmp/scripts/
RUN chmod +x -R /tmp/scripts/

# set timezone
ARG TZ=UTC
RUN /tmp/scripts/set_timezone.sh ${TZ}

# add users
ARG APP_USER=www-data
ARG APP_USER_ID=1000
ARG APP_GROUP=$(APP_USER)
ARG APP_GROUP_ID=$(APP_USER_ID)

RUN /tmp/scripts/create_user.sh ${APP_USER} ${APP_GROUP} ${APP_USER_ID} ${APP_GROUP_ID}

# install common software
RUN /tmp/scripts/install_software.sh

# perform any other, container specific build steps
COPY ${SERVICE_DIR}/config/* /etc/service/config
RUN /tmp/scripts/modify_config.sh /etc/service/config/default.conf \
    "__APP_USER" \
    "${APP_USER}" \
;
# [...]

# set default work directory
WORKDIR "..."

# cleanup 
RUN /tmp/scripts/cleanup.sh

# define ENTRYPOINT
ENTRYPOINT [...]
CMD [...]</code></pre>
<p>The comments should suffice to give you an overview - so let's talk about the individual parts in detail.</p>
<h3><a id="setting-the-timezone"></a>Setting the timezone</h3>
<p><strong>Script: <code>set_timezone.sh</code></strong></p>
<p>Let's start with a simple and obvious one: Ensuring that all containers use the same system timezone
(see <a href="https://www.itzgeek.com/how-tos/linux/debian/how-to-change-timezone-in-debian-9-8-ubuntu-16-04-14-04-linuxmint-18.html">here</a>
and <a href="https://unix.stackexchange.com/q/452559">here</a>)</p>
<pre><code>#!/bin/sh

TZ=$1
ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone</code></pre>
<p>The script is then called from the <code>Dockerfile</code> via</p>
<pre><code>ARG TZ=UTC
RUN /tmp/scripts/set_timezone.sh ${TZ}</code></pre>
<h3><a id="synchronizing-file-and-folder-ownership-on-shared-volumes"></a>Synchronizing file and folder ownership on shared volumes</h3>
<p><strong>Script: <code>create_user.sh</code></strong></p>
<p>Docker makes it really easy to share files between containers by using <a href="https://docs.docker.com/storage/volumes/">volumes</a>.
For simplicities sake, you can picture a volume simply as an additional disk that multiple containers have access to.
And since it's PHP we're talking about here, sharing the same application files is a common requirement
(e.g. for <code>php-fpm</code>, <code>nginx</code>, <code>php-workers</code>).</p>
<p>As long as you are only dealing with one container, life is easy: You can simply <code>chown</code> files to the correct user.
But since the containers might have a different user setup, permissions/ownership becomes a problem. Checkout
<a href="https://serversforhackers.com/c/dckr-file-permissions">this video on Docker &amp; File Permissions</a> for a practical
example in a Laravel application.</p>
<p>The first thing for me was understanding that file ownership does not depend on the user <strong>name</strong> but rather on the user <strong>id</strong>.
And you might have guessed it: Two containers might have a user with the same name but with a different id.
The same is true for groups, btw. You can check the id by running <code>id &lt;name&gt;</code>, e.g.</p>
<pre><code>id www-data
uid=33(www-data) gid=33(www-data) groups=33(www-data)</code></pre>
<p><a href="/img/structuring-the-docker-setup-for-php-projects/docker-file-ownership-volume.png"><img src="/img/structuring-the-docker-setup-for-php-projects/docker-file-ownership-volume.png" alt="File ownership with multiple containers using a shared volume" /></a></p>
<p>That's inconvenient but rather easy to solve in most cases, because we have full control over the containers and
can <a href="https://www.cyberciti.biz/faq/linux-change-user-group-uid-gid-for-all-owned-files/">assign ids as we like</a>
(using <code>usermod -u &lt;id&gt; &lt;name&gt;</code>) and thus making sure every container uses the same user names with the same user ids.</p>
<p>Things get complicated when the volume isn't just a Docker volume but a shared folder on the host. This is usually
what we want for development, so that changes on the host are immediately reflected in all the containers.</p>
<p><a href="/img/structuring-the-docker-setup-for-php-projects/docker-file-ownership-host.png"><img src="/img/structuring-the-docker-setup-for-php-projects/docker-file-ownership-host.png" alt="File ownership with multiple containers using a shared volume from the host" /></a></p>
<p>This issue <strong>only affects users with a linux host system</strong>! Docker Desktop (previously known as Docker for Mac / Docker for Win)
has a virtualization layer in between that will effectively erase all ownership settings and make everything shared
from the host available to every user in a container.</p>
<p>We use the following script to ensure a consistent user setup when building a container:</p>
<pre><code>#!/bin/sh

APP_USER=$1
APP_GROUP=$2
APP_USER_ID=$3
APP_GROUP_ID=$4

new_user_id_exists=$(id ${APP_USER_ID} &gt; /dev/null 2&gt;&amp;1; echo $?) 
if [ "$new_user_id_exists" = "0" ]; then
    (&gt;&amp;2 echo "ERROR: APP_USER_ID $APP_USER_ID already exists - Aborting!");
    exit 1;
fi

new_group_id_exists=$(getent group ${APP_GROUP_ID} &gt; /dev/null 2&gt;&amp;1; echo $?) 
if [ "$new_group_id_exists" = "0" ]; then
    (&gt;&amp;2 echo "ERROR: APP_GROUP_ID $APP_GROUP_ID already exists - Aborting!");
    exit 1;
fi

old_user_id=$(id -u ${APP_USER})
old_user_exists=$(id -u ${APP_USER} &gt; /dev/null 2&gt;&amp;1; echo $?) 
old_group_id=$(getent group ${APP_GROUP} | cut -d: -f3)
old_group_exists=$(getent group ${APP_GROUP} &gt; /dev/null 2&gt;&amp;1; echo $?)

if [ "$old_group_id" != "${APP_GROUP_ID}" ]; then
    # create the group
    groupadd -f ${APP_GROUP}
    # and the correct id
    groupmod -g ${APP_GROUP_ID} ${APP_GROUP}
    if [ "$old_group_exists" = "0" ]; then
        # set the permissions of all "old" files and folder to the new group
        find / -group $old_group_id -exec chgrp -h ${APP_GROUP} {} \; || true
    fi 
fi

if [ "$old_user_id" != "${APP_USER_ID}" ]; then
    # create the user if it does not exist
    if [ "$old_user_exists" != "0" ]; then
        useradd ${APP_USER} -g ${APP_GROUP}
    fi

    # make sure the home directory exists with the correct permissions
    mkdir -p /home/${APP_USER} &amp;&amp; chmod 755 /home/${APP_USER} &amp;&amp; chown ${APP_USER}:${APP_GROUP} /home/${APP_USER} 

    # change the user id, set the home directory and make sure the user has a login shell
    usermod -u ${APP_USER_ID} -m -d /home/${APP_USER} ${APP_USER} -s $(which bash)

    if [ "$old_user_exists" = "0" ]; then
        # set the permissions of all "old" files and folder to the new user 
        find / -user $old_user_id -exec chown -h ${APP_USER} {} \; || true
    fi
fi</code></pre>
<p>The script is then called from the <code>Dockerfile</code> via</p>
<pre><code>ARG APP_USER=www-data
ARG APP_USER_ID=1000
ARG APP_GROUP=$(APP_USER)
ARG APP_GROUP_ID=$(APP_USER_ID)

RUN /tmp/scripts/create_user.sh ${APP_USER} ${APP_GROUP} ${APP_USER_ID} ${APP_GROUP_ID}</code></pre>
<p>The default values can be overriden by passing in the corresponding
<a href="https://docs.docker.com/engine/reference/commandline/build/#set-build-time-variables---build-arg">build args</a>. </p>
<p>Linux users should use the user id of the user on their host system - for Docker Desktop users the defaults are fine.</p>
<h3><a id="modifying-configuration-files"></a>Modifying configuration files</h3>
<p>For most services we probably need some custom configuration settings, like</p>
<ul>
<li>setting php.ini values</li>
<li>changing the default user of a service </li>
<li>changing the location of logfiles</li>
</ul>
<p>There are a couple of<br />
<a href="https://dantehranian.wordpress.com/2015/03/25/how-should-i-get-application-configuration-into-my-docker-containers/">common approaches to modify application configuration in docker</a>
and we are currently trying to stick to two rules:</p>
<ol>
<li>provide additional files that override defaults if possible</li>
<li>change non-static values with a simple search and replace via <code>sed</code> during the container build</li>
</ol>
<h4><a id="providing-additional-config-files"></a>Providing additional config files</h4>
<p>Most services allow the specification of additional configuration files that override the default values in
a default config file. This is great because we only need to define the settings that we actually care about
instead of copying a full file with lots of redundant values.</p>
<p>Take the <a href="http://php.net/manual/en/configuration.file.php#configuration.file.scan"><code>php.ini</code> file</a> for example:
It allows to places additional <code>.ini</code> files in a specific directory that override the default values. An easy way
to find this directory is <code>php -i | grep "additional .ini"</code>:</p>
<pre><code>$ php -i | grep "additional .ini"
Scan this dir for additional .ini files =&gt; /usr/local/etc/php/conf.d</code></pre>
<p>So instead of providing a &quot;full&quot; <code>php.ini</code> file, we will use a <code>zz-app.ini</code> file instead, that <strong>only</strong> contains the
.ini settings we actually want to change and place it under <code>/usr/local/etc/php/conf.d</code>. </p>
<p>Why <code>zz-</code>? Because</p>
<blockquote>
<p>[...] Within each directory, PHP will scan all files ending in .ini in alphabetical order.</p>
</blockquote>
<p>so if we want to ensure that our .ini files comes last (overriding all previous settings), we'll give it a
corresponding prefix :)</p>
<p>The full process would look like this:</p>
<ul>
<li>place the file in the <code>.docker</code> folder, e.g. at <code>.docker/.shared/config/php/conf.d/zz-app.ini</code></li>
<li>pass the folder as build context</li>
<li>in the Dockerfile, use <code>COPY .shared/config/php/conf.d/zz-app.ini /usr/local/etc/php/conf.d/zz-app.ini</code></li>
</ul>
<h4><a id="changing-non-static-values"></a>Changing non-static values</h4>
<p><strong>Script: <code>modify_config.sh</code></strong></p>
<p>Some configuration values are subject to local settings and thus should not be hard coded in configuration files.
Take the <code>memory_limit</code> configuration for <code>php-fpm</code> as an example: Maybe someone in the team can only dedicate
a limited amount of memory to docker, so the <code>memory_limit</code> has to be kept lower than usual.</p>
<p>We'll account for that fact by using a variable prefixed by <code>__</code> instead of the real value and replace it with
a dynamic argument in the Dockerfile. Example for the aforementioned <code>zz-app.ini</code>:</p>
<pre><code>memory_limit = __MEMORY_LIMIT</code></pre>
<p>We use the following script <code>modify_config.sh</code> to replace the value:</p>
<pre><code>#!/bin/sh

CONFIG_FILE=$1
VAR_NAME=$2
VAR_VALUE=$3

sed -i -e "s#${VAR_NAME}#${VAR_VALUE}#" "${CONFIG_FILE}"</code></pre>
<p>The script is then called from the <code>Dockerfile</code> via</p>
<pre><code>ARG PHP_FPM_MEMORY_LIMIT=1024M

RUN /tmp/scripts/modify_config.sh \
    "/usr/local/etc/php/conf.d/zz-app.ini" \
    "__MEMORY_LIMIT" \
    "${PHP_FPM_MEMORY_LIMIT}" \
;</code></pre>
<p>where <code>PHP_FPM_MEMORY_LIMIT</code> has a default value of <code>1024M</code> but can be overriden when the actual build is initiated.</p>
<h3><a id="installing-php-extensions"></a>Installing php extensions</h3>
<p><strong>Script: <code>install_php_extensions.sh</code></strong></p>
<p>When php extensions are missing, googling will often point to answers for normal linux systems using <code>apt-get</code> or <code>yum</code>,
e.g. <code>sudo apt-get install php-xdebug</code>. But for the official docker images, the recommended way is using the
<a href="https://github.com/docker-library/docs/blob/master/php/README.md#how-to-install-more-php-extensions">docker-php-ext-configure, docker-php-ext-install, and docker-php-ext-enable helper scripts</a>.
Unfortunately, some extensions have rather complicated dependencies, so that the installation fails.
Fortunately, there is a great project on Github called
<a href="https://github.com/mlocati/docker-php-extension-installer">docker-php-extension-installer</a> that takes care of that for us
and is super easy to use:</p>
<pre><code>FROM php:7.3-cli

ADD https://raw.githubusercontent.com/mlocati/docker-php-extension-installer/master/install-php-extensions /usr/local/bin/

RUN chmod uga+x /usr/local/bin/install-php-extensions &amp;&amp; sync &amp;&amp; install-php-extensions xdebug</code></pre>
<p>The readme also contains an
<a href="https://github.com/mlocati/docker-php-extension-installer#supported-php-extensions">overview of supported extension</a>
per PHP version. To ensure that all of our PHP containers have the same extensions, we provide the following script:</p>
<pre><code>#!/bin/sh

# add wget
apt-get update -yqq &amp;&amp; apt-get -f install -yyq wget

# download helper script
wget -q -O /usr/local/bin/install-php-extensions https://raw.githubusercontent.com/mlocati/docker-php-extension-installer/master/install-php-extensions \
    || (echo "Failed while downloading php extension installer!"; exit 1)

# install all required extensions
chmod uga+x /usr/local/bin/install-php-extensions &amp;&amp; sync &amp;&amp; install-php-extensions \
    xdebug \
    opcache \
;</code></pre>
<p>If you're not sure which extensions are required by your application, give the
<a href="https://github.com/maglnet/ComposerRequireChecker">ComposerRequireChecker</a> a try.</p>
<h3><a id="installing-common-software"></a>Installing common software</h3>
<p><strong>Script: <code>install_software.sh</code></strong></p>
<p>There is a certain set of software that I want to have readily available in every container. Since this a development
setup, I'd prioritize ease of use / debug over performance / image size, so this might seem like a little &quot;too much&quot;.
I think I'm also kinda spoiled by my Homestead past, because it's so damn convenient to have everything right at
your fingertips :)</p>
<p>Anyway, the script is straight forward:</p>
<pre><code>#!/bin/sh

apt-get update -yqq &amp;&amp; apt-get install -yqq \
    curl \
    dnsutils \
    gdb \
    git \
    htop \
    iputils-ping \
    iproute2 \
    ltrace \
    make \
    procps \
    strace \
    sudo \
    sysstat \
    unzip \
    vim \
    wget \
;</code></pre>
<p>Notes:</p>
<ul>
<li>this list should match <strong>your own set of go-to tools</strong>. I'm fairly open to adding new stuff here if it speeds up the
dev workflow. But if you don't require some of the tools, get rid of them.</li>
<li>sorting the software alphabetically is a good practice to avoid unnecessary duplicates. Don't do this by hand, though!
If you're using an IDE / established text editor, chances are high that this is either a build-in functionality or
there's a plugin available. I'm using <a href="https://plugins.jetbrains.com/plugin/5919-lines-sorter">Lines Sorter for PhpStorm</a></li>
</ul>
<h3><a id="cleaning-up"></a>Cleaning up</h3>
<p><strong>Script: <code>cleanup.sh</code></strong></p>
<p>Nice and simple:</p>
<pre><code>#!/bin/sh

apt-get clean
rm -rf /var/lib/apt/lists/* \
       /tmp/* \
       /var/tmp/* \
       /var/log/lastlog \
       /var/log/faillog</code></pre>
<h3><a id="using-entrypoint-for-pre-run-configuration"></a>Using <code>ENTRYPOINT</code> for pre-run configuration</h3>
<p>Docker went back to the unix roots with the
<a href="https://en.wikipedia.org/wiki/Unix_philosophy#Do_One_Thing_and_Do_It_Well">do on thing and do it well philosophy</a> which is
manifested in the <a href="https://medium.freecodecamp.org/docker-entrypoint-cmd-dockerfile-best-practices-abc591c30e21"><code>CMD</code> and <code>ENTRYPOINT</code> instructions</a>.</p>
<p>As I had a hard time understanding those instructions when I started with Docker, here's my take at a layman's terms description:</p>
<ul>
<li>since a container should do one thing, we need to specify that thing. That's what we do with <code>ENTRYPOINT</code>. Concrete examples:
<ul>
<li>a <code>mysql</code> container should probably run the <code>mysqld</code> daemon</li>
<li>a <code>php-fpm</code> container.. well, <code>php-fpm</code></li>
</ul></li>
<li>the <code>CMD</code> is passed as the default argument to the <code>ENTRYPOINT</code></li>
<li>the <code>ENTRYPOINT</code> is executed every time we <em>run</em> a container. Some things can't be done during build but only at runtime
(e.g. find the IP of the host from within a container - see section
<a href="providing-host-docker-internal-for-linux-host-systems">Providing <code>host.docker.internal</code> for linux host systems</a>
) - <code>ENTRYPOINT</code> is a good solution for that problem</li>
<li>technically, we can only override an already existing <code>ENTRYPOINT</code> from the base image. But: We can structure the new
<code>ENTRYPOINT</code> like a <a href="https://en.wikipedia.org/wiki/Decorator_pattern">decorator</a> by adding <code>exec "$@"</code> at the end to
simulate inheritance from the parent image</li>
</ul>
<p>To expand on the last point, consider the default
<a href="https://github.com/docker-library/php/blob/640a30e8ff27b1ad7523a212522472fda84d56ff/7.3/stretch/fpm/docker-php-entrypoint"><code>ENTRYPOINT</code> of the current [2019-02-23; PHP 7.3] <code>php-fpm</code> image</a></p>
<pre><code>#!/bin/sh

set -e

# first arg is `-f` or `--some-option`
if [ "${1#-}" != "$1" ]; then
    set -- php-fpm "$@"
fi

exec "$@"</code></pre>
<p>In the <a href="https://github.com/docker-library/php/blob/640a30e8ff27b1ad7523a212522472fda84d56ff/7.3/stretch/fpm/Dockerfile#L223">corresponding Dockerfile</a>
we find the following instructions:</p>
<pre><code># [...]
ENTRYPOINT ["docker-php-entrypoint"]
# [...]
CMD ["php-fpm"]</code></pre>
<p>That means: When we run the container it will pass the string &quot;php-fpm&quot; to the <code>ENTRYPOINT</code> script <code>docker-php-entrypoint</code>
as argument which will then execute it (due to the <code>exec "$@"</code> instruction at the end):</p>
<pre><code>$ docker run --name test --rm php:fpm
[23-Feb-2019 14:49:20] NOTICE: fpm is running, pid 1
[23-Feb-2019 14:49:20] NOTICE: ready to handle connections
# php-fpm is running
# Hit ctrl + c to close the connection
$ docker stop test</code></pre>
<p>We could now override the default <code>CMD</code> &quot;php-fpm&quot; with something else, e.g. a simple <code>echo "hello"</code>. The <code>ENTRYPOINT</code>
will happily execute it:</p>
<pre><code>$ docker run --name test --rm php:fpm echo "hello"
hello</code></pre>
<p>But now the <code>php-fpm</code> process isn't started any more. How can we echo &quot;hello&quot; but still keep the fpm process running?
By adding our own <code>ENTRYPOINT</code> script:</p>
<pre><code>#!/bin/sh
echo 'hello'

exec "$@"</code></pre>
<p>Full example (using <a href="https://docs.docker.com/engine/reference/commandline/build/#build-with--">stdin to pass the Dockerfile</a>
via <a href="https://stackoverflow.com/q/2953081/413531">Heredoc string</a>)</p>
<pre><code>$ docker build -t my-fpm -&lt;&lt;'EOF'
FROM php:fpm

RUN  touch "/usr/bin/my-entrypoint.sh" \
  &amp;&amp; echo "#!/bin/sh" &gt;&gt; "/usr/bin/my-entrypoint.sh" \
  &amp;&amp; echo "echo 'hello'" &gt;&gt; "/usr/bin/my-entrypoint.sh" \
  &amp;&amp; echo "exec \"\$@\"" &gt;&gt; "/usr/bin/my-entrypoint.sh" \
  &amp;&amp; chmod +x "/usr/bin/my-entrypoint.sh" \
  &amp;&amp; cat "/usr/bin/my-entrypoint.sh" \
;

ENTRYPOINT ["/usr/bin/my-entrypoint.sh", "docker-php-entrypoint"]
CMD ["php-fpm"]
EOF</code></pre>
<p>Note that we added the <code>ENTRYPOINT</code> of the parent image <code>docker-php-entrypoint</code> as argument to our own <code>ENTRYPOINT</code> script
<code>/usr/bin/my-entrypoint.sh</code> so that we don't loose its functionality. And we need to define the <code>CMD</code> instruction explicitly,
because the one from the parent image is <a href="https://stackoverflow.com/a/49031590/413531">automatically removed once we define our own <code>ENTRYPOINT</code></a>.</p>
<p>But: It works: </p>
<pre><code>$ docker run --name test --rm my-fpm
hello
[23-Feb-2019 15:43:25] NOTICE: fpm is running, pid 1
[23-Feb-2019 15:43:25] NOTICE: ready to handle connections
# Hit ctrl + c to close the connection
$ docker stop test</code></pre>
<h4><a id="providing-host-docker-internal-for-linux-host-systems"></a>Providing <code>host.docker.internal</code> for linux host systems</h4>
<p><strong>Script: <code>docker-entrypoint/resolve-docker-host-ip.sh</code></strong></p>
<p>In the previous part of this tutorial series, I explained how to build the
<a href="/blog/setup-phpstorm-with-xdebug-on-docker">Docker container in a way that it plays nice with PhpStorm and Xdebug</a>.
The key parts were SSH access and the magical <code>host.docker.internal</code> DNS entry. This works great for Docker Desktop (Windows and Mac)
but not for Linux. The DNS entry <a href="https://github.com/docker/for-linux/issues/264">doesn't exist there</a>.
Since we rely on that entry
<a href="/blog/setup-phpstorm-with-xdebug-on-docker/#fix-xdebug-on-phpstorm-when-run-from-a-docker-container">to make debugging possible</a>,
we will set it &quot;manually&quot; <a href="https://stackoverflow.com/a/24049165/413531">if the host doesn't exist</a>
with the following script
(inspired by the article <a href="https://dev.to/bufferings/access-host-from-a-docker-container-4099">Access host from a docker container</a>):</p>
<pre><code>#!/bin/sh

set -e

HOST_DOMAIN="host.docker.internal"

# check if the host exists - this will fail on linux
if dig ${HOST_DOMAIN} | grep -q 'NXDOMAIN'
then
  # resolve the host IP
  HOST_IP=$(ip route | awk 'NR==1 {print $3}')
  # and write it to the hosts file
  echo "$HOST_IP\t$HOST_DOMAIN" &gt;&gt; /etc/hosts
fi

exec "$@"</code></pre>
<p>The script is placed at <code>.shared/docker-entrypoint/resolve-docker-host-ip.sh</code> and added as <code>ENTRYPOINT</code> in the Dockerfile via </p>
<pre><code>COPY .shared/scripts/ /tmp/scripts/

RUN mkdir -p /bin/docker-entrypoint/ \
 &amp;&amp; cp /tmp/scripts/docker-entrypoint/* /bin/docker-entrypoint/ \
 &amp;&amp; chmod +x -R /bin/docker-entrypoint/ \
;

ENTRYPOINT ["/bin/docker-entrypoint/resolve-docker-host-ip.sh", ...]</code></pre>
<p>Notes:</p>
<ul>
<li>since this script depends on runtime configuration, we need to run it as an <code>ENTRYPOINT</code></li>
<li>there is no need to explicitly check for the OS type - we simply make sure that the DNS entry exists
and add it if it doesn't</li>
<li>we're using <code>dig</code> (package <code>dnsutils</code>) and <code>ip</code> (package <code>iproute2</code>) which need to be installed
during the build time of the container. Tip: If you need to figure out the package for a specific command,
give <a href="https://command-not-found.com/">https://command-not-found.com/</a> a try. See the
<a href="https://command-not-found.com/dig">entry for <code>dig</code></a> for instance.</li>
<li>this workaround is only required in containers we want to debug via xdebug</li>
</ul>
<h2><a id="wrapping-up"></a>Wrapping up</h2>
<p>Congratulations, you made it! If some things are not completely clear by now, don't hesitate to leave a comment.
Apart from that, you should now have a running docker setup for your local PHP development as well as a nice &quot;flow&quot;
to get started each day.</p>
<p>In the next part of this tutorial, we will add some more containers (php workers, mysql, redis, blackfire) and use
a fresh installation of Laravel to make use of them.</p>
<p>Please subscribe to the <a href="/feed.xml">RSS feed</a> or <a href="#newsletter">via email</a> to get automatic notifications when this next part comes out :)</p>]]></description>
                <pubDate>Mon, 20 May 2019 10:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/blog/structuring-the-docker-setup-for-php-projects/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/blog/structuring-the-docker-setup-for-php-projects/</guid>
            </item>
                    <item>
                <title>How to setup PhpStorm with Xdebug on Docker [Tutorial Part 2]</title>
                <description><![CDATA[<p>In the second part of this tutorial series on developing PHP on Docker we're taking a good hard look
at PhpStorm, Xdebug and how to run and debug scripts from within PhpStorm on Docker.</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/27KBaI24jKI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</div>
<h2>Published parts of the Docker PHP Tutorial</h2>
<ul>
<li><a href="/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/">Setting up PHP, PHP-FPM and NGINX for local development on Docker</a>
(2018-07-08)</li>
<li><a href="/blog/setup-phpstorm-with-xdebug-on-docker/">Setting up PhpStorm with Xdebug for local development on Docker</a>
(2018-08-06)</li>
<li><a href="/blog/structuring-the-docker-setup-for-php-projects/">Structuring the Docker setup for PHP Projects</a>
(2019-05-20)</li>
</ul>
<p>All code samples are publicly available in my
<a href="https://github.com/paslandau/docker-php-tutorial">Docker PHP Tutorial repository on github</a>.
The branch for this tutorial is
<a href="https://github.com/paslandau/docker-php-tutorial/tree/part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker">part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker</a>.</p>
<p><strong>Note</strong>: The setup that I am going to use is for demonstration purposes only! I do <strong>not</strong> recommend that you use it
&quot;as is&quot; as your development setup. Some problems that I won't solve here include:</p>
<ul>
<li>everything is owned by root (no dedicated user; that will in particular be problematic for linux users)</li>
<li>SSH login credentials are hard-coded in the container (inherently insecure)</li>
<li><code>host.docker.internal</code> will only exist for Windows and Mac users, NOT for unix users</li>
</ul>
<p>There will be a another part of this series that will deal with all of those (and some more common) problems and
aims at providing a consistent development environment for all developers in a team (regardless of the OS they are using).
Please subscribe to the <a href="http:///feed.xml">RSS feed</a> to get automatic notifications when that part comes out :)</p>
<h2>Table of contents</h2>
<ul>
<li><a href="#setup-the-docker-containers">Setup: The docker containers</a></li>
<li><a href="#run-php-via-built-in-docker-setup">Run PHP via built-in Docker setup</a><ul>
 <li><a href="#enable-docker-to-communicate-on-port%202375">Enable docker to communicate on port 2375</a></li>
 <li><a href="#configure-docker-server-in-phpstorm">Configure Docker Server in PhpStorm</a></li>
 <li><a href="#configure-docker-php-cli-interpreter">Configure Docker PHP CLI Interpreter</a></li>
 <li><a href="#run-debug-a-php-script-on-docker-server">Run/debug a php script on docker</a></li>
</ul></li>
<li><a href="#run-php-on-docker-via-deployment-configuration">Run PHP on Docker via Deployment Configuration</a><ul>
 <li><a href="#preparing-the-internal-container">Preparing the "workspace" container</a></li>
 <li><a href="#configure-the-deployment-configuration">Configure the Deployment Configuration</a></li>
 <li><a href="#run-debug-a-php-script-on-docker">Run/debug a php script on docker</a></li>
 <li><a href="#fix-xdebug-on-phpstorm-when-run-from-a-docker-container">Fix Xdebug on PhpStorm when run from a Docker container</a></li>
</ul></li>
</ul>
<h2><a id="setup-the-docker-containers"></a>Setup: The docker containers</h2>
<p>We will only need the php-cli container for this part.
Luckily, we already have a good understanding on how to create the container, although we'll need to make some
adjustments to make everything work smoothly with PhpStorm. I'm gonna walk you through all the necessary changes,
but I'd still recommend to clone the corresponding git repository <a href="https://github.com/paslandau/docker-php-tutorial">docker-php-tutorial</a>
(unless you've already done that in part 1), checkout branch <a href="https://github.com/paslandau/docker-php-tutorial/tree/part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker"><code>part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker</code></a> and
build the containers now.</p>
<p>As in part 1, I'm assuming your codebase lives at <code>/c/codesbase</code>:</p>
<pre><code>cd /c/codebase/
git clone https://github.com/paslandau/docker-php-tutorial.git
cd docker-php-tutorial
git checkout part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker
docker-compose build</code></pre>
<p>Further, make sure to open <code>/c/codebase/docker-php-tutorial</code> as a project in PhpStorm.</p>
<p>In general, there are two ways to run PHP from PhpStorm using Docker:</p>
<ol>
<li>via the built-in Docker setup</li>
<li>via Deployment Configuration (treating docker more or less like a VM)</li>
</ol>
<h2><a id="run-php-via-built-in-docker-setup"></a>Run PHP via built-in Docker setup</h2>
<p>This is the &quot;easier&quot; way and should mostly work &quot;out of the box&quot;. When you run a PHP script using this method, PhpStorm will start a
docker container and configure it automatically (path mappings, network setup, ...). Next, the script in question is executed and the container
is stopped afterwards.</p>
<h3><a id="enable-docker-to-communicate-on-port 2375"></a>Enable docker to communicate on port 2375</h3>
<p>Open the Docker Setting in tab &quot;General&quot; and activate the checkbox that says
&quot;Expose daemon on tcp://localhost:2375 without TLS&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-port-tcp-2375.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-port-tcp-2375.PNG" alt="Enable docker to communicate on port 2375" /></a></p>
<h3><a id="configure-docker-server-in-phpstorm"></a>Configure Docker Server in PhpStorm</h3>
<p>In PhpStorm, navigate to <code>File | Settings | Build, Execution, Deployment | Docker</code>. Fill out <code>Name</code> and <code>Engine API URL</code>:</p>
<ul>
<li>Name: Docker</li>
<li>Engine API URL: <code>tcp://localhost:2375</code></li>
</ul>
<p>PhpStorm will automatically validate your settings and show a &quot;Connection successful&quot; info below the path mappings box:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/php-built-in-docker-setup.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/php-built-in-docker-setup.PNG" alt="Configure Docker server in PhpStorm" /></a></p>
<h3><a id="configure-docker-php-cli-interpreter"></a>Configure Docker PHP CLI Interpreter</h3>
<p>Navigate to <code>File | Settings | Languages &amp; Frameworks | PHP</code>. Click on the three dots &quot;...&quot; next to &quot;CLI Interpreter&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter.PNG" alt="Setup CLI Interpreter PhpStorm" /></a></p>
<p>In the newly opened pop up click on the &quot;+&quot; sign on the top left and choose &quot;From Docker,Vagrant,VM,Remote...&quot;</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker.PNG" alt="New CLI Interpreter" /></a></p>
<p>Next, choose &quot;Docker&quot; from the radio buttons and select our previously created Docker server (named &quot;Docker&quot;).
As image, choose <code>docker-php-tutorial_docker-php-cli:latest</code> (which is one of the images used in this tutorial). If you don't see
this image you've probably not yet built the containers. In that case, please checkout the repo and build the containers: </p>
<pre><code>cd /c/codebase/
git clone https://github.com/paslandau/docker-php-tutorial.git
cd docker-php-tutorial
git checkout part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker
docker-compose build</code></pre>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker-php-cli.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker-php-cli.PNG" alt="New CLI Interpreter from Docker server" /></a></p>
<p>PhpStorm will now try to create the container and figure out if it can run PHP. If all goes well, you should see the following screenshot
with information about the PHP and Xdebug versions in the image/container.</p>
<p><em>Note</em>: Sometimes, this does not work immediately. If that's the case for you, try to click the &quot;Refresh&quot; icon next to &quot;PHP executable&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker-configured.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker-configured.PNG" alt="New CLI Interpreter from Docker configured" /></a></p>
<p>After you hit &quot;OK&quot;, you'll be back in the PHP Interpreter screen where our newly configured Docker interpreter should be already selected:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-done.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-done.PNG" alt="New CLI Interpreter from Docker chosen" /></a></p>
<p>Note that PhpStorm has automatically configured the path mappings as <code>-v</code> command line option for the Docker container. After hitting &quot;OK&quot;
one last time, everything is set up.</p>
<h3><a id="run-debug-a-php-script-on-docker-server"></a>Run/debug a php script on docker</h3>
<p>To verify that everything is working, open the file <code>app/hello-world.php</code> in PhpStorm, right click in the editor pane and choose &quot;Run&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-run-php-script.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-run-php-script.PNG" alt="Run PHP script" /></a></p>
<p>PhpStorm will start the configured container and run the script. The output is then visible at the bottom of the IDE:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/built-in-docker-run-php-script-finished.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/built-in-docker-run-php-script-finished.PNG" alt="PHP script output" /></a></p>
<p>Since we're using an image that has Xdebug installed, we can also set a breakpoint and use &quot;Debug&quot; instead of &quot;Run&quot; to trigger a debug session:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script.PNG" alt="Debug PHP script" /></a></p>
<p>PhpStorm should stop on the marked line. </p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script-breakpoint.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script-breakpoint.PNG" alt="Debug PHP script pausing" /></a></p>
<p>When you take a look at the &quot;Console&quot; panel at the bottom of the IDE, you should see something like this:</p>
<pre><code>docker://docker-php-tutorial_docker-php-cli:latest/php -dxdebug.remote_enable=1 -dxdebug.remote_mode=req -dxdebug.remote_port=9000 -dxdebug.remote_host=192.168.10.1 /opt/project/app/hello-world.php</code></pre>
<p>Please keep the <code>-dxdebug.remote_host=192.168.10.1</code> option in mind - this will be &quot;interesting&quot; when we set up a Docker-based PHP Interpreter
via Deployment Configuration ;)</p>
<p>PS: You find the official documentation for the built-in Docker support at
<a href="https://confluence.jetbrains.com/display/PhpStorm/Docker+Support+in+PhpStorm">Docker Support in PhpStorm</a>.</p>
<h2><a id="run-php-on-docker-via-deployment-configuration"></a>Run PHP on Docker via Deployment Configuration</h2>
<p>The previously explained method is nice, but it is lacking flexibility and it's also pretty slow as the container used to run
the script needs to be started each time we want to execute something. Luckily, there is an additional way of running PHP scripts
on Docker in PhpStorm, which is closely related to the Vagrant setup that I explained in
<a href="https://www.pascallandau.com/blog/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/#configuring-phpstorm-to-use-the-vagrant-box">Configuring PhpStorm to use the vagrant box</a>.</p>
<p>To make this work, we will keep a docker container running all the time and configure PhpStorm to connect to it via SSH. Thus, PhpStorm
effectively treats the docker container as any other remote host.</p>
<h3><a id="preparing-the-workspace-container"></a>Preparing the &quot;workspace&quot; container</h3>
<p>Please make sure to checkout my demo repository and switch to the correct branch first:</p>
<pre><code>cd /c/codebase/
git clone https://github.com/paslandau/docker-php-tutorial.git
cd docker-php-tutorial
git checkout part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker</code></pre>
<p>For now, we only need the <code>php-cli</code> container. In it, we need to setup the xdebug extension (already done and explained in the previous part) and
an SSH server so that we can log in via SSH. Let's take a look a the <code>Dockerfile</code>:</p>
<pre><code>FROM php:7.0-cli

RUN apt-get update -yqq \
 &amp;&amp; apt-get install -yqq \
    # install sshd
    openssh-server \
    # install ping and netcat (for debugging xdebug connectivity)
    iputils-ping netcat \
    # fix ssh start up bug
    # @see https://github.com/ansible/ansible-container/issues/141
 &amp;&amp; mkdir /var/run/sshd \
;

# add default public key to authorized_keys
COPY ./ssh/insecure_id_rsa.pub /root/insecure_id_rsa.pub
RUN mkdir -p /root/.ssh \
 &amp;&amp; cat /root/insecure_id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys \
 &amp;&amp; rm -rf /root/insecure_id_rsa.pub \
;

RUN pecl -q install xdebug-2.6.0 \
;
COPY ./conf.d/xdebug.ini /usr/local/etc/php/conf.d/xdebug.ini

# @see https://docs.docker.com/engine/examples/running_ssh_service/
CMD ["/usr/sbin/sshd", "-D"]
</code></pre>
<p>and the <code>docker-compose.yml</code>:</p>
<pre><code>  docker-php-cli:
    # define the directory where the build should happened,
    # i.e. where the Dockerfile of the service is located
    # all paths are relative to the location of docker-compose.yml
    build: 
      context: ./php-cli
    # make the SSH port available via port mapping
    ports:
      - "2222:22"
    # reserve a tty - otherwise the container shuts down immediately
    # corresponds to the "-i" flag
    tty: true
    # mount the app directory of the host to /var/www in the container
    # corresponds to the "-v" option
    volumes:
      - ./app:/var/www
    # connect to the network
    # corresponds to the "--network" option
    networks:
      - web-network</code></pre>
<p>There are four things to note:</p>
<ol>
<li>installing the server </li>
<li>adding the ssh keys to actually log in</li>
<li>changing the default <code>CMD</code> to keep the SSH daemon running</li>
<li>port- and volume mapping</li>
</ol>
<h4><a id="installing-the-server"></a>Installing the server</h4>
<p>The server installation is straight forward:</p>
<pre><code>apt-get install -yqq openssh-server</code></pre>
<p>the only none-intuitive thing is, that we need to &quot;manually&quot; create the directory <code>/var/run/sshd</code>
( <a href="https://github.com/ansible/ansible-container/issues/141">due to a bug</a> ).</p>
<h4><a id="adding-the-ssh-keys"></a>Adding the ssh keys</h4>
<p>For the ssh keys, I'm choosing the easy route (for now) and use a pre-generated ssh key pair (see <code>php-cli/ssh/*</code>).
The content of the public key is appended to <code>/root/.ssh/authorized_keys</code> so that I can log in to the container as user <code>root</code> using the
corresponding private key from <code>php-cli/ssh/insecure_id_rsa</code>.</p>
<p><strong>Caution</strong>: Of course, this is massively insecure! Those keys are part of the repository, making them available to everybody with access to the repo.
That makes sense for this publicly available tutorial (because everything works &quot;out of the box&quot; for everybody following along) but it is also one
of the reasons you should <strong>not</strong> use that repo as your <strong>actual</strong> development setup.</p>
<p>Again, there will be another part of this tutorial in which I'll present a solution to this problem (using volumes to share my local ssh keys with a
container and an <code>ENTRYPOINT</code> to put them in the right place).</p>
<h4><a id="keep-the-ssh-daemon-running"></a>Keep the SSH daemon running</h4>
<p>For SSH to work, we must start <code>sshd</code> and keep it running in the container. We achieve this by using <code>CMD ["/usr/sbin/sshd", "-D"]</code> in the
Dockerfile, following the official docker example to <a href="https://docs.docker.com/engine/examples/running_ssh_service/">Dockerize an SSH service</a>.</p>
<h4><a id="port-and-volume-mapping"></a>Port- and volume mapping</h4>
<p>Since docker containers do not have deterministic IP addresses, we map port 22 from the container to port 2222 on our host machine and we
further provide a path mapping from our local <code>./app</code> folder to <code>/var/www</code> in the container. Both pieces of information a required when
we configure PhpStorm later on.</p>
<p>Now that everything is in place, let's build and run the container:</p>
<pre><code>cd /c/codebase/docker-php-tutorial
docker-compose up -d docker-php-cli</code></pre>
<p>yielding</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /d/codebase/docker-php-tutorial (part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker)
$ docker-compose up -d docker-php-cli
Creating docker-php-tutorial_docker-php-cli_1 ... done</code></pre>
<p><em>Note</em>: One might argue, that it's kinda defeating the purpose of docker, when we now treat it as a VM, installing SSH and neglecting it's
&quot;one process per container&quot; rule. But honestly, I don't care about that when
it comes to my local development setup as my main goal is to have something lightweight, that is easily shareable with my team to have a
consistent infrastructure setup ;)</p>
<h3><a id="configure-the-deployment-configuration"></a>Configure the Deployment Configuration</h3>
<p>In PhpStorm, navigate to <code>File | Settings | Build, Execution, Deployment | Deployment</code>.
In the newly opened pop up click on the &quot;+&quot; sign on the top left and choose &quot;From Docker,Vagrant,VM,Remote...&quot; with:</p>
<ul>
<li>Name: Docker (SSH)</li>
<li>Type: SFTP</li>
</ul>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/new-deployment-configuration.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/new-deployment-configuration.PNG" alt="New SFTP Deployment Configuration" /></a></p>
<p>In the <code>Connection</code> tab, choose the following settings:</p>
<ul>
<li>SFTP host: 127.0.0.1</li>
<li>Port: 2222</li>
<li>User name: root</li>
<li>Auth type: Key pair (OpenSSH or PuTTY)</li>
<li>Private key file: <code>C:\codebase\docker-php-tutorial\php-cli\ssh\insecure_id_rsa</code></li>
</ul>
<p><em>Notes</em>:</p>
<ul>
<li>the &quot;Port&quot; corresponds to the port mapping that we defined in the <code>docker-compose.yml</code> file</li>
<li>the &quot;Private key file&quot; is the &quot;insecure&quot; ssh key that matches the public key we specified in the <code>php-cli/Dockerfile</code></li>
</ul>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-connection.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-connection.PNG" alt="Deployment Configuration: Connection" /></a></p>
<p>Hit the &quot;Test SFT connection...&quot; button to test the settings. You should see</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-connection-test.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-connection-test.PNG" alt="Deployment Configuration: Test Connection" /></a></p>
<p>(there might also appear a fingerprint warning because we're using 127.0.0.1 as host. You can simply ignore that warning).</p>
<p>Now choose the <code>Mappings</code> tab and fill it the fields as follows:</p>
<ul>
<li>Local path: <code>C:\codebase\docker-php-tutorial\app</code></li>
<li>Deployment path on server 'Docker (SSH)': <code>/var/www/</code></li>
</ul>
<p>Those mappings correspond to the volume definition for the <code>docker-php-cli</code> service in <code>docker-compose.yml</code>:</p>
<pre><code>[...]
    # mount the app directory of the host to /var/www in the container
    # corresponds to the "-v" option
    volumes:
      - ./app:/var/www
[...]</code></pre>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-path-mappings.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-path-mappings.PNG" alt="Deployment Configuration: Path Mappings" /></a></p>
<p>Next, we need to create a PHP Interpreter based on our newly created Deployment Configuration.
Open settings and navigate to <code>File | Settings | Languages &amp; Frameworks | PHP</code>. Click on the three dots &quot;...&quot; next to &quot;CLI Interpreter&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter.PNG" alt="Setup CLI Interpreter PhpStorm" /></a></p>
<p>In the newly opened pop up click on the &quot;+&quot; sign on the top left and choose &quot;From Docker,Vagrant,VM,Remote...&quot;</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker.PNG" alt="New CLI Interpreter" /></a></p>
<p>Choose &quot;Deployment Configuration&quot; from the radio buttons and select the &quot;Docker (SSH)&quot; entry. Please make sure to enter
<code>/usr/local/bin/php</code> as path for the PHP executable (as PhpStorm by default will set this path to <code>/usr/bin/php</code>).</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-deployment-configuration.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-deployment-configuration.PNG" alt="Setup Docker (SSH) Interpreter" /></a></p>
<p>Set &quot;Docker (SSH)&quot; as name for the new interpreter and click &quot;OK&quot;. </p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-docker-deployment-configuration.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-docker-deployment-configuration.PNG" alt="Finalize Docker (SSH) Interpreter" /></a></p>
<p>Confirm the new PHP Interpreter to close the settings dialog.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-deployment-configuration-done.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-deployment-configuration-done.PNG" alt="Confirm Deployment Configuration Interpreter" /></a></p>
<h3><a id="run-debug-a-php-script-on-docker"></a>Run/debug a php script on docker</h3>
<p>To verify that everything is working, open the file <code>app/hello-world.php</code> in PhpStorm, right click in the editor pane and choose &quot;Run&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-run-php-script.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-run-php-script.PNG" alt="Run PHP script" /></a></p>
<p>PhpStorm will start the configured container and run the script. The output is then visible in at the bottom of the IDE:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-ssh-run-php-script-finished.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-ssh-run-php-script-finished.PNG" alt="PHP script output when run via SFTP" /></a></p>
<p>Since we're using an image that has Xdebug installed, we can also set a breakpoint and use &quot;Debug&quot; instead of &quot;Run&quot; to trigger a debug session:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script.PNG" alt="Debug PHP script" /></a></p>
<p>Hm weird... Although this worked flawlessly when we used the built-in functionality, it does not when we use the Deployment Configuration and shows
a &quot;Connection with 'Xdebug 2.6.0' not established.&quot; error.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/failing-xdebug-connection.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/failing-xdebug-connection.PNG" alt="Xdebug connection cannot be established error" /></a></p>
<h3><a id="fix-xdebug-on-phpstorm-when-run-from-a-docker-container"></a>Fix Xdebug on PhpStorm when run from a Docker container</h3>
<p>Long story short: There is a bug in the networking setup of Docker for Win that makes PhpStorm use the wrong <code>remote_host</code> when it starts a
debugging session. When you take a look at the &quot;Console&quot; panel at the bottom of the IDE, you should see something like this:</p>
<pre><code>sftp://root@127.0.0.1:2222/usr/local/bin/php -dxdebug.remote_enable=1 -dxdebug.remote_mode=req -dxdebug.remote_port=9000 -dxdebug.remote_host=172.18.0.1 /var/www/hello-world.php</code></pre>
<p>The <code>-dxdebug.remote_host=172.18.0.1</code> option is our suspect here. Luckily, since
<a href="https://docs.docker.com/docker-for-windows/networking/#use-cases-and-workarounds">Docker v18.03</a> there is a &quot;magic&quot; DNS entry called `host.docker.internal
that we can use to reach the host from a container.</p>
<p>So, how can we solve this? PhpStorm enables us to
<a href="https://www.jetbrains.com/help/phpstorm/configuring-xdebug.html#d165872e407">pass custom options to Xdebug</a> when a debugging session is initiated.
Open <code>File | Settings | Languages &amp; Frameworks | PHP</code> and click on the &quot;...&quot; next to &quot;PHP Interpreter&quot; to bring up the interpreters. Choose
&quot;Docker (SSH)&quot; in the left pane and click on the little folder icon on the bottom of the window next to &quot;Configuration options&quot;. In the pop up enter
<code>xdebug.remote_host</code> as key and <code>host.docker.internal</code> as value and hit &quot;OK&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/xdebug-options.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/xdebug-options.PNG" alt="Configure Xdebug options" /></a></p>
<p>This results in the configuration setting <code>-dxdebug.remote_host=host.docker.internal</code> that is now appended to the remaining (default) arguments
that PhpStorm uses and will <strong>override</strong> any existing options (including the incorrect <code>xdebug.remote_host</code>).</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/xdebug-options-configured.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/xdebug-options-configured.PNG" alt="Configured Xdebug options" /></a></p>
<p>Initiating a debug session on <code>app/hello-world.php</code> will now finally stop the execution as expected and the
&quot;Console&quot; panel at the bottom of the IDE, shows</p>
<pre><code>sftp://root@127.0.0.1:2222/usr/local/bin/php -dxdebug.remote_enable=1 -dxdebug.remote_mode=req -dxdebug.remote_port=9000 -dxdebug.remote_host=172.18.0.1 -dxdebug.remote_host=host.docker.internal /var/www/hello-world.php</code></pre>
<p>This setup denotes the end of the second tutorial. In the next part we will take a <strong>much</strong> deeper look into Xdebug to fully understand how it works
(especially in combination with PhpStorm), how to fix common problems and make it work in different scenarios (debugging from the browser, from php workers, etc.).</p>]]></description>
                <pubDate>Mon, 06 Aug 2018 12:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/blog/setup-phpstorm-with-xdebug-on-docker/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/blog/setup-phpstorm-with-xdebug-on-docker/</guid>
            </item>
                    <item>
                <title>How to setup PHP, PHP-FPM and NGINX on Docker in Windows 10 [Tutorial Part 1]</title>
                <description><![CDATA[<p>You probably heard from the new kid around the block called &quot;Docker&quot;?
You are a PHP developer and would like to get into that, but you didn't have the time to look into it, yet?
Then this tutorial is for you! By the end of it, you should know:</p>
<ul>
<li>how to setup Docker &quot;natively&quot; on a Windows 10 machine</li>
<li>how to build and run containers from the command line</li>
<li>how to log into containers and explore them for information</li>
<li>what a Dockerfile is and how to use it</li>
<li>how containers can talk to each other</li>
<li>how <code>docker-compose</code> can be used to fit everything nicely together</li>
</ul>
<p><strong>Note</strong>: I will not only walk on the happy path during this tutorial. That means I'll deep-dive into
some things that are not completely related to docker (e.g. how to find out where the configuration
files for php-fpm are located), but that are imho important to understand, because they enable you to
solve problems later on your own. </p>
<p>But if you are short on time, you might also jump directly to <a href="#tl-dr">the tl;dr</a>.</p>
<h2>Published parts of the Docker PHP Tutorial</h2>
<ul>
<li><a href="/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/">Setting up PHP, PHP-FPM and NGINX for local development on Docker</a>
(2018-07-08)</li>
<li><a href="/blog/setup-phpstorm-with-xdebug-on-docker/">Setting up PhpStorm with Xdebug for local development on Docker</a>
(2018-08-06)</li>
<li><a href="/blog/structuring-the-docker-setup-for-php-projects/">Structuring the Docker setup for PHP Projects</a>
(2019-05-20)</li>
</ul>
<p>This is the first part of a (probably) multi-part series on Docker. The second part explains how
to <a href="/blog/setup-phpstorm-with-xdebug-on-docker">set up PHP in Docker containers in order to work nicely with PHPStorm when using XDebug</a>.</p>
<h2>Table of contents</h2>
<ul>
<li><a id="introduction">Introduction</a>
    <ul>
    <li><a href="#precondiction">Preconditions</a></li>
    <li><a href="#why-use-docker">Why use Docker?</a></li>
    <li><a href="#transition-vagrant">Transition from Vagrant</a></li>
    </ul>
</li>
<li><a href="#setup-docker">Setup Docker</a>    
</li><li><a href="#setup-php-cli">Setting up the PHP cli container</a>
    <ul>
        <li><a href="#xdebug-php">Installing Xdebug in the PHP container</a></li>
        <li><a href="#dockerfile">Persisting image changes with a Dockerfile</a></li>
    </ul>
</li> 
<li><a href="#webstack">Setting up a web stack with php-fpm and nginx</a>
    <ul>
        <li><a href="#setup-nginx">Setting up nginx</a></li>
        <li><a href="#setup-php-fpm">Setting up php-fpm</a>
            <ul>
                <li><a href="#php-fpm-xdebug">Installing xdebug</a></li>
            </ul>
        </li> 
        <li><a href="#connecting-nginx-php-fpm">Connecting nginx and php-fpm</a></li>
    </ul>
</li> 
<li><a href="#docker-compose">Putting it all together: Meet docker-compose</a></li>
<li><a href="#tl-dr">The tl;dr</a></li>
</ul>
<h2><a id="introduction"></a>Introduction</h2>
<h3><a id="precondiction"></a>Preconditions</h3>
<p>I'm assuming that you have installed <a href="https://git-scm.com/download/win">Git bash for Windows</a>. If not, please do that before,
see <a href="http://www.pascallandau.com/blog/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/#git-and-git-bash">Setting up the software: Git and Git Bash</a>.</p>
<h3><a id="why-use-docker"></a>Why use Docker?</h3>
<p>I won't go into too much detail what Docker is and why you should use it, because
<a href="https://www.linode.com/docs/applications/containers/when-and-why-to-use-docker/">others</a>
<a href="https://www.zdnet.com/article/what-is-docker-and-why-is-it-so-darn-popular/">have</a>
<a href="https://stackoverflow.com/questions/16647069/should-i-use-vagrant-or-docker-for-creating-an-isolated-environment">already</a>
talked about this extensively.</p>
<p>As for me, my main reasons were</p>
<ul>
<li>Symlinks in vagrant didn't work the way they should</li>
<li>VMs become bloated and hard to manage over time</li>
<li>Setup in the team involved a lot of work</li>
<li>I wanted to learn Docker for quite some time because you hear a lot about it</li>
</ul>
<p>In general, Docker is kind of like a virtual machine, so it allows us to develop in an OS of our choice (e.g. Windows)
but run the code in the same environment as it will in production (e.g. on a linux server). Thanks to its core principles,
it makes the separation of services really easy (e.g. having a dedicated server for your database) which - again -
is something that should happen on production anyway.</p>
<h3><a id="transition-vagrant"></a>Transition from Vagrant</h3>
<p>On Windows, you can either use the <a href="https://docs.docker.com/toolbox/toolbox_install_windows/">Docker Toolbox</a>
(which is essentially a VM with Docker setup on it) or the Hyper-V based <a href="https://www.docker.com/docker-windows">Docker for Windows</a>.
This tutorial will only look at the latter.</p>
<p><strong>A word of caution</strong>: Unfortunately, we cannot have other Gods besides Docker (on Windows).
The native Docker client requires Hyper-V to be activated which in turn will cause Virtualbox to not work any longer.
Thus, we will not be able to use Vagrant and Docker alongside each other.
This was actually the main reason it took me so long to start working with Docker.</p>
<h2><a id="setup-docker"></a>Setup Docker</h2>
<p>First, <a href="https://store.docker.com/editions/community/docker-ce-desktop-windows">download Docker for Windows</a>
(requires Microsoft Windows 10 Professional or Enterprise 64-bit). The version I am using in this tutorial is <code>18.03.1-ce-win65</code>.
During the installation,
leave the option &quot;Use Windows Containers instead of Linux containers&quot; unticked as we intend to develop on linux containers
(you can change it later anyway).</p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/use-linux-containers.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/use-linux-containers.PNG" alt="Install docker" /></a></p>
<p>After the installation finishes, we need to log out of Windows and in again.
Docker should start automatically. If not, there should be a &quot;Docker for Windows&quot; icon placed on your desktop.
If Hyper-V is not activated yet, Docker will automatically urge you to do so now.</p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/enable-hyper-v-and-containers.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/enable-hyper-v-and-containers.PNG" alt="Activate Hype-V" /></a></p>
<p>If you agree, Hyper-V and container features are activated and a reboot is initiated.
See <a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v">Install Hyper-V on Windows 10</a>
to deactivate it again.</p>
<p><strong>Caution</strong>: VirtualBox will stop working afterwards! Starting one of my previous machines from the VirtualBox interface
or via <code>vagrant up</code> fails with the error message</p>
<blockquote>
<p>VT-x is not available (VERR_VMX_NO_VMX)</p>
</blockquote>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/virtual-box-error.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/virtual-box-error.PNG" alt="Virtual box error" /></a>
<a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/vagrant-error.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/vagrant-error.PNG" alt="Vagrant error" /></a></p>
<p>After rebooting, Docker will start automatically and a welcome screen appears.</p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/welcome-screen.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/welcome-screen.PNG" alt="Docker welcome screen" /></a></p>
<p>We can ignore that (close the window).
In addition, a new icon is added to your system tray. A right-click reveals the context menu. </p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/system-tray-icon.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/system-tray-icon.PNG" alt="Docker settings in system tray" /></a></p>
<p>Open the tab &quot;Shared Devices&quot; and tick the hard drives on your host machine that you want to share with Docker containers. </p>
<p><em>Note: We will still need to define explicit path mappings for the actual containers later on, but the hard drive that the path belongs
to must be made available here. After clicking &quot;Apply&quot;, you will be prompted for your credentials</em></p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-shared-drives.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-shared-drives.PNG" alt="Docker settings: Shared devices" /></a>
<a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-shared-drives-credentials.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-shared-drives-credentials.PNG" alt="Docker settings: Credential prompt" /></a></p>
<p>Next, open tab &quot;Advanced&quot;. You don't actually have to change any of the settings but if you (like me)
don't have <code>C:/</code> set up as you biggest partition, you might want to change the &quot;Disk image location&quot;.
I'm putting mine at <code>C:\Hyper-V\Virtual Hard Disks\MobyLinuxVM.vhdx</code>. It might take some minutes for Docker to process the changes.</p>
<p>Docker &quot;physically&quot; stores the container images in that location.</p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-advanced-disk-image-location.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/install-docker/settings-advanced-disk-image-location.PNG" alt="Docker settings: Advanced" /></a></p>
<p>Congratulations, Docker is now set up on your machine 😊</p>
<h2><a id="setup-php-cli"></a>Setting up the PHP cli container</h2>
<p>Now that we have the general stuff out of the way, let's set up our first container.
I've created the directory <code>C:/codebase/docker-php/</code> and will run the remaining examples in there. </p>
<p>Firstly, lets create a directory for our sourcecode:</p>
<pre><code>mkdir -p "C:/codebase/docker-php/app"</code></pre>
<p>For the sake of simplicity, we will stick to the <a href="https://hub.docker.com/_/php/">official PHP image</a> and run:</p>
<pre><code>docker run -d --name docker-php -v "C:/codebase/docker-php/app":/var/www php:7.0-cli</code></pre>
<p>Which means:</p>
<pre><code>docker run                               // run a container
-d                                       // in the background (detached)
--name docker-php                        // named docker-php
-v "C:/codebase/docker-php/app":/var/www // sync the directory C:/codebase/docker-php/app on the 
                                         // windows host with /var/www in the container
php:7.0-cli                              // use this image to build the container</code></pre>
<p>The result looks something like this:</p>
<pre><code>$ docker run -d --name docker-php -v "C:/codebase/docker-php/app":/var/www php:7.0-cli
Unable to find image 'php:7.0-cli' locally
7.0-cli: Pulling from library/php
f2aa67a397c4: Pulling fs layer
c533bdb78a46: Pulling fs layer
65a7293804ac: Pulling fs layer
35a9c1f94aea: Pulling fs layer
54cffc62e1c2: Pulling fs layer
153ff2f4c2af: Pulling fs layer
96d392f71f56: Pulling fs layer
e8c43e665458: Pulling fs layer
35a9c1f94aea: Waiting
54cffc62e1c2: Waiting
153ff2f4c2af: Waiting
96d392f71f56: Waiting
e8c43e665458: Waiting
c533bdb78a46: Verifying Checksum
c533bdb78a46: Download complete
35a9c1f94aea: Verifying Checksum
35a9c1f94aea: Download complete
f2aa67a397c4: Verifying Checksum
f2aa67a397c4: Download complete
153ff2f4c2af: Verifying Checksum
153ff2f4c2af: Download complete
54cffc62e1c2: Verifying Checksum
54cffc62e1c2: Download complete
e8c43e665458: Verifying Checksum
e8c43e665458: Download complete
96d392f71f56: Verifying Checksum
96d392f71f56: Download complete
f2aa67a397c4: Pull complete
65a7293804ac: Verifying Checksum
65a7293804ac: Download complete
c533bdb78a46: Pull complete
65a7293804ac: Pull complete
35a9c1f94aea: Pull complete
54cffc62e1c2: Pull complete
153ff2f4c2af: Pull complete
96d392f71f56: Pull complete
e8c43e665458: Pull complete
Digest: sha256:ff6c5e695a931f18a5b59c82b1045edea42203a299e89a554ebcd723df8b9014
Status: Downloaded newer image for php:7.0-cli
56af890e1a61f8ffa5528b040756dc62a94c0b929c29df82b9bf5dec6255321f</code></pre>
<p>Since we don't have the image on our machine (see <code>Unable to find image 'php:7.0-cli' locally</code>),
Docker attempts to pull it from the official registry at <a href="https://hub.docker.com/">https://hub.docker.com/</a>.
We've specifically chosen the &quot;7.0-cli&quot; version of the PHP image (which means: PHP 7.0 CLI only).
See <a href="https://hub.docker.com/_/php/">https://hub.docker.com/_/php/</a> for a list of all available tags/images.</p>
<p>Now let's see if the container is actually running via <code>docker ps</code></p>
<pre><code>$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</code></pre>
<p>Weird. For some reason, we don't see our newly created container there. Let's check with the <code>-a</code> flag to list <strong>all</strong> containers,
even the ones that are not running.</p>
<pre><code>$ docker ps -a
CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS                      PORTS               NAMES
56af890e1a61        php:7.0-cli         "docker-php-entrypoi…"   27 seconds ago     Exited (0) 25 seconds ago                       docker-php</code></pre>
<p>Aha. So the container was created, but immediately stopped (see <code>Created 27 seconds ago; Exited (0) 25 seconds ago</code>).
That's because a container only <a href="https://stackoverflow.com/a/28214133/413531">lives as long as it's main process is running</a>.
According to <a href="https://docs.docker.com/config/containers/multi-service_container/">the docs</a>,</p>
<blockquote>
<p>A container's main running process is the ENTRYPOINT and/or CMD at the end of the Dockerfile.&quot; </p>
</blockquote>
<p><a href="https://stackoverflow.com/a/21564990/413531">This answer explains the difference between CMD and ENTRYPOINT</a> quite well.
Since we don't have a Dockerfile defined, we would need to look at the
<a href="https://github.com/docker-library/php/blob/27c65bbd606d1745765b89bf43f39b06efad1e43/7.0/stretch/cli/Dockerfile">Dockerfile of the base image</a>
we're using, but I actually don't wanna go down this rabbit hole for now. Basically, the &quot;problem&quot; is, that the
container doesn't have a long running process / service defined, (as the php-fpm or the nginx containers do later on).
To keep the container alive, we need to add the <code>-i</code> flag to the <code>docker run</code> command:</p>
<pre><code>docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www php:7.0-cli</code></pre>
<p>But then this happens:</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /
$ docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www php:7.0-cli
C:\Program Files\Docker\Docker\Resources\bin\docker.exe: Error response from daemon: Conflict. The container name "/docker-php" is already in use by container "56af890e1a61f8ffa5528b040756dc62a94c0b929c29df82b9bf5dec6255321f". You have to remove (or rename) that container to be able to reuse that name.
See 'C:\Program Files\Docker\Docker\Resources\bin\docker.exe run --help'.</code></pre>
<p>Apparently, we cannot use the same name (<code>docker-php</code>) again. Bummer. So, let's remove the previous container first via </p>
<pre><code>docker rm docker-php</code></pre>
<p>and try again afterwards:</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /
$ docker rm docker-php
docker-php

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www php:7.0-cli
7b3024a542a2d25fd36cef96f4ea689ec7ebb758818758300097a7be3ad2c2f6

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker ps
CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS              PORTS               NAMES
7b3024a542a2        php:7.0-cli         "docker-php-entrypoi…"   5 seconds ago      Up 4 seconds                            docker-php</code></pre>
<p>Sweet, so now that the container is up and running, let's &quot;<a href="https://stackoverflow.com/a/30173220">log in</a>&quot; via </p>
<pre><code>docker exec -it docker-php bash</code></pre>
<p>You might get the following error message</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker exec -it docker-php bash
the input device is not a TTY.  If you are using mintty, try prefixing the command with 'winpty'</code></pre>
<p>If so, prefixing the command with <code>winpty</code> should help:</p>
<pre><code>winpty docker exec -it docker-php bash</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ winpty docker exec -it docker-php bash
root@7b3024a542a2:/#</code></pre>
<p>A quick <code>php -v</code> within the container verifies, that we can actually run php scripts in there:</p>
<pre><code>root@7b3024a542a2:/# php -v
PHP 7.0.30 (cli) (built: May 23 2018 23:04:32) ( NTS )
Copyright (c) 1997-2017 The PHP Group
Zend Engine v3.0.0, Copyright (c) 1998-2017 Zend Technologies</code></pre>
<p>Remember the path mapping, that we specified? Let's create a simple &quot;hello world&quot; script <strong>on the windows 10 host machine</strong>
at <code>C:\codebase\docker-php\app\hello-world.php</code> to make sure it works:</p>
<pre><code>cd "C:\codebase\docker-php\app"
echo '&lt;?php echo "Hello World (php)\n"; ?&gt;' &gt; hello-world.php</code></pre>
<p>Should look like this on the host machine:</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ ls -alh app
total 1,0K
drwxr-xr-x 1 Pascal 197121  0 Mai 28 12:29 ./
drwxr-xr-x 1 Pascal 197121  0 Mai 28 11:46 ../
-rw-r--r-- 1 Pascal 197121 49 Mai 28 12:30 hello-world.php</code></pre>
<p>And like this from within the container:</p>
<pre><code>root@7b3024a542a2:/# ls -alh /var/www
total 4.5K
drwxr-xr-x 2 root root  0 May 28 10:29 .
drwxr-xr-x 1 root root 4.0K May 28 10:00 ..
-rwxr-xr-x 1 root root   31 May 28 10:31 hello-world.php</code></pre>
<p>Let's run the script <strong>in the container</strong> via </p>
<pre><code>php /var/www/hello-world.php</code></pre>
<pre><code>root@7b3024a542a2:/# php /var/www/hello-world.php
Hello World</code></pre>
<p>Purrfect. We created the file on our host system and it's automatically available in the container. </p>
<h3><a id="xdebug-php"></a>Installing Xdebug in the PHP container</h3>
<p>Since we intend to use Docker for our local development setup, the ability to debug is mandatory. So let's extend our image with the xdebug extension.
The readme of the official Docker PHP repository does a good job at explaining
<a href="https://github.com/docker-library/docs/blob/master/php/README.md#how-to-install-more-php-extensions">how to install extensions</a>.
For xdebug, we'll use PECL. To install the extension, make sure to be logged into the container and run </p>
<pre><code>pecl install xdebug-2.6.0</code></pre>
<p>You should see an output like this:</p>
<pre><code>root@7b3024a542a2:/# pecl install xdebug-2.6.0
[...]
Build process completed successfully
Installing '/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so'
install ok: channel://pecl.php.net/xdebug-2.6.0
configuration option "php_ini" is not set to php.ini location
You should add "zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so" to php.ini</code></pre>
<p>The xdebug extension has been build and saved in <code>/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so</code>.
To actually activate it, run </p>
<pre><code>docker-php-ext-enable xdebug</code></pre>
<p>That helper command will place the file <code>docker-php-ext-xdebug.ini</code> in the directory for additional php ini files with the content</p>
<pre><code>zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so</code></pre>
<p>which enables the extension. Btw. you can locate the additional php ini files folder by running </p>
<pre><code>php -i | grep "additional .ini"</code></pre>
<p>Result:</p>
<pre><code>root@7b3024a542a2:/# php -i | grep "additional .ini"
Scan this dir for additional .ini files =&gt; /usr/local/etc/php/conf.d</code></pre>
<p>When we check the contents of that folder, we will indeed find the <code>xdebug.ini</code> file with the before mentioned content and <code>php -m</code> reveals,
that xdebug is actually active.</p>
<pre><code>root@7b3024a542a2:/# ls -alh /usr/local/etc/php/conf.d
total 12K
drwxr-sr-x 1 root staff 4.0K May 28 13:30 .
drwxr-sr-x 1 root staff 4.0K Apr 30 20:34 ..
-rw-r--r-- 1 root staff   81 May 28 13:30 docker-php-ext-xdebug.ini
root@7b3024a542a2:/# cat /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini
zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so
root@7b3024a542a2:/# php -m | grep xdebug
xdebug</code></pre>
<p>Now we'll log out of the container (type &quot;exit&quot; or hit <code>CTRL</code> +<code>D</code>) and stop the container via </p>
<pre><code>docker stop docker-php</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker stop docker-php
docker-php

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker ps -a
CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS                      PORTS               NAMES
7b3024a542a2        php:7.0-cli         "docker-php-entrypoi…"   2 hours ago        Exited (137) 7 seconds ago                      docker-php</code></pre>
<p>Now we start the container again via </p>
<pre><code>docker start docker-php</code></pre>
<p>log back in and check if xdebug is still there:</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker start docker-php
docker-php

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ winpty docker exec -it docker-php bash
root@7b3024a542a2:/# php -m | grep xdebug
xdebug</code></pre>
<p>And... it is! So the changes we made &quot;survived&quot; a restart of the container. But: They won't survive a &quot;rebuild&quot; of the container.
First we stop and remove the container via </p>
<pre><code>docker rm -f docker-php</code></pre>
<p>The <code>-f</code> flag forces the container to stop. Otherwise we would need an additional <code>docker stop docker-php</code> before.</p>
<p>Then we rebuild it, log in</p>
<pre><code>docker run -di --name docker-php -v "C:/codebase/docker-php/":/codebase php:7.0-cli
inpty docker exec -it docker-php bash</code></pre>
<p>and check for xdebug:</p>
<pre><code>php -m | grep xdebug</code></pre>
<p>... which won't be there anymore.</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker rm -f docker-php
docker-php

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker run -di --name docker-php -v "C:/codebase/docker-php/":/codebase php:7.0-cli
1da17524418f5327760eb113904b7ceec30f22b41e4b4bd77f9fa2f7b92b4ead

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ winpty docker exec -it docker-php bash
root@1da17524418f:/# php -m | grep xdebug
root@1da17524418f:/#</code></pre>
<p>Note the new container ID (before: <code>7b3024a542a2</code>; now: <code>1da17524418f</code>) and that <code>php -m | grep xdebug</code> doesn't yield anything.</p>
<h3><a id="dockerfile"></a>Persisting image changes with a Dockerfile</h3>
<p>Simply put, a <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile</a> describes the changes we make to a base image,
so we (and everybody else) can easily recreate the same environment. In our case,
we need to define the PHP base image that we used as well as instructions for installing and enabling xdebug.
To clearly separate infrastructure from code, we'll create a new directory at <code>C:/codebase/docker-php/php-cli/</code>.
Create a file named <code>Dockerfile</code> in this directory</p>
<pre><code>mkdir "C:/codebase/docker-php/php-cli/"
touch "C:/codebase/docker-php/php-cli/Dockerfile"</code></pre>
<p>and give it the following content:</p>
<pre><code>FROM php:7.0-cli
RUN pecl install xdebug-2.6.0 \
    &amp;&amp; docker-php-ext-enable xdebug</code></pre>
<p>Change to the <code>C:/codebase/docker-php/php-cli/</code> directory and build the image based on that Dockerfile</p>
<pre><code>cd "C:/codebase/docker-php/php-cli/"
docker build -t docker-php-image -f Dockerfile .</code></pre>
<p>The <code>-f Dockerfile</code> is actually optional as this is the default anyway. &quot;docker-php-image&quot; is the name of our new image. </p>
<p>If you encounter the following error </p>
<pre><code>"docker build" requires exactly 1 argument.
See 'docker build --help'.

Usage:  docker build [OPTIONS] PATH | URL | - [flags]

Build an image from a Dockerfile</code></pre>
<p>you probably missed the trailing <code>.</code> at the end of <code>docker build -t docker-php-image -f Dockerfile .</code> ;)</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker build -t docker-php-image -f Dockerfile .
Sending build context to Docker daemon   5.12kB
Step 1/2 : FROM php:7.0-cli
 ---&gt; da771ba4e565
Step 2/2 : RUN pecl install xdebug-2.6.0    &amp;&amp; docker-php-ext-enable xdebug
 ---&gt; Running in ff16ef56e648
downloading xdebug-2.6.0.tgz ...
Starting to download xdebug-2.6.0.tgz (283,644 bytes)
[...]
You should add "zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so" to php.ini
Removing intermediate container ff16ef56e648
 ---&gt; 12be27256b12
Successfully built 12be27256b12
Successfully tagged docker-php-image:latest
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have '-rwxr-xr-x' permissions. It is recommended to double check and reset permissions for sensitive files and directories.</code></pre>
<p>Note, that the building takes longer than before, because Docker now needs to do the extra work of installing xdebug.
Instead of using the base <code>php:7.0-cli</code> image, we'll now use our new, shiny <code>docker-php-image</code> image to start the container and check for xdebug.</p>
<pre><code>docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www docker-php-image</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www docker-php-image
C:\Program Files\Docker\Docker\Resources\bin\docker.exe: Error response from daemon: Conflict. The container name "/docker-php" is already in use by container "2e84cb536fc573142a9951331b16393e3028d9c6eff87f89cfda682279634a2b". You have to remove (or rename) that container to be able to reuse that name.
See 'C:\Program Files\Docker\Docker\Resources\bin\docker.exe run --help'.</code></pre>
<p>Aaaand we get an error, because we tried to use the same name (&quot;docker-php&quot;), that we used for the previous, still running container.
Sigh.. fortunately we already know how to solve that via</p>
<pre><code>docker rm -f docker-php</code></pre>
<p>Retry </p>
<pre><code>docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www docker-php-image</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker rm -f docker-php
docker-php

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker run -di --name docker-php -v "C:/codebase/docker-php/app":/var/www docker-php-image
f27cc1310c836b15b7062e1fd381f283250a85133fb379c4cf1f891dec63770b

Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ winpty docker exec -it docker-php bash
root@f27cc1310c83:/# php -m | grep xdebug
xdebug</code></pre>
<p>Yep, all good. Btw. since we &quot;only&quot; want to check if xdebug was installed, we could also simply pass <code>-m</code> to the <code>docker run</code> command:</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker run docker-php-image php -m | grep xdebug
xdebug</code></pre>
<p>Be aware that this will create a new container every time it's run (, note the first entry with the wonderful name &quot;distracted_mclean&quot;):</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker ps -a
CONTAINER ID        IMAGE               COMMAND                 CREATED             STATUS                      PORTS               NAMES
abc9fec8a88b        docker-php-image    "docker-php-entrypoi…"   4 minutes ago      Exited (0) 4 minutes ago                        distracted_mclean
f27cc1310c83        docker-php-image    "docker-php-entrypoi…"   10 minutes ago     Exited (137) 6 minutes ago                      docker-php</code></pre>
<p>Before we move on, let's []stop and remove all containers via](<a href="https://coderwall.com/p/ewk0mq/stop-remove-all-docker-containers">https://coderwall.com/p/ewk0mq/stop-remove-all-docker-containers</a>).</p>
<pre><code>docker rm -f $(docker ps -aq)</code></pre>
<p>The <code>$(docker ps -aq)</code> part returns only the numeric ids of all containers and passes them to the <code>docker rm -f</code> command.</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-cli
$ docker rm -f $(docker ps -aq)
abc9fec8a88b
f27cc1310c83</code></pre>
<h2><a id="webstack"></a>Setting up a web stack with php-fpm and nginx</h2>
<p>Since most people are probably not only working on CLI scripts but rather on web pages,
the next step in this tutorial is about setting up an nginx web server and connect it to php-fpm.</p>
<h3><a id="setup-nginx"></a>Setting up nginx</h3>
<p>We're gonna use the <a href="https://hub.docker.com/_/nginx/">official nginx image</a> and since we don't know anything about that image yet,
let's run and explore it a bit:</p>
<pre><code>docker run -di nginx:latest</code></pre>
<p>yields</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /
$ docker run -di nginx:latest
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
[...]
Status: Downloaded newer image for nginx:latest
15c6b8d8a2bff873f353d24dc9c40d3008da9396029b3f1d9db7caeebedd3f50</code></pre>
<p>Note that we only used the minimum number of arguments here. Since we did not specify a name, we will simply use the ID instead to log in
(so be sure to use the one that your shell returned - don't just copy the line below :P)</p>
<pre><code>$ winpty docker exec -it 15c6b8d8a2bff873f353d24dc9c40d3008da9396029b3f1d9db7caeebedd3f50 bash
root@15c6b8d8a2bf:/#</code></pre>
<p>We would expect that there is an nginx process running, but upon checking with <code>ps aux</code> we get </p>
<pre><code>bash: ps: command not found" as a response. </code></pre>
<p>This is common when using docker images, because they are usually kept as minimal as possible.
Although this is a good practice in production, it is kind of cumbersome in development.
So, let's install <code>ps</code> via </p>
<pre><code>apt-get update &amp;&amp; apt-get install -y procps</code></pre>
<p>and try again:</p>
<pre><code>root@15c6b8d8a2bf:/# apt-get update &amp;&amp; apt-get install -y procps
Get:1 http://security.debian.org/debian-security stretch/updates InRelease [94.3 kB]
[...] 
associated file /usr/share/man/man1/w.procps.1.gz (of link group w) doesn't exist
Processing triggers for libc-bin (2.24-11+deb9u3) ...
root@15c6b8d8a2bf:/# ps aux
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root          1  0.0  0.2  32608  5148 ?        Ss   06:46   0:00 nginx: master process nginx -g daemon off;
nginx         5  0.0  0.1  33084  2388 ?        S    06:46   0:00 nginx: worker process
root         14  0.0  0.1  18132  3272 pts/0    Ss   06:50   0:00 bash
root        259  0.0  0.1  36636  2844 pts/0    R+   06:53   0:00 ps aux
root@15c6b8d8a2bf:/#</code></pre>
<p>Ah. Much better. Lets dig a little deeper and see how the process is configured via <code>nginx -V</code></p>
<pre><code>root@15c6b8d8a2bf:/# nginx -V
nginx version: nginx/1.13.12
built by gcc 6.3.0 20170516 (Debian 6.3.0-18+deb9u1)
built with OpenSSL 1.1.0f  25 May 2017
TLS SNI support enabled
configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/ng
inx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path
=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-
http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module
 --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_
module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt='-g -O2 -fdebug-prefix-map=/data/builder/debuild/nginx-1.13.12/debian/debuild-base/nginx-
1.13.12=. -specs=/usr/share/dpkg/no-pie-compile.specs -fstack-protector-strong -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fPIC' --with-ld-opt='-specs=/usr/share/dpkg/no-pie-link.specs -Wl,-z,relr
o -Wl,-z,now -Wl,--as-needed -pie'</code></pre>
<p>Sweet, so the configuration file is placed in the default location at <code>/etc/nginx/nginx.conf</code>
(see <code>--conf-path=/etc/nginx/nginx.conf</code>). Checking that file will show us, where we need to place additional config files
(e.g. for the configuration of our web site). Run</p>
<pre><code>cat /etc/nginx/nginx.conf</code></pre>
<p>... and see</p>
<pre><code>root@15c6b8d8a2bf:/# cat /etc/nginx/nginx.conf

user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}</code></pre>
<p>Note the line <code>include /etc/nginx/conf.d/*.conf</code> at the end of the file. In this directory, we'll find the default nginx config:</p>
<pre><code>ls -alh /etc/nginx/conf.d/
cat /etc/nginx/conf.d/default.conf</code></pre>
<pre><code>root@15c6b8d8a2bf:/# ls -alh /etc/nginx/conf.d/
total 12K
drwxr-xr-x 2 root root 4.0K Apr 30 13:55 .
drwxr-xr-x 3 root root 4.0K Apr 30 13:55 ..
-rw-r--r-- 1 root root 1.1K Apr  9 16:01 default.conf
root@15c6b8d8a2bf:/# cat /etc/nginx/conf.d/default.conf
server {
    listen       80;
    server_name  localhost;

    #charset koi8-r;
    #access_log  /var/log/nginx/host.access.log  main;

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    # proxy the PHP scripts to Apache listening on 127.0.0.1:80
    #
    #location ~ \.php$ {
    #    proxy_pass   http://127.0.0.1;
    #}

    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    #
    #location ~ \.php$ {
    #    root           html;
    #    fastcgi_pass   127.0.0.1:9000;
    #    fastcgi_index  index.php;
    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
    #    include        fastcgi_params;
    #}

    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
}</code></pre>
<p>So the server is listening on port 80. Unfortunately, we cannot reach the web server from our windows host machine,
as there is currently (2018-05-31) an <a href="https://github.com/docker/for-win/issues/221">open bug for accessing container IPs from a windows host</a>
(don't worry, we'll fix that with port mappings in a second)).
So, in order to verify that the server is actually  working, we'll install <code>curl</code> inside the nginx container and fetch <code>127.0.0.1:80</code>:</p>
<pre><code>apt-get install curl -y
curl localhost:80</code></pre>
<p>Looks like this:</p>
<pre><code>root@15c6b8d8a2bf:/# apt-get install curl -y
Reading package lists... Done
Building dependency tree
[...]
Running hooks in /etc/ca-certificates/update.d...
done.
root@15c6b8d8a2bf:/# curl localhost:80
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>Looks good! Now let's customize some stuff:</p>
<ul>
<li>point the root to <code>/var/www</code></li>
<li>place a &quot;Hello world&quot; index file in <code>/var/www/index.html</code></li>
</ul>
<pre><code>sed -i "s#/usr/share/nginx/html#/var/www#" /etc/nginx/conf.d/default.conf
mkdir -p /var/www
echo "Hello world!" &gt; /var/www/index.html</code></pre>
<p>To make the changes become effective, we need to <a href="http://nginx.org/en/docs/beginners_guide.html#control">reload nginx</a> via </p>
<pre><code>nginx -s reload</code></pre>
<pre><code>root@15c6b8d8a2bf:/# nginx -s reload
2018/05/29 09:22:54 [notice] 351#351: signal process started</code></pre>
<p>Check with curl, et voilá:</p>
<pre><code>root@15c6b8d8a2bf:/# curl 127.0.0.1:80
Hello world!</code></pre>
<p>With all that new information we can set up our nginx image with the following folder structure on the host machine:</p>
<pre><code>C:\codebase\docker-php
+ nginx\
  + conf.d\
    - site.conf
  - Dockerfile
+ app\
  - index.html
  - hello-world.php</code></pre>
<p><code>nginx\Dockerfile</code></p>
<pre><code>FROM nginx:latest</code></pre>
<p><code>nginx\conf.d\site.conf</code></p>
<pre><code>server {
    listen      80;
    server_name localhost;
    root        /var/www;
}</code></pre>
<p><code>app\index.html</code></p>
<pre><code>Hello World</code></pre>
<p>Clean up the &quot;exploration&quot; nginx container, <code>cd</code> into <code>/c/codebase/docker-php/nginx</code> and build the new image: </p>
<pre><code>docker rm -f $(docker ps -aq)
cd /c/codebase/docker-php/nginx
docker build -t docker-nginx-image .</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker rm -f $(docker ps -aq)
15c6b8d8a2bf
Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ cd nginx
Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/nginx
$ docker build -t docker-nginx-image .
Sending build context to Docker daemon  3.584kB
Step 1/1 : FROM nginx:latest
 ---&gt; ae513a47849c
Successfully built ae513a47849c
Successfully tagged docker-nginx-image:latest
SECURITY WARNING: You are building a Docker image from Windows against a non-Windows Docker host. All files and directories added to build context will have '-rwxr-xr-x' permissions. It is recommended to double check and reset permissions for sensitive files and directories.</code></pre>
<p>And then run the &quot;new&quot; container via </p>
<pre><code>docker run -di --name docker-nginx -p 8080:80 -v "C:\codebase\docker-php\nginx\conf.d":/etc/nginx/conf.d/ -v "C:\codebase\docker-php\app":/var/www docker-nginx-image</code></pre>
<p>where</p>
<pre><code>-p 8080:80                                                  // maps port 8080 on the windows host to port 80 in the container
-v "C:\codebase\docker-php\nginx\conf.d":/etc/nginx/conf.d/ // mounts the conf.d folder on the host to the correct directory in the container
-v "C:\codebase\docker-php\app":/var/www                    // mounts the "code" directory in the correct place</code></pre>
<p>Thanks to the port mapping we can now simply open <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a> in a browser on the host machine
and see the content of our <code>app\index.html</code> file.</p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-nginx.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-nginx.PNG" alt="nginx index file" /></a></p>
<p>If you want some more information about running nginx on Docker, check out
<a href="https://www.digitalocean.com/community/tutorials/how-to-run-nginx-in-a-docker-container-on-ubuntu-14-04">this tutorial</a>.</p>
<p>Before we move on, let's clean up</p>
<pre><code>docker stop docker-nginx</code></pre>
<h3><a id="setup-php-fpm"></a>Setting up php-fpm</h3>
<p>We are already familiar with the official docker PHP image but have only used the cli-only version so far.
FPM ones can be pulled in by using the <code>-fpm</code> tags (e.g. like <code>php:7.0-fpm</code>).
As with nginx, let's explore the php-fpm image first:</p>
<pre><code>docker run -di --name php-fpm-test php:7.0-fpm</code></pre>
<p>The first thing to note is, that the image automatically exposes port 9000 as a <code>docker ps</code> reveals:</p>
<pre><code>$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                  NAMES
c5d23b694563        php:7.0-fpm         "docker-php-entrypoi…"   4 hours ago         Up 4 hours                  9000/tcp               php-fpm-test</code></pre>
<p>When we examine the Dockerfile that was used to build the image
(click <a href="https://hub.docker.com/r/library/php/">here</a> and search for the &quot;7.0-fpm&quot; tag
that currently (2018-05-31) links <a href="https://github.com/docker-library/php/blob/27c65bbd606d1745765b89bf43f39b06efad1e43/7.0/stretch/fpm/Dockerfile">here</a>),
we can see that it contains an <code>EXPOSE 9000</code> at the bottom.</p>
<p>What else we can we figure out...</p>
<pre><code>winpty docker exec -it php-fpm-test bash</code></pre>
<p>First, will check where the configuration files are located via <code>php-fpm -i | grep config</code>:</p>
<pre><code>root@c5d23b694563:/var/www/html# php-fpm -i | grep config
Configure Command =&gt;  './configure'  '--build=x86_64-linux-gnu' '--with-config-file-path=/usr/local/etc/php' '--with-config-file-scan-dir=/usr/local/etc/php/conf.d' '--enable-option-checking=fatal' '--disable-c
gi' '--with-mhash' '--enable-ftp' '--enable-mbstring' '--enable-mysqlnd' '--with-curl' '--with-libedit' '--with-openssl' '--with-zlib' '--with-libdir=lib/x86_64-linux-gnu' '--enable-fpm' '--with-fpm-user=www-da
ta' '--with-fpm-group=www-data' 'build_alias=x86_64-linux-gnu'
fpm.config =&gt; no value =&gt; no value
[...]
</code></pre>
<p><code>--with-config-file-path=/usr/local/etc/php</code> is our suspect. So it is very likely,
that we will find the <a href="https://myjeeva.com/php-fpm-configuration-101.html#global-directives">global directives config file</a> at
<code>/usr/local/etc/php-fpm.conf</code> (unfortunately, we cannot resolve the location directly).
<code>grep</code>'ing this file for <code>include=</code> reveals the location for the
<a href="https://myjeeva.com/php-fpm-configuration-101.html#pool-directives">pool directives config</a>:</p>
<pre><code>grep "include=" /usr/local/etc/php-fpm.conf</code></pre>
<pre><code>root@c5d23b694563:/var/www/html# grep "include=" /usr/local/etc/php-fpm.conf
include=etc/php-fpm.d/*.conf</code></pre>
<p>Hm - a relative path. That looks kinda odd? Let's get a little more context with the <code>-C</code> option for <code>grep</code>:</p>
<pre><code>grep -C 6 "include=" /usr/local/etc/php-fpm.conf</code></pre>
<pre><code>root@c5d23b694563:/var/www/html# grep -C 6 "include=" /usr/local/etc/php-fpm.conf
; Include one or more files. If glob(3) exists, it is used to include a bunch of
; files from a glob(3) pattern. This directive can be used everywhere in the
; file.
; Relative path can also be used. They will be prefixed by:
;  - the global prefix if it's been set (-p argument)
;  - /usr/local otherwise
include=etc/php-fpm.d/*.conf</code></pre>
<p>Ah - that makes more sense. So we need to resolve <code>etc/php-fpm.d/*.conf</code> relative to <code>/usr/local</code>.
Resulting in <code>/usr/local/etc/php-fpm.d/*.conf</code> (usually you'll at least find a <code>www.conf</code> file in there).
The pool config determines amongst other things how php-fpm listens for connections (e.g. via Unix socket or via TCP IP:port).</p>
<pre><code>cat /usr/local/etc/php-fpm.d/www.conf</code></pre>
<pre><code>root@c5d23b694563:/var/www/html# cat /usr/local/etc/php-fpm.d/www.conf
[...]
; The address on which to accept FastCGI requests.
; Valid syntaxes are:
;   'ip.add.re.ss:port'    - to listen on a TCP socket to a specific IPv4 address on
;                            a specific port;
;   '[ip:6:addr:ess]:port' - to listen on a TCP socket to a specific IPv6 address on
;                            a specific port;
;   'port'                 - to listen on a TCP socket to all addresses
;                            (IPv6 and IPv4-mapped) on a specific port;
;   '/path/to/unix/socket' - to listen on a unix socket.
; Note: This value is mandatory.
listen = 127.0.0.1:9000
[...]</code></pre>
<p>php-fpm ist listening on port 9000 on 127.0.0.1 (localhost). So it makes total sense to expose port 9000.</p>
<h4><a id="php-fpm-xdebug"></a>Installing xdebug</h4>
<p>Since we probably also want to debug php-fpm, xdebug needs to be setup as well. The process is pretty much the same as for the cli image:</p>
<pre><code>pecl install xdebug-2.6.0
docker-php-ext-enable xdebug
php-fpm -m | grep xdebug</code></pre>
<p>Of course we'll also put that in its own Dockerfile:</p>
<pre><code>C:\codebase\docker-php
+ php-fpm\
  - Dockerfile</code></pre>
<p><code>php-fpm\Dockerfile</code></p>
<pre><code>FROM php:7.0-fpm
RUN pecl install xdebug-2.6.0 \
    &amp;&amp; docker-php-ext-enable xdebug</code></pre>
<p>Clean up the test container and build the new image</p>
<pre><code>docker rm -f php-fpm-test
cd /c/codebase/docker-php/php-fpm
docker build -t docker-php-fpm-image .</code></pre>
<h3><a id="connecting-nginx-php-fpm"></a>Connecting nginx and php-fpm</h3>
<p>Now that we have containers for nginx and php-fpm, we need to connect them.
To do so, we have to make sure that both containers are in the same network and can talk to each other
(<a href="https://stackoverflow.com/questions/29905953/how-to-correctly-link-php-fpm-and-nginx-docker-containers">which is a common problem</a>).
Docker provides so called
<a href="https://docs.docker.com/network/network-tutorial-standalone/#use-user-defined-bridge-networks">user defined bridge networks</a>
allowing <strong>automatic service discovery</strong>. That basically means,
that our nginx container can use <em>the name</em> of the php-fpm container to connect to it.
Otherwise we would have to figure out the containers <em>IP address</em> in the default network every time we start the containers.</p>
<pre><code>docker network ls</code></pre>
<p>reveals a list of the current networks</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /
$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
7019b0b37ba7        bridge              bridge              local
3820ad97cc92        host                host                local
03fecefbe8c9        none                null                loca</code></pre>
<p>Now let's add a new one called <code>web-network</code> for our web stack via </p>
<pre><code>docker network create --driver bridge web-network</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /
$ docker network create --driver bridge web-network
20966495e04e9f9df9fd64fb6035a9e9bc3aa6d83186dcd23454e085a0d97648

Pascal@Landau-Laptop MINGW64 /
$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
7019b0b37ba7        bridge              bridge              local
3820ad97cc92        host                host                local
03fecefbe8c9        none                null                local
20966495e04e        web-network         bridge              local</code></pre>
<p>Start the nginx container and connect it to the new network via</p>
<pre><code>docker start docker-nginx
docker network connect web-network docker-nginx</code></pre>
<p>Finally, we need to mount the local code folder <code>app\</code> we mounted to the nginx container at <code>/var/www</code>
also in the php-fpm container in the same location:</p>
<pre><code>docker run -di --name docker-php-fpm -v "C:\codebase\docker-php\app":/var/www --network web-network docker-php-fpm-image</code></pre>
<p>Note that we specified the network in the run command via the <code>--network</code> option.
We can verify that both containers are connected to the <code>web-network</code> by running </p>
<pre><code>docker network inspect web-network</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-fpm
$ docker network inspect web-network
[
    {
        "Name": "web-network",
        "Id": "20966495e04e9f9df9fd64fb6035a9e9bc3aa6d83186dcd23454e085a0d97648",
        "Created": "2018-05-30T06:39:44.3107066Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "3358e813423165880d59c8ebc2cb4c563ee8ad1d401595f8bfcf763ff5db8f4a": {
                "Name": "docker-php-fpm",
                "EndpointID": "d2f1d6285a0932817e1fb8839bef3a6d178f5306a2116307dba200038ea2a3a3",
                "MacAddress": "02:42:ac:12:00:03",
                "IPv4Address": "172.18.0.3/16",
                "IPv6Address": ""
            },
            "eaa5c05942788985e90a80fa000723286e9b4e7179d0f6f431c0f5109e012764": {
                "Name": "docker-nginx",
                "EndpointID": "274fa9a6868aff656078a72e19c05fb87e4e86b83aaf12be9b943890140a421d",
                "MacAddress": "02:42:ac:12:00:02",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]</code></pre>
<p>The &quot;Containers&quot; key reveals that the <code>docker-php-fpm</code> container has the IP address 172.18.0.3
and the docker-nginx container is reachable via 172.18.0.2.
But can we actually connect from nginx to php-fpm? Let's find out:</p>
<p>Log into the nginx container </p>
<pre><code>winpty docker exec -ti docker-nginx bash</code></pre>
<p>and ping the IP</p>
<pre><code>ping 172.18.0.3 -c 2</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php/php-fpm
$ winpty docker exec -ti docker-nginx bash
root@eaa5c0594278:/# ping 172.18.0.3 -c 2
bash: ping: command not found</code></pre>
<p>.. well, after we make the command available by installing <code>iputils-ping</code>:</p>
<pre><code>apt-get update &amp;&amp; apt-get install iputils-ping -y
ping 172.18.0.3 -c 2</code></pre>
<pre><code>root@eaa5c0594278:/# apt-get update &amp;&amp; apt-get install iputils-ping -y
root@eaa5c0594278:/# ping 172.18.0.3 -c 2
PING 172.18.0.3 (172.18.0.3) 56(84) bytes of data.
64 bytes from 172.18.0.3: icmp_seq=1 ttl=64 time=0.142 ms
64 bytes from 172.18.0.3: icmp_seq=2 ttl=64 time=0.162 ms

--- 172.18.0.3 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1071ms
rtt min/avg/max/mdev = 0.142/0.152/0.162/0.010 ms</code></pre>
<p>We can ping the container - that's good. But we were also promised we could reach the container by its name <code>docker-php-fpm</code>:</p>
<pre><code>ping docker-php-fpm -c 2</code></pre>
<pre><code>root@eaa5c0594278:/# ping docker-php-fpm -c 2
PING docker-php-fpm (172.18.0.3) 56(84) bytes of data.
64 bytes from docker-php-fpm.web-network (172.18.0.3): icmp_seq=1 ttl=64 time=0.080 ms
64 bytes from docker-php-fpm.web-network (172.18.0.3): icmp_seq=2 ttl=64 time=0.131 ms

--- docker-php-fpm ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1045ms
rtt min/avg/max/mdev = 0.080/0.105/0.131/0.027 ms</code></pre>
<p>And we can - awesome! Now we need to tell nginx to pass all PHP related requests to php-fpm by changing the
<code>nginx\conf.d\site.conf</code> file on our windows host to </p>
<pre><code>server {
    listen      80;
    server_name localhost;
    root        /var/www;

   location ~ \.php$ {
        try_files $uri =404;
        fastcgi_pass docker-php-fpm:9000;
        include fastcgi_params;
        fastcgi_param  SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }
}</code></pre>
<p>Note the <code>fastcgi_pass docker-php-fpm:9000;</code> line that tells nginx how to reach our php-fpm service.
Because we mounted the <code>nginx\conf.d</code> folder, we just need to reload nginx:</p>
<pre><code>nginx -s reload</code></pre>
<p>and open <a href="http://127.0.0.1:8080/hello-world.php">http://127.0.0.1:8080/hello-world.php</a> on a browser on your host machine.</p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-php-fpm.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-php-fpm.PNG" alt="php-fpm hello world" /></a></p>
<p>Btw. there's also a good tutorial on geekyplatypus.com on how to
<a href="http://geekyplatypus.com/dockerise-your-php-application-with-nginx-and-php7-fpm/">Dockerise your PHP application with Nginx and PHP7-FPM</a>.
But since it's using docker-compose you might want to read the next chapter first :)</p>
<h2><a id="docker-compose"></a>Putting it all together: Meet docker-compose</h2>
<p>Lets sum up what we have do now to get everything up and running:</p>
<ol>
<li>start php-cli</li>
<li>start nginx</li>
<li>start php-fpm</li>
</ol>
<pre><code>docker run -di --name docker-php -v "C:\codebase\docker-php\app":/var/www --network web-network docker-php-image
docker run -di --name docker-nginx -p 8080:80 -v "C:\codebase\docker-php\nginx\conf.d":/etc/nginx/conf.d/ -v "C:\codebase\docker-php\app":/var/www  --network web-network docker-nginx-image
docker run -di --name docker-php-fpm -v "C:\codebase\docker-php\app":/var/www --network web-network docker-php-fpm-image</code></pre>
<p>Hm. That's alright I guess... but it also feels like &quot;a lot&quot;. Wouldn't it be much better to have everything neatly defined in one place?
I bet so! Let me introduce you to <a href="https://docs.docker.com/compose/">docker-compose</a></p>
<blockquote>
<p>Compose is a tool for defining and running multi-container Docker applications.
With Compose, you use a YAML file to configure your application's services.
Then, with a single command, you create and start all the services from your configuration.</p>
</blockquote>
<p>Lets do this step by step, starting with the php-cli container. Create the file <code>C:\codebase\docker-php\docker-compose.yml</code>:</p>
<pre><code># tell docker what version of the docker-compose.yml we're using
version: '3'

# define the network
networks:
  web-network:

# start the services section
services:
  # define the name of our service
  # corresponds to the "--name" parameter
  docker-php-cli:
    # define the directory where the build should happened,
    # i.e. where the Dockerfile of the service is located
    # all paths are relative to the location of docker-compose.yml
    build: 
      context: ./php-cli
    # reserve a tty - otherwise the container shuts down immediately
    # corresponds to the "-i" flag
    tty: true
    # mount the app directory of the host to /var/www in the container
    # corresponds to the "-v" option
    volumes:
      - ./app:/var/www
    # connect to the network
    # corresponds to the "--network" option
    networks:
      - web-network</code></pre>
<p>Before we get started, we're gonna clean up the old containers:</p>
<pre><code>docker rm -f $(docker ps -aq)</code></pre>
<p>To test the docker-compose.yml we need to run <code>docker-compose up -d</code> from <code>C:\codebase\docker-php</code></p>
<pre><code>cd "C:\codebase\docker-php"
docker-compose up -d</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker-compose up -d
Creating network "docker-php_web-network" with the default driver
Building docker-php-cli
Step 1/2 : FROM php:7.0-cli
 ---&gt; da771ba4e565
Step 2/2 : RUN pecl install xdebug-2.6.0     &amp;&amp; docker-php-ext-enable xdebug
 ---&gt; Using cache
 ---&gt; 12be27256b12
Successfully built 12be27256b12
Successfully tagged docker-php_docker-php-cli:latest
Image for service docker-php-cli was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.
Creating docker-php_docker-php-cli_1 ... done</code></pre>
<p>Note that the image is build from scratch when we run <code>docker-compose up</code> for the first time.
A <code>docker ps -a</code> shows that the container is running fine, we can log in and execute source code from the host machine.</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker ps -a
CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS               NAMES
adf794f27315        docker-php_docker-php-cli   "docker-php-entrypoi…"   3 minutes ago       Up 2 minutes                            docker-php_docker-php-cli_1</code></pre>
<p>Logging in</p>
<pre><code>winpty docker exec -it docker-php_docker-php-cli_1 bash</code></pre>
<p>and running </p>
<pre><code>php /var/www/hello-world.php</code></pre>
<p>works as before</p>
<pre><code>root@adf794f27315:/# php /var/www/hello-world.php
Hello World (php)</code></pre>
<p>Now log out of the container and run </p>
<pre><code>docker-compose down </code></pre>
<p>to shut the container down again:</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker-compose down
Stopping docker-php_docker-php-cli_1 ... done
Removing docker-php_docker-php-cli_1 ... done
Removing network docker-php_web-network</code></pre>
<p>Add the remaining services to the <code>docker-compose.yml</code> file:</p>
<pre><code># tell docker what version of the docker-compose.yml we're using
version: '3'

# define the network
networks:
  web-network:

# start the services section
services:
  # define the name of our service
  # corresponds to the "--name" parameter
  docker-php-cli:
    # define the directory where the build should happened,
    # i.e. where the Dockerfile of the service is located
    # all paths are relative to the location of docker-compose.yml
    build: 
      context: ./php-cli
    # reserve a tty - otherwise the container shuts down immediately
    # corresponds to the "-i" flag
    tty: true
    # mount the app directory of the host to /var/www in the container
    # corresponds to the "-v" option
    volumes:
      - ./app:/var/www
    # connect to the network
    # corresponds to the "--network" option
    networks:
      - web-network

  docker-nginx:
    build: 
      context: ./nginx
    # defines the port mapping
    # corresponds to the "-p" flag
    ports:
      - "8080:80"
    tty: true
    volumes:
      - ./app:/var/www
      - ./nginx/conf.d:/etc/nginx/conf.d
    networks:
      - web-network

  docker-php-fpm:
    build: 
      context: ./php-fpm
    tty: true
    volumes:
      - ./app:/var/www
    networks:
      - web-network</code></pre>
<p>And up again...</p>
<pre><code>docker-compose up -d</code></pre>
<pre><code>Pascal@Landau-Laptop MINGW64 /c/codebase/docker-php
$ docker-compose up -d
Building docker-nginx
Step 1/1 : FROM nginx:latest
 ---&gt; ae513a47849c
Successfully built ae513a47849c
Successfully tagged docker-php_docker-nginx:latest
Image for service docker-nginx was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.
Building docker-php-fpm
Step 1/2 : FROM php:7.0-fpm
 ---&gt; a637000da5a3
Step 2/2 : RUN pecl install xdebug-2.6.0     &amp;&amp; docker-php-ext-enable xdebug
 ---&gt; Running in 4ec27516df54
downloading xdebug-2.6.0.tgz ...
Starting to download xdebug-2.6.0.tgz (283,644 bytes)
[...]
---&gt; 120c8472b4f3
Successfully built 120c8472b4f3
Successfully tagged docker-php_docker-php-fpm:latest
Image for service docker-php-fpm was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.
Creating docker-php_docker-nginx_1   ... done
Creating docker-php_docker-php-cli_1 ... done
Creating docker-php_docker-php-fpm_1 ... done</code></pre>
<p>Only nginx and php-fpm needed to be built because the php-cli one already existed.
Lets check if we can still open <a href="http://127.0.0.1:8080/hello-world.php">http://127.0.0.1:8080/hello-world.php</a> in a browser on the host machine:</p>
<p><a href="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-php-fpm.PNG"><img src="/img/php-php-fpm-and-nginx-on-docker-in-windows-10/webstack/hello-world-php-fpm.PNG" alt="php-fpm hello world" /></a></p>
<p>Yes we can! So instead of needing to run 3 different command with a bunch of parameters we're now down to
<code>docker-compose up -d</code>. Looks like an improvement to me ;)</p>
<h2><a id="tl-dr"></a>The tl;dr</h2>
<p>The whole article is a lot to take in and it is most likely not the most efficient approach when you &quot;just want to get started&quot;.
So in this section we'll boil it down to only the necessary steps without in depth explanations.</p>
<ul>
<li><a href="https://store.docker.com/editions/community/docker-ce-desktop-windows">Download Docker for Windows</a></li>
<li><a href="#setup-docker">Install Docker</a>
<ul>
<li>activate Hyper-V (Virtual Box will stop working) </li>
<li>enable Disk Sharing in the settings</li>
</ul></li>
<li>Set up the following folder structure
<pre><code>C:\codebase\docker-php
+ nginx\
  + conf.d\
    - site.conf
  - Dockerfile
+ php-cli\
  - Dockerfile
+ php-fpm\
  - Dockerfile
+ app\
  - index.html
  - hello-world.html
- docker-compose.yml</code></pre>
<ul>
<li>or simply <code>git clone git@github.com:paslandau/docker-php-tutorial.git docker-php &amp;&amp; git checkout part_1_setting-up-php-php-fpm-and-nginx-for-local-development-on-docker</code></li>
</ul></li>
<li>Open a shell at <code>C:\codebase\docker-php</code></li>
<li>run <code>docker-compose up -d</code></li>
<li>check in browser via
<ul>
<li>127.0.0.1:8080</li>
<li>127.0.0.1:8080/hello-world.php</li>
</ul></li>
<li>run <code>docker-compose down</code></li>
</ul>
<p>Your application code lives in the <code>app\</code> folder and changes are automatically available to the containers.
This setup denotes the end of the first tutorial. In the next part we will learn how to set up Docker in PHPStorm,
especially in combination with xdebug.</p>]]></description>
                <pubDate>Sun, 08 Jul 2018 22:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/</guid>
            </item>
                    <item>
                <title>BigQuery: Convert timestamp/date/datetime to different timezone</title>
                <description><![CDATA[<p>BigQuery provides multiple functions to convert timestamps / dates / datetimes to a different timezone:</p>
<ul>
<li><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#date">DATE(timestamp_expression, timezone)</a></li>
<li><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#time">TIME(timestamp, timezone)</a></li>
<li><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#datetime">DATETIME(timestamp_expression, timezone)</a></li>
</ul>
<p>According to the <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#time-zones">docu</a> the <code>timezone</code>
can be provided as UTC-offset (e.g. <code>+02:00</code>) or timezone name (e.g. <code>Europe/Berlin</code>). See this
<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">list of IANA timezone offsets and names</a>.</p>
<p>The converted dates/times can than be formatted with via </p>
<ul>
<li><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#format_date">FORMAT_DATE(format_string, date_expression)</a></li>
<li><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#format_time">FORMAT_TIME(format_string, time_expression)</a></li>
<li><a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#format_datetime">FORMAT_DATETIME(format_string, datetime_expression)</a></li>
</ul>
<h2>Code</h2>
<pre><code>#standardSQL
SELECT
  DATETIME(timestamp, "Europe/Berlin") as datetime_berlin,
  DATE(timestamp, "Europe/Berlin") as date_berlin,
  TIME(timestamp, "Europe/Berlin") as time_berlin,
  FORMAT_DATETIME("%F %X", DATETIME(timestamp, "Europe/Berlin")) as formatted_date_time_berlin
FROM
  table</code></pre>
<h2>Working Example</h2>
<script src="https://gist.github.com/paslandau/b40d8e265884ce2c19b966e52fbf72b9.js"><script src="https://gist.github.com/paslandau/b40d8e265884ce2c19b966e52fbf72b9.js"></script></script>
<h2>Run on BigQuery</h2>
<p><a href="https://console.cloud.google.com/bigquery?sq=106862046541:12050165b14e437387aa63757ae7d60c">Open in BigQuery Console</a></p>
<p><a href="/img/bigquery-snippets/convert-timestamp-date-datetime-to-different-timezone/convert-timestamp-date-datetime-to-different-timezone-bigquery-example.png"><img src="/img/bigquery-snippets/convert-timestamp-date-datetime-to-different-timezone/convert-timestamp-date-datetime-to-different-timezone-bigquery-example.png" alt="BigQuery Console: Convert timestamp to different timezone example" title="BigQuery Console: Convert timestamp to different timezone" /></a></p>
<h2>Links</h2>
<ul>
<li><a href="https://gist.github.com/paslandau/b40d8e265884ce2c19b966e52fbf72b9">Gist on Github</a></li>
<li><a href="https://console.cloud.google.com/bigquery?sq=106862046541:12050165b14e437387aa63757ae7d60c">Example on BigQuery</a></li>
<li><a href="https://stackoverflow.com/a/43349229/413531">Answer to &quot;BigQuery converting to a different timezone&quot; on Stackoverflow</a></li>
</ul>
<h2>Use cases</h2>
<p>BigQuery displays data usually in UTC. That leads to problems when using date formatting functions because
dates and times can be off. Converting the datetimes prior formatting into the correct timezone solves those issues.</p>
<p>Common formats:</p>
<pre><code>FORMAT_TIMESTAMP("%F %X", timestamp)                            # %Y-%m-%d %H:%M:%S =&gt; 2018-04-08 18:28:01
FORMAT_DATETIME("%F %X", DATETIME(timestamp, "Europe/Berlin"))  # %Y-%m-%d %H:%M:%S =&gt; 2018-04-08 18:28:01
FORMAT_DATE("%F", DATE(timestamp, "Europe/Berlin"))             # %Y-%m-%d          =&gt; 2018-04-08
FORMAT_DATE("%V", DATE(timestamp, "Europe/Berlin"))             # calendar week     =&gt; 14
FORMAT_TIME("%T", DATETIME(timestamp, "Europe/Berlin"))         # %H:%M:%S          =&gt; 18:28:01</code></pre>]]></description>
                <pubDate>Sun, 08 Apr 2018 18:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/bigquery-snippets/convert-timestamp-date-datetime-to-different-timezone/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/bigquery-snippets/convert-timestamp-date-datetime-to-different-timezone/</guid>
            </item>
                    <item>
                <title>BigQuery: Extract URL parameters as ARRAY</title>
                <description><![CDATA[<p>We're gonna use the <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators?hl=de#regexp_extract_all">REGEXP_EXTRACT_ALL</a>
function provided in the Standard SQL dialect of BigQuery
to extract parameters from the query part of a URL and return them as an ARRAY.</p>
<h2>Code</h2>
<pre><code>#standardSQL
SELECT
  REGEXP_EXTRACT_ALL(query,r'(?:\?|&amp;)((?:[^=]+)=(?:[^&amp;]*))') as params,
  REGEXP_EXTRACT_ALL(query,r'(?:\?|&amp;)(?:([^=]+)=(?:[^&amp;]*))') as keys,
  REGEXP_EXTRACT_ALL(query,r'(?:\?|&amp;)(?:(?:[^=]+)=([^&amp;]*))') as values
FROM
  table</code></pre>
<h2>Working Example</h2>
<script src="https://gist.github.com/paslandau/6c46020211a00c39607d5eab1d093f3a.js"><script src="https://gist.github.com/paslandau/6c46020211a00c39607d5eab1d093f3a.js"></script></script>
<h3>Result</h3>
<table>
<thead>
<tr>
<th>Row</th>
<th>id</th>
<th>query</th>
<th>params</th>
<th>keys</th>
<th>values</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>?foo=bar</td>
<td>foo=bar</td>
<td>foo</td>
<td>bar</td>
<td>simple</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>?foo=bar&amp;bar=baz</td>
<td>foo=bar</td>
<td>foo</td>
<td>bar</td>
<td>multiple params</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>bar=baz</td>
<td>bar</td>
<td>baz</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>?foo[]=bar&amp;foo[]=baz</td>
<td>foo[]=bar</td>
<td>foo[]</td>
<td>bar</td>
<td>arrays</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>foo[]=baz</td>
<td>foo[]</td>
<td>baz</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>no query</td>
</tr>
</tbody>
</table>
<h2>Run on BigQuery</h2>
<p><a href="https://console.cloud.google.com/bigquery?sq=106862046541:e5da849d652a4502b12443a2f14b355a">Open in BigQuery Console</a></p>
<p><a href="/img/bigquery-snippets/extract-url-parameters-array/extract-url-parameters-array-bigquery-example.png"><img src="/img/bigquery-snippets/extract-url-parameters-array/extract-url-parameters-array-bigquery-example.png" alt="BigQuery Console: Extract URL parameters example" title="BigQuery Console: Extract URL parameters example" /></a></p>
<h2>Notes</h2>
<ul>
<li><code>REGEXP_EXTRACT_ALL</code> only excepts 1 capturing group, hence we need to mark all other groups
as non-capturing with <code>(?:</code></li>
<li>if the URL contains a fragment part (e.g. <a href="https://example.org/?foo=bar#baz">https://example.org/?foo=bar#baz</a>), the fragment is currently not removed.
To do so, remove the fragment prior to extraction with
<a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators?hl=de#regexp_replace">REGEXP_REPLACE</a>,
e.g. like so:
<pre><code>REGEXP_EXTRACT_ALL(
REGEXP_EXTRACT(query, r'#.*', ''),
r'(?:\?|&amp;)(?:(?:[^=]+)=([^&amp;]*))') as values</code></pre></li>
</ul>
<h2>Links</h2>
<ul>
<li><a href="https://gist.github.com/paslandau/6c46020211a00c39607d5eab1d093f3a">Gist on Github</a></li>
<li><a href="https://console.cloud.google.com/bigquery?sq=106862046541:e5da849d652a4502b12443a2f14b355a">Example on BigQuery</a></li>
<li><a href="https://regex101.com/r/iqwgxD/1/">REGEX explanation on Regex101</a></li>
</ul>
<h2>Use cases</h2>
<ul>
<li>compile a list of all parameters from your log files</li>
<li>evaluate the frequency of parameters keys/values</li>
</ul>]]></description>
                <pubDate>Sun, 08 Apr 2018 12:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/bigquery-snippets/extract-url-parameters-array/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/bigquery-snippets/extract-url-parameters-array/</guid>
            </item>
            </channel>
</rss>
