<?xml version = "1.0" encoding = "UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>pascallandau.com</title>
        <description>Personal website of Pascal Landau</description>
        <link>https://www.pascallandau.com</link>
        <atom:link href="https://www.pascallandau.com/feed.xml" rel="self" type="application/rss+xml"/>
        <pubDate>Tue, 22 Mar 2022 07:16:15 +0000</pubDate>
        <lastBuildDate>Tue, 22 Mar 2022 07:16:15 +0000</lastBuildDate>
        <language>en</language>
                    <item>
                <title>PhpStorm, Docker and Xdebug 3 on PHP 8.1 in 2022 [Tutorial Part 4.2]</title>
                <description><![CDATA[<p>In this second subpart of the fourth part of this tutorial series on developing PHP on Docker we
will <strong>setup our local development environment to be used by PhpStorm and Xdebug</strong>. We will also
ensure that we can run <strong>PHPUnit tests from the command line as well as from PhpStorm</strong> and throw
the tool <code>strace</code> into the mix for debugging long running processes.</p>
<div class="center-div">
<iframe width="560" height="315" src="https://www.youtube.com/embed/bZ1MiynqT98" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<p>All code samples are publicly available in my
<a href="https://github.com/paslandau/docker-php-tutorial">Docker PHP Tutorial repository on github</a>.<br />
You find the branch for this tutorial at
<a href="https://github.com/paslandau/docker-php-tutorial/tree/part-4-2-phpstorm-docker-xdebug-3-php-8-1-in-2022">part-4-2-phpstorm-docker-xdebug-3-php-8-1-in-2022</a></p>
<!-- generated -->
<p><a id='published-parts-of-the-docker-php-tutorial'> </a></p>
<!-- /generated -->
<h2>Published parts of the Docker PHP Tutorial</h2>
<ul>
<li><a href="/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/">Setting up PHP, PHP-FPM and NGINX for local development on Docker</a>
(2018-07-08)</li>
<li><a href="/blog/setup-phpstorm-with-xdebug-on-docker/">Setting up PhpStorm with Xdebug for local development on Docker</a>
(2018-08-06)</li>
<li><a href="/blog/structuring-the-docker-setup-for-php-projects/">Structuring the Docker setup for PHP Projects</a>
(2019-05-20)</li>
<li><a href="/blog/docker-from-scratch-for-php-applications-in-2022/">Docker from scratch for PHP 8.1 Applications in 2022</a>
(2022-03-21)</li>
<li><a href="/blog/phpstorm-docker-xdebug-3-php-8-1-in-2022/">PhpStorm, Docker and Xdebug 3 on PHP 8.1 in 2022</a>
(2022-03-22)</li>
<li><a href="/blog/run-laravel-9-docker-in-2022/">Run Laravel 9 on Docker in 2022</a>
(2022-03-23)</li>
</ul>
<p>If you want to follow along, please subscribe to the <a href="/feed.xml">RSS feed</a>
or <a href="#newsletter">via email</a>
to get automatic notifications when the next part comes out :)</p>
<!-- generated -->
<p><a id='table-of-contents'> </a></p>
<!-- /generated -->
<h2>Table of contents</h2>
<!-- toc -->
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#install-tools">Install Tools</a>
<ul>
<li><a href="#install-composer">Install composer</a></li>
<li><a href="#install-xdebug">Install Xdebug</a></li>
<li><a href="#install-phpunit">Install PHPUnit</a></li>
<li><a href="#install-ssh">Install SSH</a></li>
</ul></li>
<li><a href="#setup-phpstorm">Setup PhpStorm</a>
<ul>
<li><a href="#ssh-configuration">SSH Configuration</a></li>
<li><a href="#php-interpreter">PHP Interpreter</a></li>
<li><a href="#phpunit">PHPUnit</a></li>
<li><a href="#debugging">Debugging</a>
<ul>
<li><a href="#debug-code-executed-via-phpstorm">Debug code executed via PhpStorm</a></li>
<li><a href="#debug-code-executed-via-php-fpm-cli-or-from-a-worker">Debug code executed via php-fpm, cli or from a worker</a>
<ul>
<li><a href="#php-fpm">php-fpm</a></li>
<li><a href="#cli">cli</a></li>
<li><a href="#php-workers">php-workers</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#strace">strace</a></li>
<li><a href="#wrapping-up">Wrapping up</a></li>
</ul>
<!-- /toc -->
<!-- generated -->
<p><a id='introduction'> </a></p>
<!-- /generated -->
<h2>Introduction</h2>
<p>This article is mostly an update of
<a href="/blog/setup-phpstorm-with-xdebug-on-docker/">Setting up PhpStorm with Xdebug for local development on Docker</a>
but will also cover the &quot;remaining cases&quot; of <strong>debugging php-fpm</strong> and <strong>php worker processes</strong>. </p>
<p>We will still rely on an <strong>always-running docker setup</strong> that we connect to via an SSH Configuration
instead of using the
<a href="/blog/setup-phpstorm-with-xdebug-on-docker/#run-debug-a-php-script-on-docker-server">built-in docker-compose capabilities</a>
as I feel it's closer to what we do in CI / production. However, we will <strong>not use SSH keys</strong>
any longer but simply authenticate via password. This reduces complexity and removes any
pesky warnings regarding &quot;SSH keys being exposed in a repository&quot;.</p>
<!-- generated -->
<p><a id='install-tools'> </a></p>
<!-- /generated -->
<h2>Install Tools</h2>
<!-- generated -->
<p><a id='install-composer'> </a></p>
<!-- /generated -->
<h3>Install composer</h3>
<p><a href="https://getcomposer.org/">Composer</a> is installed by pulling
<a href="https://hub.docker.com/_/composer">the official composer docker image</a> and simply &quot;copying&quot; the
composer executable over to the base php image. In addition, composer needs the extensions
<code>mbstring</code> and <code>phar</code></p>
<pre><code># File: .docker/images/php/base/Dockerfile

ARG ALPINE_VERSION
ARG COMPOSER_VERSION
FROM composer:${COMPOSER_VERSION} as composer
FROM alpine:${ALPINE_VERSION} as base

# ...

RUN apk add --update --no-cache  \
        php-mbstring~=${TARGET_PHP_VERSION} \
        php-phar~=${TARGET_PHP_VERSION} \

# ...

COPY --from=composer /usr/bin/composer /usr/local/bin/composer</code></pre>
<p>Because we want our build to be deterministic, we &quot;pin&quot; the composer version by adding a
<code>COMPOSER_VERSION</code> variable to the <code>.docker/.env</code> file </p>
<pre><code class="language-dotenv">COMPOSER_VERSION=2.2.5</code></pre>
<p>and using it in <code>.docker/docker-compose/docker-compose-php-base.yml</code>:</p>
<pre><code class="language-yaml">services:
  php-base:
    build:
      args:
        - COMPOSER_VERSION=${COMPOSER_VERSION?}</code></pre>
<!-- generated -->
<p><a id='install-xdebug'> </a></p>
<!-- /generated -->
<h3>Install Xdebug</h3>
<p>Install the extension via <code>apk</code> (only for the <code>local</code> target):</p>
<pre><code class="language-Dockerfile"># File: .docker/images/php/base/Dockerfile

FROM base as local

RUN apk add --no-cache --update \
        php-xdebug~=${TARGET_PHP_VERSION} \
    # ensure that xdebug is not enabled by default
    &amp;&amp; rm -f /etc/php8/conf.d/00_xdebug.ini</code></pre>
<p>We also don't want to enable <code>xdebug</code> immediately but only when we need it (due to the decrease
in performance when the extension is enabled), hence we remove the default config file and
disable the extension in the application <code>.ini</code> file</p>
<pre><code># File: .docker/images/php/base/conf.d/zz-app-local.ini

; Note:
; Remove the comment ; to enable debugging
;zend_extension=xdebug
xdebug.client_host=host.docker.internal
xdebug.start_with_request=yes
xdebug.mode=debug</code></pre>
<p>See <a href="/blog/setup-phpstorm-with-xdebug-on-docker/#fix-xdebug-on-phpstorm-when-run-from-a-docker">Fix Xdebug on PhpStorm when run from a Docker container</a>
for an explanation of the <code>xdebug.client_host=host.docker.internal</code> setting (previously called
<code>xdebug.remote_host</code> in xdebug &lt; 3). This will still work out of the box for Docker Desktop, but
for Linux users we need to add the
<a href="https://github.com/docker/for-linux/issues/264#issuecomment-965465879"><code>host-gateway</code> magic reference</a>
<strong>to all PHP containers</strong> (we can't add it to the php base image because this is a runtime setting):</p>
<pre><code class="language-yaml">services:
  service:
    extra_hosts:
      - host.docker.internal:host-gateway</code></pre>
<p>Finally, we need to add
<a href="https://www.jetbrains.com/help/phpstorm/debugging-a-php-cli-script.html">the environment variable <code>PHP_IDE_CONFIG</code></a>
<strong>to all PHP containers</strong>. The variable is defined as <code>PHP_IDE_CONFIG=serverName=dofroscra</code>, where
&quot;dofroscra&quot; is the name of the server that we will configure later for debugging. Because we
need the same value in multiple places, the variable is configured in <code>.docker/.env</code>:</p>
<pre><code>PHP_IDE_CONFIG=serverName=dofroscra</code></pre>
<p>And then added in
<code>.docker/docker-compose/docker-compose.local.yml</code></p>
<pre><code class="language-yaml">services:
  php-fpm:
    environment:
      - PHP_IDE_CONFIG=${PHP_IDE_CONFIG?}

  php-worker:
    environment:
      - PHP_IDE_CONFIG=${PHP_IDE_CONFIG?}

  application:
    environment:
      - PHP_IDE_CONFIG=${PHP_IDE_CONFIG?}</code></pre>
<!-- generated -->
<p><a id='install-phpunit'> </a></p>
<!-- /generated -->
<h3>Install PHPUnit</h3>
<p>PHPUnit will be installed via <code>composer</code> but will not be &quot;baked into the image&quot; for local
development. Thus, we must run <code>composer require</code> <strong>in the container</strong>. To make this more
convenient a make target for running arbitrary composer commands is added in
<code>.make/01-00-application-setup.mk</code>:</p>
<pre><code class="language-makefile">.PHONY: composer
composer: ## Run composer commands. Specify the command e.g. via ARGS="install"
    $(EXECUTE_IN_APPLICATION_CONTAINER) composer $(ARGS);</code></pre>
<p>This allows me to run <code>make composer ARGS="install"</code> from the host system to execute <code>composer install</code> in the container. In consequence, <code>composer</code> will use the PHP version and extensions of
the <code>application</code> container to install the dependencies, yet I will still see the installed files
locally because the codebase is configured as a volume for the container.</p>
<p>Before installing phpunit, we must add the required extensions <code>dom</code> and <code>xml</code> to the container</p>
<pre><code># File: .docker/images/php/base/Dockerfile

# ...

RUN apk add --update --no-cache  \
        php-dom~=${TARGET_PHP_VERSION} \
        php-xml~=${TARGET_PHP_VERSION} \</code></pre>
<p>as well as rebuild and restart the docker setup via </p>
<pre><code>make docker-build
make docker-down
make docker-up</code></pre>
<p>Now we can add phpunit via</p>
<pre><code>make composer ARGS='require "phpunit/phpunit"'</code></pre>
<p>which will create a <code>composer.json</code> file and setup up the <code>vendor/</code> directory:</p>
<pre><code>$ make composer ARGS='require "phpunit/phpunit"'
Using version ^9.5 for phpunit/phpunit
./composer.json has been created
Running composer update phpunit/phpunit
Loading composer repositories with package information
Updating dependencies
...
</code></pre>
<p>I have also added </p>
<ul>
<li>a minimal <code>phpunit.xml</code> config file</li>
<li>a test case at <code>tests/SomeTest.php</code> </li>
<li>and a new Makefile for &quot;anything related to qa&quot; at <code>.make/01-02-application-qa.mk</code>:</li>
</ul>
<pre><code class="language-Makefile">##@ [Application: QA]

.PHONY: test
test: ## Run the test suite 
    $(EXECUTE_IN_WORKER_CONTAINER) vendor/bin/phpunit -c phpunit.xml</code></pre>
<p>So I can run tests simply via <code>make test</code></p>
<pre><code>$ make test
ENV=local TAG=latest DOCKER_REGISTRY=docker.io DOCKER_NAMESPACE=dofroscra APP_USER_NAME=application APP_GROUP_NAME=application docker-compose -p dofroscra_local --env-file ./.docker/.env -f ./.docker/docker-compose/docker-compose.yml -f ./.docker/docker-compose/docker-compose.local.yml exec -T --user application php-worker vendor/bin/phpunit
PHPUnit 9.5.13 by Sebastian Bergmann and contributors.

.                                                                   1 / 1 (100%)

Time: 00:00.324, Memory: 4.00 MB

OK (1 test, 1 assertion)</code></pre>
<!-- generated -->
<p><a id='install-ssh'> </a></p>
<!-- /generated -->
<h3>Install SSH</h3>
<p>We will execute commands from PhpStorm via ssh in the <code>application</code> container. As mentioned, we
won't use a key file for authentication but will instead simply use a password that is
configured via the <code>APP_SSH_PASSWORD</code> variable in <code>.docker/.env</code> and passed to the image in
<code>.docker/docker-compose/docker-compose.local.yml</code>. In addition, we map port <code>2222</code> from the
host system to port <code>22</code> of the application container and make sure that the codebase is shared
as a volume between host and container</p>
<pre><code class="language-yaml">  application:
    build:
      args:
        - APP_SSH_PASSWORD=${APP_SSH_PASSWORD?}
    volumes:
      - ${APP_CODE_PATH_HOST?}:${APP_CODE_PATH_CONTAINER?}
    ports:
      - "${APPLICATION_SSH_HOST_PORT:-2222}:22"</code></pre>
<p>The container already contains <code>openssh</code> and sets the password</p>
<pre><code class="language-Dockerfile">ARG BASE_IMAGE
FROM ${BASE_IMAGE} as base

FROM base as local

RUN apk add --no-cache --update \
        openssh

ARG APP_SSH_PASSWORD
RUN echo "$APP_USER_NAME:$APP_SSH_PASSWORD" | chpasswd 2&gt;&amp;1

# Required to start sshd, otherwise the container will error out on startup with the message
# "sshd: no hostkeys available -- exiting."
# @see https://stackoverflow.com/a/65348102/413531 
RUN ssh-keygen -A

# we use SSH deployment configuration in PhpStorm for local development
EXPOSE 22

CMD ["/usr/sbin/sshd", "-D"]</code></pre>
<!-- generated -->
<p><a id='setup-phpstorm'> </a></p>
<!-- /generated -->
<h2>Setup PhpStorm</h2>
<p>We will configure a remote PHP interpreter that uses an SSH connection to run commands in the
<code>application</code> container. Before,
<a href="/blog/setup-phpstorm-with-xdebug-on-docker/#configure-the-deployment-configuration">we have been using an <code>SFTP Deployment configuration</code></a>
, which was kinda confusing (&quot;What is SFTP doing here?&quot;), so we will use an
<a href="https://www.jetbrains.com/help/phpstorm/create-ssh-configurations.html">SSH Configuration</a>
instead and configure the path mappings in the <strong>Cli Interpreter</strong> interface</p>
<!-- generated -->
<p><a id='ssh-configuration'> </a></p>
<!-- /generated -->
<h3>SSH Configuration</h3>
<p>At <code>File | Settings | Tools | SSH Configurations</code> create a new SSH Configuration named
&quot;Docker PHP Tutorial&quot; with the following settings </p>
<ul>
<li>Host: 127.0.0.1</li>
<li>Port: see <code>APPLICATION_SSH_HOST_PORT</code> in <code>.docker/docker-compose/docker-compose.local.yml</code></li>
<li>User name: see <code>APP_USER_NAME</code> in <code>.make/.env</code></li>
<li>Authentication type: Password</li>
<li>Password: see <code>APP_SSH_PASSWORD</code> in <code>.docker/.env</code></li>
</ul>
<p><a href="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-ssh-configuration.PNG"><img src="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-ssh-configuration.PNG" alt="PhpStorm SSH Configuration" title="PhpStorm SSH Configuration" /></a></p>
<!-- generated -->
<p><a id='php-interpreter'> </a></p>
<!-- /generated -->
<h3>PHP Interpreter</h3>
<p>At <code>File | Settings | PHP</code> add a new PHP CLI interpreter that uses the new SSH Configuration</p>
<p><a href="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-cli-interpreter.PNG"><img src="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-cli-interpreter.PNG" alt="PhpStorm new CLI interpreter" title="PhpStorm new CLI interpreter" /></a></p>
<p>In addition, we define the <strong>path to the xdebug extension</strong> because it is disabled by default but
PhpStorm can enable it automatically if required. You can find the path in the <code>application</code>
container via</p>
<pre><code>root:/var/www/app# php -i | grep extension_dir
extension_dir =&gt; /usr/lib/php8/modules =&gt; /usr/lib/php8/modules
root:/var/www/app# ll /usr/lib/php8/modules | grep xdebug
-rwxr-xr-x    1 root     root        303936 Jan  9 00:21 xdebug.so</code></pre>
<p>We still need to
<a href="/blog/setup-phpstorm-with-xdebug-on-docker/#fix-xdebug-on-phpstorm-when-run-from-a-docker-container">Fix Xdebug on PhpStorm when run from a Docker container</a>
by adding a custom PHP option for <code>xdebug.client_host=host.docker.internal</code>. That's the same value
we use in <code>.docker/images/php/base/conf.d/zz-app-local.ini</code>.</p>
<p><a href="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-cli-interpreter-xdebug.PNG"><img src="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-cli-interpreter-xdebug.PNG" alt="PhpStorm Xdebug settings for the CLI interpreter" title="PhpStorm Xdebug settings for the CLI interpreter" /></a></p>
<p>In the interpreter overview we must now configure the <strong>path mappings</strong> so that PhpStorm knows
&quot;which local file belongs to which remote one&quot;. The remote folder is defined in <code>.docker/.env</code> via</p>
<pre><code class="language-dotenv">APP_CODE_PATH_CONTAINER=/var/www/app</code></pre>
<p><a href="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-cli-interpreter-path-mappings.PNG"><img src="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-cli-interpreter-path-mappings.PNG" alt="PhpStorm path mappings for the CLI interpreter" title="PhpStorm path mappings for the CLI interpreter" /></a></p>
<p>Afterwards we can set a breakpoint e.g. in <code>setup.php</code> and start debugging:</p>
<p><a href="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-xdebug-breakpoint.PNG"><img src="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-xdebug-breakpoint.PNG" alt="PhpStorm debugging breakpoint" title="PhpStorm debugging breakpoint" /></a></p>
<p>The screenshot shows that PhpStorm adds the Xdebug extension that we defined previously.</p>
<!-- generated -->
<p><a id='phpunit'> </a></p>
<!-- /generated -->
<h3>PHPUnit</h3>
<p><code>phpunit</code> is configured via <code>File | Settings | PHP | Test Frameworks</code>. First, we select the
interpreter that we just added</p>
<p><a href="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-phpunit-interpreter.PNG"><img src="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-phpunit-interpreter.PNG" alt="Set up phpunit in PhpStorm" title="Set up phpunit in PhpStorm" /></a></p>
<p>Then, we add the paths to the composer autoload script and the <code>phpunit.xml</code> configuration file.</p>
<p><a href="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-phpunit-settings.PNG"><img src="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-phpunit-settings.PNG" alt="phpunit settings in PhpStorm" title="phpunit settings in PhpStorm" /></a></p>
<p>PhpStorm will now execute tests using the PHP interpreter in the <code>application</code> container</p>
<p><a href="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-run-phpunit-test.PNG"><img src="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-run-phpunit-test.PNG" alt="Run a phpunit test in PhpStorm" title="Run a phpunit test in PhpStorm" /></a></p>
<!-- generated -->
<p><a id='debugging'> </a></p>
<!-- /generated -->
<h3>Debugging</h3>
<p>First of all, if you haven't already please also take a look at the
<a href="https://xdebug.org/docs/step_debug">official xdebug documentation</a>. Derick is doing a great job
at explaining xdebug in detail including some helpful videos like
<a href="https://www.youtube.com/watch?v=4opFac50Vwo">Xdebug 3: Xdebug with Docker and PhpStorm in 5 minutes</a></p>
<!-- generated -->
<p><a id='debug-code-executed-via-phpstorm'> </a></p>
<!-- /generated -->
<h4>Debug code executed via PhpStorm</h4>
<p>This should already work out of the box. Simply set a break point, right-click on a file and choose
&quot;Debug '...'&quot;</p>
<p><a href="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-xdebug-breakpoint.PNG"><img src="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-xdebug-breakpoint.PNG" alt="PhpStorm debugging breakpoint" title="PhpStorm debugging breakpoint" /></a></p>
<!-- generated -->
<p><a id='debug-code-executed-via-php-fpm-cli-or-from-a-worker'> </a></p>
<!-- /generated -->
<h4>Debug code executed via php-fpm, cli or from a worker</h4>
<p>For code that is executed &quot;directly&quot; by a container without PhpStorm, we first need to enable
<code>xdebug</code> in the container by removing the <code>;</code> in front of the extension in
<code>/etc/php8/conf.d/zz-app-local.ini</code></p>
<pre><code>; Note:
; Remove the comment ; to enable debugging
zend_extension=xdebug</code></pre>
<p>To make this a little more convenient, we use dedicated make recipes for those actions in
<code>.make/01-01-application-commands.mk</code></p>
<pre><code class="language-Makefile">.PHONY: execute-in-container
execute-in-container: ## Execute a command in a container. E.g. via "make execute-in-container DOCKER_SERVICE_NAME=php-fpm COMMAND="echo 'hello'"
    @$(if $(DOCKER_SERVICE_NAME),,$(error DOCKER_SERVICE_NAME is undefined))
    @$(if $(COMMAND),,$(error COMMAND is undefined))
    $(EXECUTE_IN_CONTAINER) $(COMMAND);

.PHONY: enable-xdebug
enable-xdebug: ## Enable xdebug in the given container specified by "DOCKER_SERVICE_NAME". E.g. "make enable-xdebug DOCKER_SERVICE_NAME=php-fpm"
    "$(MAKE)" execute-in-container APP_USER_NAME="root" DOCKER_SERVICE_NAME=$(DOCKER_SERVICE_NAME) COMMAND="sed -i 's/.*zend_extension=xdebug/zend_extension=xdebug/' '/etc/php8/conf.d/zz-app-local.ini'"

.PHONY: disable-xdebug
disable-xdebug: ## Disable xdebug in the given container specified by "DOCKER_SERVICE_NAME". E.g. "make enable-xdebug DOCKER_SERVICE_NAME=php-fpm"
    "$(MAKE)" execute-in-container APP_USER_NAME="root" DOCKER_SERVICE_NAME=$(DOCKER_SERVICE_NAME) COMMAND="sed -i 's/.*zend_extension=xdebug/;zend_extension=xdebug/' '/etc/php8/conf.d/zz-app-local.ini'"</code></pre>
<p>To capture incoming requests, we need to make PhpStorm listen for PHP Debug connections via
<code>Run | Start Listening for PHP Debug Connections</code>. </p>
<p><a href="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-start-listening-for-debug-connections.PNG"><img src="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-start-listening-for-debug-connections.PNG" alt="PhpStorm: Start Listening for PHP Debug Connections" title="PhpStorm: Start Listening for PHP Debug Connections" /></a></p>
<p>The corresponding ports are configured at <code>File | Settings | PHP | Debug</code>. In Xdebug &lt; 3 the
default port was <code>9000</code> and in <a href="https://xdebug.org/docs/all_settings#client_port">Xdebug 3 it is <code>9003</code></a> </p>
<p><a href="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-xdebug-ports.PNG"><img src="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-xdebug-ports.PNG" alt="PhpStorm: configure xdebug ports" title="PhpStorm: configure xdebug ports" /></a></p>
<p>Finally, we need to add a server via <code>File | Settings | PHP | Servers</code></p>
<p><a href="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-server.PNG"><img src="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-server.PNG" alt="PhpStorm: configure a server" title="PhpStorm: configure a server" /></a></p>
<p>The name of the server must match the value of the <code>serverName</code> key in the environment variable
<code>PHP_IDE_CONFIG</code> that we configured previously as <code>serverName=dofroscra</code>.</p>
<!-- generated -->
<p><a id='php-fpm'> </a></p>
<!-- /generated -->
<h5>php-fpm</h5>
<p>For <code>php-fpm</code> we must
<a href="https://stackoverflow.com/a/43076457">restart the <code>php-fpm</code> process without restarting the container</a>
after we have activated <code>xdebug</code> via</p>
<pre><code>kill -USR2 1</code></pre>
<p>Since this is a pain to remember, we add a make target in <code>.make/01-01-application-commands.mk</code></p>
<pre><code class="language-Makefile"># @see https://stackoverflow.com/a/43076457
.PHONY: restart-php-fpm
restart-php-fpm: ## Restart the php-fpm service
    "$(MAKE)" execute-in-container DOCKER_SERVICE_NAME=$(DOCKER_SERVICE_NAME_PHP_FPM) COMMAND="kill -USR2 1"</code></pre>
<p>So we can now simply run</p>
<pre><code>make enable-xdebug DOCKER_SERVICE_NAME=php-fpm
make restart-php-fpm</code></pre>
<p>Setting a breakpoint in <code>public/index.php</code> and opening <a href="http://127.0.0.1/">http://127.0.0.1/</a> in
a browser or via <code>curl http://127.0.0.1/</code> will halt the execution as expected.</p>
<p><a href="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-xdebug-breakpoint-php-fpm.PNG"><img src="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-xdebug-breakpoint-php-fpm.PNG" alt="PhpStorm debugging breakpoint for php-fpm" title="PhpStorm debugging breakpoint for php-fpm" /></a></p>
<!-- generated -->
<p><a id='cli'> </a></p>
<!-- /generated -->
<h5>cli</h5>
<p>Instead of triggering a PHP script via HTTP request, we can also run CLI scripts - think of the
<code>make setup-db</code> target for instance. To debug such invocations, we need to follow the same steps
as before:</p>
<ul>
<li>enable the <code>xdebug</code> extension in the <code>application</code> container</li>
<li>&quot;Listening for PHP Debug Connections&quot; from PhpStorm</li>
</ul>
<p>Running the following make targets will trigger a breakpoint in <code>setup.php</code>:</p>
<pre><code>make enable-xdebug DOCKER_SERVICE_NAME=application
make setup-db</code></pre>
<p><a href="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-xdebug-breakpoint-cli.PNG"><img src="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-xdebug-breakpoint-cli.PNG" alt="PhpStorm debugging breakpoint for cli" title="PhpStorm debugging breakpoint for cli" /></a></p>
<!-- generated -->
<p><a id='php-workers'> </a></p>
<!-- /generated -->
<h5>php-workers</h5>
<p>And finally the same thing for long running PHP processes (aka workers). Just as before:</p>
<ul>
<li>enable the <code>xdebug</code> extension in the <code>php-worker</code> container</li>
<li>&quot;Listening for PHP Debug Connections&quot; from PhpStorm</li>
<li>restart the php workers  </li>
</ul>
<p>Running the following make targets will trigger a breakpoint in <code>worker.php</code>:</p>
<pre><code>make enable-xdebug DOCKER_SERVICE_NAME=php-worker
make restart-workers</code></pre>
<p><a href="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-xdebug-breakpoint-php-worker.PNG"><img src="/img/phpstorm-docker-xdebug-3-php-8-1-in-2022/phpstorm-xdebug-breakpoint-php-worker.PNG" alt="PhpStorm debugging breakpoint for php-workers" title="PhpStorm debugging breakpoint for php-workers" /></a></p>
<!-- generated -->
<p><a id='strace'> </a></p>
<!-- /generated -->
<h2>strace</h2>
<p><a href="https://strace.io/">strace</a> is a great tool for debugging long running processes that I've
adopted after reading <a href="https://derickrethans.nl/what-is-php-doing.html">What is PHP doing?</a>. I've
added it to the php base image:</p>
<pre><code class="language-Dockerfile">RUN apk add --update --no-cache \
        strace</code></pre>
<p>You can attach to any running process via <code>sudo strace -p $processId</code> - BUT that doesn't work
out of the box on docker and will fail with the error message</p>
<pre><code>strace: attach: ptrace(PTRACE_SEIZE, 1): Operation not permitted</code></pre>
<p>This is caused by a security measure from docker and
<a href="https://stackoverflow.com/a/46676868">can be circumvented</a> by adding</p>
<pre><code class="language-yaml">services:
  service:
    cap_add:
      - "SYS_PTRACE"
    security_opt:
      - "seccomp=unconfined"</code></pre>
<p>in <code>.docker/docker-compose/docker-compose.local.yml</code> <strong>to all PHP containers</strong>. After
rebuilding and restarting the docker setup, you can now e.g. log in the <code>php-worker</code> container
and run <code>strace</code> on a php worker process:</p>
<pre><code>application:/var/www/app# ps aux
PID   USER     TIME  COMMAND
    1 applicat  0:00 {supervisord} /usr/bin/python3 /usr/bin/supervisord
    7 applicat  0:00 php /var/www/app/worker.php
    8 applicat  0:00 php /var/www/app/worker.php
    9 applicat  0:00 php /var/www/app/worker.php
   10 applicat  0:00 php /var/www/app/worker.php
   11 applicat  0:00 bash
   20 applicat  0:00 ps aux
application:/var/www/app# sudo strace -p 7
strace: Process 7 attached
restart_syscall(&lt;... resuming interrupted read ...&gt;) = 0
poll([{fd=4, events=POLLIN|POLLPRI|POLLERR|POLLHUP}], 1, 0) = 0 (Timeout)
sendto(4, "*2\r\n$4\r\nRPOP\r\n$5\r\nqueue\r\n", 25, MSG_DONTWAIT, NULL, 0) = 25
poll([{fd=4, events=POLLIN|POLLPRI|POLLERR|POLLHUP}], 1, 0) = 1 ([{fd=4, revents=POLLIN}])
recvfrom(4, "$", 1, MSG_PEEK, NULL, NULL) = 1</code></pre>
<!-- generated -->
<p><a id='wrapping-up'> </a></p>
<!-- /generated -->
<h2>Wrapping up</h2>
<p>Congratulations, you made it! If some things are not completely clear by now, don't hesitate to
leave a comment. Apart from that, you should now have a fully configured development setup that
works with PhpStorm as your IDE.</p>
<p>In the next part of this tutorial, we will
<a href="/blog/run-laravel-9-docker-in-2022/">use a fresh installation of Laravel on top of our setup</a>.</p>
<p>Please subscribe to the <a href="/feed.xml">RSS feed</a> or <a href="#newsletter">via email</a> to get automatic
notifications when this next part comes out :)</p>]]></description>
                <pubDate>Tue, 22 Mar 2022 11:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/blog/phpstorm-docker-xdebug-3-php-8-1-in-2022/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/blog/phpstorm-docker-xdebug-3-php-8-1-in-2022/</guid>
            </item>
                    <item>
                <title>Docker from scratch for PHP 8.1 Applications in 2022 [Tutorial Part 4.1]</title>
                <description><![CDATA[<p>In the fourth part of this tutorial series on developing PHP on Docker we will revisit the previous
tutorials and update some things to be up-to-date in 2022. The article will be split in 3
subparts:</p>
<ul>
<li>Part 4.1: Update the code structure (<strong>this article</strong>)
<ul>
<li>we'll also introduce three new containers (PHP workers, MySQL and redis) and add a small proof
of concept to tie all containers together</li>
</ul></li>
<li>Part 4.2: Add the tools for local development (
<a href="/blog/phpstorm-docker-xdebug-3-php-8-1-in-2022/">PhpStorm, Docker and Xdebug 3 on PHP 8.1 in 2022</a>,
<strong>available at 2022-03-22</strong>)
<ul>
<li>make the setup work with PhpStorm, including the ability to execute phpunit tests and run
xdebug for all php containers (application, fpm and php workers)</li>
</ul></li>
<li>Part4.3: Include Laravel (
<a href="/blog/run-laravel-9-docker-in-2022/">Run Laravel 9 on Docker in 2022</a>,
<strong>available at 2022-03-23</strong>)
<ul>
<li>refactor the code to use Commands, Controllers, Queues, etc.</li>
</ul></li>
</ul>
<div class="center-div">
<iframe width="560" height="315" src="https://www.youtube.com/embed/NuSWKx9FSso" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<p>All code samples are publicly available in my
<a href="https://github.com/paslandau/docker-php-tutorial">Docker PHP Tutorial repository on github</a>.<br />
You find the branch for this tutorial at
<a href="https://github.com/paslandau/docker-php-tutorial/tree/part-4-1-docker-from-scratch-for-php-applications-in-2022">part-4-1-docker-from-scratch-for-php-applications-in-2022</a></p>
<!-- generated -->
<p><a id='published-parts-of-the-docker-php-tutorial'> </a></p>
<!-- /generated -->
<h2>Published parts of the Docker PHP Tutorial</h2>
<ul>
<li><a href="/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/">Setting up PHP, PHP-FPM and NGINX for local development on Docker</a>
(2018-07-08)</li>
<li><a href="/blog/setup-phpstorm-with-xdebug-on-docker/">Setting up PhpStorm with Xdebug for local development on Docker</a>
(2018-08-06)</li>
<li><a href="/blog/structuring-the-docker-setup-for-php-projects/">Structuring the Docker setup for PHP Projects</a>
(2019-05-20)</li>
<li><a href="/blog/docker-from-scratch-for-php-applications-in-2022/">Docker from scratch for PHP 8.1 Applications in 2022</a>
(2022-03-21)</li>
<li><a href="/blog/phpstorm-docker-xdebug-3-php-8-1-in-2022/">PhpStorm, Docker and Xdebug 3 on PHP 8.1 in 2022</a>
(2022-03-22)</li>
<li><a href="/blog/run-laravel-9-docker-in-2022/">Run Laravel 9 on Docker in 2022</a>
(2022-03-23)</li>
</ul>
<p>If you want to follow along, please subscribe to the <a href="/feed.xml">RSS feed</a>
or <a href="#newsletter">via email</a>
to get automatic notifications when the next part comes out :)</p>
<!-- generated -->
<p><a id='table-of-contents'> </a></p>
<!-- /generated -->
<h2>Table of contents</h2>
<!-- toc -->
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#local-docker-setup">Local docker setup</a></li>
<li><a href="#makefile">Makefile</a>
<ul>
<li><a href="#make-mk-includes"><code>.make/*.mk</code> includes</a></li>
<li><a href="#shared-variables-make-env">Shared variables: <code>.make/.env</code></a>
<ul>
<li><a href="#enforce-required-parameters">Enforce required parameters</a></li>
</ul></li>
</ul></li>
<li><a href="#docker">Docker</a>
<ul>
<li><a href="#docker-compose">docker-compose</a>
<ul>
<li><a href="#docker-env-file-and-required-env-variables"><code>.docker/.env</code> file and required ENV variables</a></li>
</ul></li>
<li><a href="#images">Images</a>
<ul>
<li><a href="#php-images">PHP images</a>
<ul>
<li><a href="#env-vs-arg">ENV vs ARG</a></li>
</ul></li>
<li><a href="#image-naming-convention">Image naming convention</a></li>
<li><a href="#environments-and-build-targets">Environments and build targets</a></li>
</ul></li>
</ul></li>
<li><a href="#make-docker-3">Make + Docker = &lt;3</a>
<ul>
<li><a href="#ensuring-the-build-order">Ensuring the build order</a></li>
<li><a href="#run-commands-in-the-docker-containers">Run commands in the docker containers</a></li>
</ul></li>
<li><a href="#php-poc">PHP POC</a></li>
<li><a href="#wrapping-up">Wrapping up</a></li>
</ul>
<!-- /toc -->
<!-- generated -->
<p><a id='introduction'> </a></p>
<!-- /generated -->
<h2>Introduction</h2>
<p>If you have read the previous
tutorial <a href="/blog/structuring-the-docker-setup-for-php-projects/">Structuring the Docker setup for PHP Projects</a>
you might encounter some significant changes. The tutorial was published over 2 years ago,
Docker has evolved and I have learned more about it. Plus, I gathered practical
experience (good and bad) with the previous setup. I would now consider most of the points under
<a href="/blog/structuring-the-docker-setup-for-php-projects/#fundamentals-on-building-the-containers">Fundamentals on building the containers</a>
as either &quot;not required&quot; or simply &quot;overengineered / too complex&quot;. To be concrete:</p>
<ul>
<li><a href="/blog/structuring-the-docker-setup-for-php-projects/#setting-the-timezone">Setting the timezone</a>
<ul>
<li>not required if the default is already UTC (which is almost always the case)</li>
</ul></li>
<li><a href="/blog/structuring-the-docker-setup-for-php-projects/#synchronizing-file-and-folder-ownership-on-shared-volumes">Synchronizing file and folder ownership on shared volumes</a>
<ul>
<li>this is only an issue if files need to be <strong>modified</strong> by containers and the host system - which
is only really relevant for the PHP containers</li>
<li>in addition, I would recommend adding a completely new user (e.g. <code>application</code>) instead of
re-using an existing one like <code>www-data</code> - this simplifies the whole user setup <em>a lot</em></li>
</ul></li>
<li><a href="/blog/structuring-the-docker-setup-for-php-projects/#modifying-configuration-files">Modifying configuration files</a>
<ul>
<li>just use <code>sed</code> - no need for a dedicated script</li>
</ul></li>
<li><a href="/blog/structuring-the-docker-setup-for-php-projects/#installing-php-extensions">Installing php extensions</a>
<ul>
<li>see <a href="#php-images">PHP images</a> - will now be done via <code>apk add</code></li>
</ul></li>
<li><a href="/blog/structuring-the-docker-setup-for-php-projects/#installing-common-software">Installing common software</a>
<ul>
<li>see <a href="#php-images">PHP images</a> - since there is only one base image there is no need for a
dedicated script</li>
</ul></li>
<li><a href="/blog/structuring-the-docker-setup-for-php-projects/#cleaning-up">Cleaning up</a>
<ul>
<li>didn't really make sense because the &quot;cleaned up files&quot; were already part of a previous layer</li>
<li>we might &quot;bring it back&quot; later when we optimize the image size to speed up the pushing/pulling
of the images to/from the registry</li>
</ul></li>
<li><a href="/blog/structuring-the-docker-setup-for-php-projects/#providing-host-docker-internal-for-linux-host-systems">Providing host.docker.internal for linux host systems</a>
<ul>
<li>can now be done via
the <a href="https://github.com/docker/for-linux/issues/264#issuecomment-965465879"><code>host-gateway</code> magic reference</a>
<pre><code class="language-yaml">services:
 myservice:
      extra_hosts:
        - host.docker.internal:host-gateway</code></pre></li>
<li>thus, no custom entrypoint is required any longer</li>
</ul></li>
</ul>
<!-- generated -->
<p><a id='local-docker-setup'> </a></p>
<!-- /generated -->
<h2>Local docker setup</h2>
<p>The goal of this part is the introduction of a working local setup <strong>without development tools</strong>. In
other words: We want the bare minimum to have something running locally.</p>
<p>The main components are:</p>
<ul>
<li>the <code>make</code> setup in the <code>Makefile</code> and in the <code>.make/</code> directory</li>
<li>the docker setup in the <code>.docker/</code> directory</li>
<li>some PHP files that act as a POC for the end2end functionality of the docker setup</li>
</ul>
<p>Check out the code via</p>
<pre><code>git checkout part_4_section_1_docker_from_scratch_for_php_applications_in_2022_code_structure</code></pre>
<p>initialize it via</p>
<pre><code>make make-init
make docker-build</code></pre>
<p>and run it via</p>
<pre><code>make docker-up</code></pre>
<p>Now you can access the web interface via <a href="http://127.0.0.1">http://127.0.0.1</a>. The following
diagram shows how the containers are connected</p>
<p><a href="/img/docker-from-scratch-for-php-applications-in-2022/docker-containers.PNG"><img src="/img/docker-from-scratch-for-php-applications-in-2022/docker-containers.PNG" alt="Docker container connections" title="Docker container connections" /></a></p>
<p>See also the <a href="#php-poc">PHP POC</a> for a full test of the setup.</p>
<!-- generated -->
<p><a id='makefile'> </a></p>
<!-- /generated -->
<h2>Makefile</h2>
<p>The <code>make</code> setup introduces a self-documenting <code>make</code> configuration
that <a href="/blog/structuring-the-docker-setup-for-php-projects/#using-make-as-central-entry-point">acts as the central entrypoint in the application</a>.</p>
<!-- generated -->
<p><a id='make-mk-includes'> </a></p>
<!-- /generated -->
<h3><code>.make/*.mk</code> includes</h3>
<p>Over time the <code>make</code> setup will grow substantially, thus we split it into multiple <code>.mk</code> files in
the <code>.make/</code> directory. The individual files are prefixed with a number to ensure their order when
we include them in the main <code>Makefile</code> via</p>
<pre><code>include .make/*.mk</code></pre>
<pre><code>.
└── .make/
    ├── 01-00-application-setup.mk
    ├── 01-01-application-commands.mk
    └── 02-00-docker.mk</code></pre>
<!-- generated -->
<p><a id='shared-variables-make-env'> </a></p>
<!-- /generated -->
<h3>Shared variables: <code>.make/.env</code></h3>
<p>We try to make <strong>shared variables</strong> available here, because we can then pass them on to individual
commands as a prefix, e.g.</p>
<pre><code class="language-makefile">.PHONY: some-target
some-target: ## Run some target
    ENV_FOO=BAR some_command --baz</code></pre>
<p>This will make the <code>ENV_FOO</code> available as environment variable to <code>some_command</code>.</p>
<p>Shared variables are used by different components, and we always try to maintain only a <strong>single
source of truth</strong>. An example would be the <code>DOCKER_REGISTRY</code> variable that we need to define the
<a href="#image-naming-convention">image names of our docker images</a> in the <code>docker-compose.yml</code> files but
also when pushing/pulling/deploying images via make targets later. In this case, the variable is
required by <code>make</code> as well as <code>docker-compose</code>.</p>
<p>To have a clear separation between variables and &quot;code&quot;, we use a <code>.env</code> file located
at <code>. make/.env</code>. It can be initialized via</p>
<pre><code>make make-init</code></pre>
<p>by copying the <code>.make/.env.example</code> to <code>.make/.env</code>. </p>
<pre><code>.
└── .make/
    ├── .make/.env.example
    └── .make/.env</code></pre>
<p>The file is included in the main <code>Makefile</code> via</p>
<pre><code>-include .make/.env</code></pre>
<p>The <code>-</code> prefix ensures that make doesn't fail if the file does not exist (yet), see
<a href="https://www.gnu.org/software/make/manual/html_node/Include.html">GNU make: Including Other Makefiles</a></p>
<!-- generated -->
<p><a id='enforce-required-parameters'> </a></p>
<!-- /generated -->
<h4>Enforce required parameters</h4>
<p>We kinda &quot;abuse&quot; make for executing arbitrary commands (instead of building artifacts) and some of
those commands require parameters that can be
<a href="https://stackoverflow.com/a/2826178/413531">passed as command arguments</a> in the form</p>
<pre><code>make some-target FOO=bar</code></pre>
<p>There is no way to &quot;define&quot; those parameters as we would in a method signature - but we can still
ensure to fail as early as possible if a parameter is missing via</p>
<pre><code class="language-makefile">@$(if $(FOO),,$(error FOO is empty or undefined))</code></pre>
<p>See
also <a href="https://stackoverflow.com/a/10858332/413531">SO: How to abort makefile if variable not set?</a></p>
<p>We use this technique for example to ensure that all required variables are defined when we execute
docker targets via the <code>validate-docker-variables</code> precondition target:</p>
<pre><code class="language-makefile">.PHONY: validate-docker-variables
validate-docker-variables: 
    @$(if $(TAG),,$(error TAG is undefined))
    @$(if $(ENV),,$(error ENV is undefined))
    @$(if $(DOCKER_REGISTRY),,$(error DOCKER_REGISTRY is undefined - Did you run make-init?))
    @$(if $(DOCKER_NAMESPACE),,$(error DOCKER_NAMESPACE is undefined - Did you run make-init?))
    @$(if $(APP_USER_NAME),,$(error APP_USER_NAME is undefined - Did you run make-init?))
    @$(if $(APP_GROUP_NAME),,$(error APP_GROUP_NAME is undefined - Did you run make-init?))

.PHONY:docker-build-image
docker-build-image: validate-docker-variables
    $(DOCKER_COMPOSE) build $(DOCKER_SERVICE_NAME)</code></pre>
<!-- generated -->
<p><a id='docker'> </a></p>
<!-- /generated -->
<h2>Docker</h2>
<p>The docker setup consists of</p>
<ul>
<li>an nginx container as a webserver</li>
<li>a MySQL database container</li>
<li>a Redis container that acts as a queue</li>
<li>a php base image that is used by
<ul>
<li>a php worker container that spawns multiple PHP worker processes via <code>supervisor</code></li>
<li>a php-fpm container as a backend for the nginx container</li>
<li>an application container that we use to run commands</li>
</ul></li>
</ul>
<p><a href="/img/docker-from-scratch-for-php-applications-in-2022/docker-images.PNG"><img src="/img/docker-from-scratch-for-php-applications-in-2022/docker-images.PNG" alt="Docker images" title="Docker images" /></a></p>
<p>We keep the <a href="/blog/structuring-the-docker-setup-for-php-projects/#the-docker-folder"><code>.docker/</code> directory from the previous tutorial</a>
, though it will be split into <code>docker-compose/</code> and <code>images/</code> like so:</p>
<pre><code>.
└── .docker/
    ├── docker-compose/
    |   ├── docker-compose.yml
    |   └── &lt;other docker-compose files&gt;
    ├── images/
    |   ├── nginx/
    |   |   ├── Dockerfile
    |   |   └── &lt;other files for the nginx image&gt;
    |   └── &lt;other folders for docker images&gt;
    ├── .env
    └── .env.example</code></pre>
<!-- generated -->
<p><a id='docker-compose'> </a></p>
<!-- /generated -->
<h3>docker-compose</h3>
<p>All images are <strong>build</strong> via <code>docker-compose</code> because the <code>docker-compose.yml</code> file(s) provide a nice
abstraction layer for the build configuration. In addition, we can also use it to <strong>orchestrate</strong> the
containers, i.e. control volumes, port mappings, networking, etc. - as well as start and stop them
via <code>docker-compose up</code> and <code>docker-compose down</code>.</p>
<p>FYI: Even though it is <em>convenient</em> to use <code>docker-compose</code> for both things, I found it also to make
the setup more complex than it needs to be when running things later in production (when we are
<em>not</em> using <code>docker-compose</code> any longer). I believe the problem here is that some modifications are
ONLY required for building while others are ONLY required for running - and combining both in the
same file yields a certain amount of noise. But: It is what it is.</p>
<p>We use three separate <code>docker-compose.yml</code> files:</p>
<ul>
<li>docker-compose.yml
<ul>
<li>contains all information valid for all environments</li>
</ul></li>
<li>docker-compose.local.yml
<ul>
<li>contains information specific to the <code>local</code> environment,
see <a href="#environments-and-build-targets">Environments and build targets</a></li>
</ul></li>
<li>docker-compose-php-base.yml
<ul>
<li>contains information for building the php base image, see <a href="#php-images">PHP images</a></li>
</ul></li>
</ul>
<!-- generated -->
<p><a id='docker-env-file-and-required-env-variables'> </a></p>
<!-- /generated -->
<h4><code>.docker/.env</code> file and required ENV variables</h4>
<p>In our docker setup we basically have 3 different types of variables:</p>
<ol>
<li>variables that <strong>depend on the local setup</strong> of an individual developer, e.g. the
<code>NGINX_HOST_HTTP_PORT</code> on the host machine (because the default one might already be in use)</li>
<li>variables that <strong>are used in multiple images</strong>, e.g. the location of the codebase within a
container's file system</li>
<li>variables that <strong>hold information that is &quot;likely to change&quot;</strong>, e.g. the exact version of a base
image</li>
</ol>
<p>Since - again - we strive to retain a single source of truth, we extract the information as
variables and put them in a <code>.docker/.env</code> file. In a perfect world, I would like to separate these
different types in different files - but <code>docker-compose</code> only allows a single <code>.env</code> file, see
e.g. <a href="https://github.com/docker/compose/issues/6170#issuecomment-443523663">this comment</a>.
If the file does not exist, it is copied from <code>.docker/.env.example</code>.</p>
<p>The variables are then used in the <code>docker-compose.yml</code> file(s). I found it to be &quot;the least
painful&quot; to always use
the <a href="https://docs.docker.com/compose/environment-variables/#substitute-environment-variables-in-compose-files"><code>?</code> modifier on variables</a>
so that <code>docker-compose</code> <strong>fails immediately if the variable is missing</strong>.</p>
<p>Note: Some variables are expected to be passed via environment variables when <code>docker-compose</code>
is invoked (i.e. they are required but not defined in the <code>.env</code> file; see also
<a href="#shared-variables-make-env">Shared variables: <code>.make/.env</code></a></p>
<!-- generated -->
<p><a id='images'> </a></p>
<!-- /generated -->
<h3>Images</h3>
<p>For <strong>MySQL</strong> and <strong>redis</strong> we do not use custom-built images but instead <strong>use the official ones
<em>directly</em></strong> and configure them through environment variables when starting the containers. In
production, we won't use docker anyway for these services but instead rely on the managed versions,
e.g.</p>
<ul>
<li>redis =&gt; <a href="https://cloud.google.com/memorystore/docs/redis">Memorystore for Redis (GCP)</a> or
<a href="https://aws.amazon.com/de/elasticache/redis/">ElastiCache für Redis (AWS)</a></li>
<li>mysql =&gt; <a href="https://cloud.google.com/sql/docs/mysql">Cloud SQL for MySQL (GCP)</a> or
<a href="https://aws.amazon.com/de/rds/mysql/">RDS for MySQL (AWS)</a></li>
</ul>
<p>The remaining containers are defined in their respective subdirectories in the <code>.docker/images/</code>
directory, e.g. the image for the <code>nginx</code> container is build via the <code>Dockerfile</code> located in
<code>.docker/images/nginx/Dockerfile</code>.</p>
<!-- generated -->
<p><a id='php-images'> </a></p>
<!-- /generated -->
<h4>PHP images</h4>
<p>We need 3 different PHP images (fpm, workers, application) and use a slightly different approach
than
in <a href="/blog/structuring-the-docker-setup-for-php-projects/">Structuring the Docker setup for PHP Projects</a>:</p>
<p>Instead of using the <a href="https://hub.docker.com/_/php">official PHP base images</a> (i.e. cli or fpm), we
use a &quot;plain&quot; alpine base image and install PHP and the required extensions manually in it. This
allows us to build a common base image for all PHP images. Benefits:</p>
<ul>
<li>a central place for shared tools and configuration (no more need for a <code>.shared/</code> directory)</li>
<li>reduced image size when pushing the individual images (the base image is recognized as a layer and
thus &quot;already exists&quot;)</li>
<li>installing extensions via <code>apk add</code> is <strong>a lot</strong> faster than via <code>docker-php-ext-install</code></li>
</ul>
<p>This new approach has two major downsides:</p>
<ul>
<li>we depend on the alpine release cycle of PHP (and PHP extensions)</li>
<li>the image build process is more complex, because we must build the base image first before we can
build the final images</li>
</ul>
<p>Fortunately, both issues can be solved rather easily:</p>
<ul>
<li><a href="https://github.com/codecasts/php-alpine">codecasts/php-alpine</a> maintains an <code>apk</code> repository with
the latest PHP versions for alpine</li>
<li>we use a dedicated <code>make</code> target to build the images instead of invoking <code>docker-compose</code>
directly - this enables us to define a &quot;build order&quot; (base first, rest after) while still having
to run only a single command as a developer
(see <a href="#ensuring-the-build-order">Ensuring the build order</a>)</li>
</ul>
<!-- generated -->
<p><a id='env-vs-arg'> </a></p>
<!-- /generated -->
<h5>ENV vs ARG</h5>
<p>I've noticed that some build arguments are required in multiple PHP containers, e.g. the name of the
application user defined in the <code>APP_USER_NAME</code> ENV variable. The username is needed</p>
<ul>
<li>in the base image to create the user</li>
<li>in the fpm image to define the user that runs the fpm processes (see <code>php-fpm.d/www.conf</code>)</li>
<li>in the worker image to define the user that runs the worker processes (
see <code>supervisor/supervisord.conf</code>)</li>
</ul>
<p>Instead of passing the name to all images via build argument, i.e.</p>
<ul>
<li>define it explicitly under <code>services.*.build.args</code> in the <code>docker-compose.yml</code> file</li>
<li>&quot;retrieve&quot; it in the Dockerfile via <code>ARG APP_USER_NAME</code></li>
</ul>
<p>I've opted to make the username available as an <code>ENV</code> variable in the base image via</p>
<pre><code>ARG APP_USER_NAME
ENV APP_USER_NAME=${APP_USER_NAME}</code></pre>
<p>and thus be able to access it in the child images directly, I can now write</p>
<pre><code>RUN echo ${APP_USER_NAME}</code></pre>
<p>instead of</p>
<pre><code>ARG APP_USER_NAME
RUN echo ${APP_USER_NAME}</code></pre>
<p>I'm not 100% certain that I like this approach as I'm more or less &quot;abusing&quot; ENV variables in ways
that they are likely not intended (&quot;Why would the username need to be stored as an ENV variable?&quot;) -
but I also don't see any other practical downside yet.</p>
<!-- generated -->
<p><a id='image-naming-convention'> </a></p>
<!-- /generated -->
<h4>Image naming convention</h4>
<p>Defining a <a href="https://windsock.io/referencing-docker-images/">fully qualified name for images</a> will
make it much easier to reference the images later, e.g. when pushing them to the registry.</p>
<p>The naming convention for the images is
<code>$(DOCKER_REGISTRY)/$(DOCKER_NAMESPACE)/$(DOCKER_SERVICE_NAME)-$(ENV)</code>, e.g.</p>
<pre><code>                   docker.io/dofroscra/nginx-local
$(DOCKER_REGISTRY)---^          ^        ^     ^        docker.io
$(DOCKER_NAMESPACE)-------------^        ^     ^        dofroscra
$(DOCKER_SERVICE_NAME)-------------------^     ^        nginx
$(ENV)-----------------------------------------^        local</code></pre>
<p>and it is used as value for <code>services.*.image</code>, e.g. for <code>nginx</code></p>
<pre><code class="language-yaml">services:
  nginx:
    image: ${DOCKER_REGISTRY?}/${DOCKER_NAMESPACE?}/nginx-${ENV?}:${TAG?}</code></pre>
<p>In case you are wondering: <code>dofroscra</code> stems from <strong>Do</strong>cker <strong>Fro</strong>m <strong>Scra</strong>tch</p>
<!-- generated -->
<p><a id='environments-and-build-targets'> </a></p>
<!-- /generated -->
<h4>Environments and build targets</h4>
<p>Our final goal is a setup that we can use for</p>
<ul>
<li>local development</li>
<li>in a CI/CD pipeline</li>
<li>in production</li>
</ul>
<p>and even though we strive to for
a <a href="https://12factor.net/dev-prod-parity">parity between those different environments</a>, there will be
differences due to fundamentally different requirements. E.g.</p>
<ul>
<li>on <em>production</em> I want a container <strong>including the sourcecode without any test dependencies</strong></li>
<li>on <em>CI</em> I want a container <strong>including the sourcecode WITH test dependencies</strong></li>
<li>on <em>local</em> I want a container <strong>that mounts the sourcecode from my host (including
dependencies)</strong></li>
</ul>
<p>This is reflected through the <code>ENV</code> environment variable. We use it in two places:</p>
<ol>
<li>as part of the image name as a suffix of the service name
(see <a href="#image-naming-convention">Image naming convention</a>)</li>
<li>to specify
the <a href="https://docs.docker.com/engine/reference/commandline/build/#specifying-target-build-stage---target">target build stage</a></li>
</ol>
<p>See the <code>docker-compose-php-base.yml</code> file for example:</p>
<pre><code>services:
  php-base:
    image: ${DOCKER_REGISTRY?}/${DOCKER_NAMESPACE?}/php-base-${ENV?}:${TAG?}
    build:
      dockerfile: images/php/base/Dockerfile
      target: ${ENV?}</code></pre>
<p>Using <strong>multiple targets in the same Dockerfile</strong> enables us to keep a <strong>common base</strong> but also
include <strong>environment specific instructions</strong>. See the Dockerfile of the <code>php-base</code> image for
example</p>
<pre><code class="language-Dockerfile">ARG ALPINE_VERSION
FROM composer:${COMPOSER_VERSION} as composer
FROM alpine:${ALPINE_VERSION} as base

RUN apk add --update --no-cache \
        bash

WORKDIR $APP_CODE_PATH

FROM base as local

RUN apk add --no-cache --update \
        mysql-client \</code></pre>
<ul>
<li>it first defines a <code>base</code> stage that includes software required in all environments</li>
<li>and then defines a <code>local</code> stage that adds additionally a <code>mysql-client</code> that helps us to debug
connectivity issues</li>
</ul>
<p>After the build for <code>local</code> is finished, we end up with an image called <code>php-base-local</code> that used
the <code>local</code> build stage as target build stage.</p>
<!-- generated -->
<p><a id='make-docker-3'> </a></p>
<!-- /generated -->
<h2>Make + Docker = &lt;3</h2>
<p>We already introduced quite some complexity into our setup:</p>
<ul>
<li>&quot;global&quot; variables (shared between <code>make</code> and <code>docker</code>)</li>
<li>multiple <code>docker-compose.yml</code> files</li>
<li>build dependencies</li>
</ul>
<p>Bringing it all together &quot;manually&quot; is quite an effort and prone to errors. But we can nicely tuck
the complexity away in <code>.make/02-00-docker.mk</code> by defining the two variables
<code>DOCKER_COMPOSE</code> and <code>DOCKER_COMPOSE_PHP_BASE</code></p>
<pre><code class="language-makefile">DOCKER_DIR:=./.docker
DOCKER_ENV_FILE:=$(DOCKER_DIR)/.env
DOCKER_COMPOSE_DIR:=$(DOCKER_DIR)/docker-compose
DOCKER_COMPOSE_FILE:=$(DOCKER_COMPOSE_DIR)/docker-compose.yml
DOCKER_COMPOSE_FILE_LOCAL:=$(DOCKER_COMPOSE_DIR)/docker-compose.local.yml
DOCKER_COMPOSE_FILE_PHP_BASE:=$(DOCKER_COMPOSE_DIR)/docker-compose-php-base.yml
DOCKER_COMPOSE_PROJECT_NAME:=dofroscra_$(ENV)

DOCKER_COMPOSE_COMMAND:=ENV=$(ENV) \
 TAG=$(TAG) \
 DOCKER_REGISTRY=$(DOCKER_REGISTRY) \
 DOCKER_NAMESPACE=$(DOCKER_NAMESPACE) \
 APP_USER_NAME=$(APP_USER_NAME) \
 APP_GROUP_NAME=$(APP_GROUP_NAME) \
 docker-compose -p $(DOCKER_COMPOSE_PROJECT_NAME) --env-file $(DOCKER_ENV_FILE)

DOCKER_COMPOSE:=$(DOCKER_COMPOSE_COMMAND) -f $(DOCKER_COMPOSE_FILE) -f $(DOCKER_COMPOSE_FILE_LOCAL)
DOCKER_COMPOSE_PHP_BASE:=$(DOCKER_COMPOSE_COMMAND) -f $(DOCKER_COMPOSE_FILE_PHP_BASE)</code></pre>
<ul>
<li><code>DOCKER_COMPOSE</code> uses <code>docker-compose.yml</code> and extends it with <code>docker-compose.local.yml</code></li>
<li><code>DOCKER_COMPOSE_PHP_BASE</code> uses only <code>docker-compose-php-base.yml</code></li>
</ul>
<p>The variables can then be used later in make recipes. </p>
<!-- generated -->
<p><a id='ensuring-the-build-order'> </a></p>
<!-- /generated -->
<h3>Ensuring the build order</h3>
<p>As mentioned under <a href="#php-images">PHP images</a>, we need to build images in a certain order and use
the following make targets:</p>
<pre><code class="language-makefile">.PHONY: docker-build-image
docker-build-image: ## Build all docker images OR a specific image by providing the service name via: make docker-build DOCKER_SERVICE_NAME=&lt;service&gt;
    $(DOCKER_COMPOSE) build $(DOCKER_SERVICE_NAME)

.PHONY: docker-build-php
docker-build-php: ## Build the php base image
    $(DOCKER_COMPOSE_PHP_BASE) build $(DOCKER_SERVICE_NAME_PHP_BASE)

.PHONY: docker-build
docker-build: docker-build-php docker-build-image ## Build the php image and then all other docker images</code></pre>
<p>As a developer, I can now simply run <code>make docker-build</code> - which will first build the <code>php-base</code>
image via <code>docker-build-php</code> and then build all the remaining images via <code>docker-build-image</code>
(by not specifying the <code>DOCKER_SERVICE_NAME</code> variable, <code>docker-compose</code> will build <strong>all</strong> services
listed in the <code>docker-compose.yml</code> files).</p>
<p>I would argue that the make recipes themselves are quite readable and easy to understand but when
we run
them with the <a href="https://www.gnu.org/software/make/manual/html_node/Options-Summary.html"><code>-n</code> option</a>
to only &quot;Print the recipe that would be executed, but not execute it&quot;, we get a feeling for the
complexity:</p>
<pre><code>$ make docker-build -n
ENV=local TAG=latest DOCKER_REGISTRY=docker.io DOCKER_NAMESPACE=dofroscra APP_USER_NAME=application APP_GROUP_NAME=application docker-compose -p dofroscra_local --env-file ./.docker/.env -f ./.docker/docker-compose/docker-compose-php-base.yml build php-base
ENV=local TAG=latest DOCKER_REGISTRY=docker.io DOCKER_NAMESPACE=dofroscra APP_USER_NAME=application APP_GROUP_NAME=application docker-compose -p dofroscra_local --env-file ./.docker/.env -f ./.docker/docker-compose/docker-compose.yml -f ./.docker/docker-compose/docker-compose.local.yml build</code></pre>
<!-- generated -->
<p><a id='run-commands-in-the-docker-containers'> </a></p>
<!-- /generated -->
<h3>Run commands in the docker containers</h3>
<p>Tooling is an important part in the development workflow. This includes things like linters, static
analyzers and testing tools but also &quot;custom&quot; tools geared towards your specific workflow. Those
tools usually <strong>require a PHP runtime</strong>. For now, we only have a single &quot;tool&quot; defined in the
file <code>setup.php</code>. It ensures that a table called <code>jobs</code> is created.</p>
<p>To run this tool, we must first start the docker setup via <code>make docker-up</code> and then execute the
script in the <code>application</code> container. The corresponding target is defined in
<code>.make/01-00-application-setup.mk</code>:</p>
<pre><code class="language-makefile">.PHONY: setup-db
setup-db: ## Setup the DB tables
    $(EXECUTE_IN_APPLICATION_CONTAINER) php setup.php $(ARGS);</code></pre>
<p>which essentially translates to</p>
<pre><code>docker-compose exec -T --user application application php setup.php</code></pre>
<p>if we are outside of a container and to</p>
<pre><code>php setup.php</code></pre>
<p>if we are inside a container. That's quite handy, because we can <strong>run the tooling directly from the
host system</strong> without having to log into a container.</p>
<p>The &quot;magic&quot; happens in the <code>EXECUTE_IN_APPLICATION_CONTAINER</code> variable that is defined in
<code>.make/02-00-docker.mk</code> as</p>
<pre><code class="language-makefile">EXECUTE_IN_WORKER_CONTAINER?=
EXECUTE_IN_APPLICATION_CONTAINER?=

EXECUTE_IN_CONTAINER?=
ifndef EXECUTE_IN_CONTAINER
    # check if 'make' is executed in a docker container, 
    # see https://stackoverflow.com/a/25518538/413531
    # `wildcard $file` checks if $file exists, 
    # see https://www.gnu.org/software/make/manual/html_node/Wildcard-Function.html
    # i.e. if the result is "empty" then $file does NOT exist 
    # =&gt; we are NOT in a container
    ifeq ("$(wildcard /.dockerenv)","")
        EXECUTE_IN_CONTAINER=true
    endif
endif
ifeq ($(EXECUTE_IN_CONTAINER),true)
    EXECUTE_IN_APPLICATION_CONTAINER:=$(DOCKER_COMPOSE) exec -T --user $(APP_USER_NAME) $(DOCKER_SERVICE_NAME_APPLICATION)
    EXECUTE_IN_WORKER_CONTAINER:=$(DOCKER_COMPOSE) exec -T --user $(APP_USER_NAME) $(DOCKER_SERVICE_NAME_PHP_WORKER)
endif</code></pre>
<p>We can take a look via <code>-n</code> again to see the resolved recipe on the host system</p>
<pre><code>pascal.landau:/c/_codebase/dofroscra# make setup-db ARGS=--drop -n
ENV=local TAG=latest DOCKER_REGISTRY=docker.io DOCKER_NAMESPACE=dofroscra APP_USER_NAME=application APP_GROUP_NAME=application docker-compose -p dofroscra_local --env-file ./.docker/.env -f ./.docker/docker-compose/docker-compose.yml -f ./.docker/docker-compose/docker-compose.local.yml exec -T --user application application php setup.php --drop</code></pre>
<p>Within a container it looks like this:</p>
<pre><code>root:/var/www/app# make setup-db ARGS=--drop -n
php setup.php --drop;</code></pre>
<!-- generated -->
<p><a id='php-poc'> </a></p>
<!-- /generated -->
<h2>PHP POC</h2>
<p>To ensure that everything works as expected, the repository contains a minimal PHP proof of concept.
By default, port 80 from the host ist forwarded to port 80 of the <code>nginx</code> container.</p>
<p>FYI: I would also recommend to add the following entry
<a href="https://www.howtogeek.com/howto/27350/beginner-geek-how-to-edit-your-hosts-file/">in the hosts file on the host machine</a></p>
<pre><code>127.0.0.1 app.local</code></pre>
<p>so that we can access the application via <a href="http://app.local">http://app.local</a> instead
of <a href="http://127.0.0.1">http://127.0.0.1</a>.</p>
<p>The files of the POC essentially ensure that the container connections outlined in
<a href="#local-docker-setup">Local docker setup</a> work as expected:</p>
<p><a href="/img/docker-from-scratch-for-php-applications-in-2022/docker-containers.PNG"><img src="/img/docker-from-scratch-for-php-applications-in-2022/docker-containers.PNG" alt="Docker container connections" title="Docker container connections" /></a></p>
<ul>
<li><code>dependencies.php</code>
<ul>
<li>returns configured <code>Redis</code> and <code>PDO</code> objects to talk to the queue and the database</li>
</ul></li>
<li><code>setup.php</code>
<ul>
<li>=&gt; <em>ensures that <code>application</code> can talk to <code>mysql</code></em></li>
</ul></li>
<li><code>public/index.php</code>
<ul>
<li>is the web root file that can be accessed via <a href="http://app.local">http://app.local</a>
<ul>
<li>=&gt; <em>ensures that <code>nginx</code> and <code>php-fpm</code> are working</em></li>
</ul></li>
<li>contains 3 different &quot;routes&quot;:
<ul>
<li><a href="http://app.local?dispatch=some-job-id">http://app.local?dispatch=some-job-id</a>
<ul>
<li>dispatches a new &quot;job&quot; with the id <code>some-job-id</code> on the queue to be picked up by a
worker
<ul>
<li>=&gt; <em>ensures that <code>php-fpm</code> can talk to <code>redis</code></em></li>
</ul></li>
</ul></li>
<li><a href="http://app.local?queue">http://app.local?queue</a>
<ul>
<li>shows the content of the queue</li>
</ul></li>
<li><a href="http://app.local?db">http://app.local?db</a>
<ul>
<li>shows the content of the database
<ul>
<li>=&gt; <em>ensures that <code>php-fpm</code> can talk to <code>mysql</code></em></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><code>worker.php</code>
<ul>
<li>is started as daemon process in the <code>php-worker</code> container</li>
<li>checks the redis datasbase <code>0</code> for the key <code>"queue"</code> every second</li>
<li>if a value is found it is stored in the <code>jobs</code> table of the database
<ul>
<li>=&gt; <em>ensures that <code>php-worker</code> can talk to <code>redis</code> and <code>mysql</code></em></li>
</ul></li>
</ul></li>
</ul>
<p>A full test scenario is defined in <code>test.sh</code> and looks like this:</p>
<pre><code>$ bash test.sh

  Building the docker setup

//...

  Starting the docker setup

//...

  Clearing DB

ENV=local TAG=latest DOCKER_REGISTRY=docker.io DOCKER_NAMESPACE=dofroscra APP_USER_NAME=application APP_GROUP_NAME=application docker-compose -p dofroscra_local --env-file ./.docker/.env -f ./.docker/docker-compose/docker-compose.yml -f ./.docker/docker-compose/docker-compose.local.yml exec -T --user application application php setup.php --drop;
Dropping table 'jobs'
Done
Creating table 'jobs'
Done

  Stopping workers

ENV=local TAG=latest DOCKER_REGISTRY=docker.io DOCKER_NAMESPACE=dofroscra APP_USER_NAME=application APP_GROUP_NAME=application docker-compose -p dofroscra_local --env-file ./.docker/.env -f ./.docker/docker-compose/docker-compose.yml -f ./.docker/docker-compose/docker-compose.local.yml exec -T --user application php-worker supervisorctl stop worker:*;
worker:worker_00: stopped
worker:worker_01: stopped
worker:worker_02: stopped
worker:worker_03: stopped

  Ensuring that queue and db are empty

Items in queue
array(0) {
}
Items in db
array(0) {
}

  Dispatching a job 'foo'

Adding item 'foo' to queue

  Asserting the job 'foo' is on the queue

Items in queue
array(1) {
  [0]=&gt;
  string(3) "foo"
}

  Starting the workers

ENV=local TAG=latest DOCKER_REGISTRY=docker.io DOCKER_NAMESPACE=dofroscra APP_USER_NAME=application APP_GROUP_NAME=application docker-compose -p dofroscra_local --env-file ./.docker/.env -f ./.docker/docker-compose/docker-compose.yml -f ./.docker/docker-compose/docker-compose.local.yml exec -T --user application php-worker supervisorctl start worker:*;
worker:worker_00: started
worker:worker_01: started
worker:worker_02: started
worker:worker_03: started

  Asserting the queue is now empty

Items in queue
array(0) {
}

  Asserting the db now contains the job 'foo'

Items in db
array(1) {
  [0]=&gt;
  string(3) "foo"
}
</code></pre>
<!-- generated -->
<p><a id='wrapping-up'> </a></p>
<!-- /generated -->
<h2>Wrapping up</h2>
<p>Congratulations, you made it! If some things are not completely clear by now, don't hesitate to
leave a comment. Apart from that, you should now have a running docker setup and the means to
&quot;control&quot; it conveniently via <code>make</code>.</p>
<p>In the next part of this tutorial, we will
<a href="/blog/phpstorm-docker-xdebug-3-php-8-1-in-2022/">configure PhpStorm as our IDE to use the docker setup</a>.</p>
<p>Please subscribe to the <a href="/feed.xml">RSS feed</a> or <a href="#newsletter">via email</a> to get automatic
notifications when this next part comes out :)</p>]]></description>
                <pubDate>Mon, 21 Mar 2022 10:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/blog/docker-from-scratch-for-php-applications-in-2022/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/blog/docker-from-scratch-for-php-applications-in-2022/</guid>
            </item>
                    <item>
                <title>BigQuery: Monitor Query Costs via INFORMATION_SCHEMA</title>
                <description><![CDATA[<p>Cost monitoring in Google BigQuery can be a difficult task, especially within a growing organization and
lots of (independent) stakeholders that have access to the data. If your organization is not using
reserved slots (<a href="https://cloud.google.com/bigquery/pricing#flat_rate_pricing">flat-rate pricing</a>)
but is billed by the number of bytes processed
(<a href="https://cloud.google.com/bigquery/pricing#on_demand_pricing">on-demand pricing</a>),
costs can get quickly out of hand, and we need the means to investigate or &quot;debug&quot; the BigQuery
usage in order to understand:</p>
<ul>
<li><strong>who</strong> ran queries with a high cost</li>
<li><strong>what</strong> were the exact queries</li>
<li><strong>when</strong> did those queries run (and are they maybe even running regularly) </li>
</ul>
<p>Previously, we had to manually set up query logging via Stackdriver as explained in the article
<a href="https://cloud.google.com/blog/products/data-analytics/taking-a-practical-approach-to-bigquery-cost-monitoring">Taking a practical approach to BigQuery cost monitoring</a>
but in late 2019 BigQuery introduced
<a href="https://cloud.google.com/bigquery/docs/information-schema-intro"><code>INFORMATION_SCHEMA</code> views</a>
as a beta feature that also contain data about BigQuery jobs via the
<a href="https://cloud.google.com/bigquery/docs/information-schema-jobs"><code>INFORMATION_SCHEMA.JOBS_BY_*</code> views</a>
and became <a href="https://cloud.google.com/bigquery/docs/release-notes#June_16_2020">generally available (GA) at 2020-06-16</a></p>
<h2>Examples</h2>
<pre><code>SELECT 
  creation_time,
  job_id,
  project_id,
  user_email,
  total_bytes_processed,
  query
FROM
  `region-us`.INFORMATION_SCHEMA.JOBS_BY_USER

SELECT * FROM `region-us`.INFORMATION_SCHEMA.JOBS_BY_PROJECT

SELECT * FROM `region-us`.INFORMATION_SCHEMA.JOBS_BY_ORGANIZATION</code></pre>
<h2>Working Example</h2>
<script src="https://gist.github.com/paslandau/980f251cbbb2f0dddff9da6425007e3f.js"><script src="https://gist.github.com/paslandau/980f251cbbb2f0dddff9da6425007e3f.js"></script></script>
<ul>
<li>this query will select the most interesting fields in terms of cost monitoring from the <code>INFORMATION_SCHEMA.JOBS_BY_USER</code>
view for all jobs that have been run in region US in the currently selected project</li>
<li>the <code>cost_in_dollar</code> is estimate by calculating the <code>total_bytes_processed</code> in Terabyte and
multiplying the result with $5.00 (which corresponds to the the cost as of today 2020-06-22).
Also, we only take those costs into account if the query was not answered from the cache
(see the <code>cache_hit != true</code> condition)</li>
<li>the <code>creation_time</code> is converted to our local timezone</li>
<li>the results are restricted to the past 30 days by using the <code>WHERE</code> clause to filter
on the partition column <code>creation_time</code></li>
<li>feel free to replace <code>JOBS_BY_PROJECT</code> with <code>JOBS_BY_USER</code> or <code>JOBS_BY_ORGANIZATION</code></li>
</ul>
<h2>Run on BigQuery</h2>
<p><a href="https://console.cloud.google.com/bigquery?sq=580364496687:b0c09fa64661413eb91f5e7e0fcedebd">Open in BigQuery UI</a></p>
<p><a href="/img/bigquery-snippets/monitor-query-costs/monitor-query-costs-bigquery-example.png"><img src="/img/bigquery-snippets/monitor-query-costs/monitor-query-costs-bigquery-example.png" alt="BigQuery UI: Monitor query costs in BigQuery example" title="BigQuery UI: Monitor query costs in BigQuery example" /></a></p>
<h2>Notes</h2>
<p>While playing around with the <code>INFORMATION_SCHEMA</code> views I've hit a couple of gotchas:</p>
<ul>
<li>the different views <a href="https://cloud.google.com/bigquery/docs/information-schema-jobs?hl=en#required_permissions">require different permissions</a></li>
<li>the views are regionalized, i.e. we <strong>must</strong> prefix the region (see <code>region-us</code> in the view specification) and
must run the job <em>in that region</em> (e.g. from the BigQuery UI via
<a href="https://cloud.google.com/bigquery/docs/running-queries#queries"><code>More &gt; Query Settings &gt; Processing location</code></a>)</li>
<li>it is not possible to <strong>mix multiple regions</strong> in the query, because a query with processing location <code>US</code>
can only access resources in location <code>US</code>. Though it would be very helpful for organizations that actively use different locations,
something like this is not possible:
<pre><code>SELECT * FROM 
(SELECT * `region-us`.INFORMATION_SCHEMA.JOBS_BY_ORGANIZATION)
UNION ALL
(SELECT * `region-eu`.INFORMATION_SCHEMA.JOBS_BY_ORGANIZATION)</code></pre></li>
<li>data is currently only kept for the past 180 days</li>
<li>the <code>JOBS_BY_USER</code> view seems to &quot;match&quot; the user based on the email address. My user email adress is a <code>@googlemail.com</code>
address; in the user column it is stored as <code>@gmail.com</code>. Thus, I get no results when using <code>JOBS_BY_USER</code></li>
<li><code>JOBS_BY_USER</code> and <code>JOBS_BY_PROJECT</code> will use the currently selected project by default. A different
project (e.g. <code>other-project</code>) can be specified via 
<pre><code>SELECT * FROM `other-project.region-us`.INFORMATION_SCHEMA.JOBS_BY_PROJECT</code></pre></li>
<li>the full <code>query</code> is not available for <code>JOBS_BY_ORGANIZATION</code></li>
</ul>
<h2>Use Cases</h2>
<p>I use this approach in our organization to set up a view based on <code>INFORMATION_SCHEMA.JOBS_BY_ORGANIZATION</code>
that is then used as a data source for <a href="https://datastudio.google.com/">Google DataStudio</a>.
This allows me to get a quick high level overview
over all query costs and further enables me to drill down deeper if I need to. I can even find the exact
queries via their <code>job_id</code>.</p>
<p><a href="/img/bigquery-snippets/monitor-query-costs/bigquery-cost-dashboard.png"><img src="/img/bigquery-snippets/monitor-query-costs/bigquery-cost-dashboard.png" alt="BigQuery cost monitoring dashboard" title="BigQuery cost monitoring dashboard" /></a></p>]]></description>
                <pubDate>Mon, 22 Jun 2020 10:40:00 +0000</pubDate>
                <link>https://www.pascallandau.com/bigquery-snippets/monitor-query-costs/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/bigquery-snippets/monitor-query-costs/</guid>
            </item>
                    <item>
                <title>BigQuery: Calculate the MEDIAN in BigQuery</title>
                <description><![CDATA[<p>There is no <code>MEDIAN()</code> function in Google BigQuery, but we can still calculate the MEDIAN
with the
<a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#percentile_cont"><code>PERCENTILE_CONT(x, 0.5)</code></a> or
<a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#percentile_disc"><code>PERCENTILE_DISC(x, 0.5)</code></a>
functions. The difference between those two functions is the linear interpolation that is applied
when using <code>PERCENTILE_CONT(x, 0.5)</code> - so that's probably what you want when dealing with numeric
values. Take the numbers <code>1,2,3,4</code> for example:</p>
<ul>
<li><code>PERCENTILE_CONT(x, 0.5)</code> yields <code>2.5</code> (as the 50% percentile is exactly between 2 and 3)</li>
<li><code>PERCENTILE_DISC(x, 0.5)</code> yields <code>2</code> (as the 50% percentile is &gt;= 2)</li>
</ul>
<h2>Example</h2>
<pre><code>SELECT 
  PERCENTILE_CONT(x, 0.5) OVER() AS median_cont,
  PERCENTILE_DISC(x, 0.5) OVER() AS median_disc
FROM
  UNNEST([1,2,3,4]) as x 
LIMIT 1</code></pre>
<p><strong>Result</strong></p>
<table>
<thead>
<tr>
<th style="text-align: right;">median_cont</th>
<th style="text-align: right;">median_disc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: right;">2.5</td>
<td style="text-align: right;">2</td>
</tr>
</tbody>
</table>
<p><strong>Caution</strong>: As of today (2020-06-20), BigQuery only supports <code>PERCENTILE_CONT</code> and <code>PERCENTILE_DISC</code> for window functions
(hence the <code>OVER()</code> clause and the <code>LIMIT 1</code> in the example above):</p>
<blockquote>
<p>PERCENTILE_CONT is under development, and we will publish the documentation once it is GA. We will support it as analytic function first, and we plan to support it as aggregate function (allowing GROUP BY) later.</p>
</blockquote>
<p>Source: <a href="https://stackoverflow.com/a/45579962/413531">SO: percentile functions with GROUPBY in BigQuery</a></p>
<p>The more common use case is probably to calculate the median as a result of a <code>GROUP BY</code> statement.
I.e. I would <em>like</em> to write something like this to get the median of <code>quantity</code> per <code>product_id</code>.</p>
<pre><code>SELECT
  product_id, 
  PERCENTILE_CONT(quantity, 0.5) AS median
GROUP BY
  product_id</code></pre>
<p>Right now, that is only possible for the average via
<a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#avg"><code>AVG()</code></a>
but not for the median. But we can still work around that limitation by using the
<code>PERCENTILE_CONT</code> function on a window partitioned by <code>product_id</code>, then group by the <code>product_id</code>
(to get only one row per <code>product_id</code>)
and resolve a single median value via <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#any_value"><code>ANY_VALUE()</code></a>.</p>
<h2>Working Example</h2>
<script src="https://gist.github.com/paslandau/14940ec0fd34dc30b36377886c308ab3.js"><script src="https://gist.github.com/paslandau/14940ec0fd34dc30b36377886c308ab3.js"></script></script>
<h2>Run on BigQuery</h2>
<p><a href="https://console.cloud.google.com/bigquery?sq=580364496687:0c40a54f0d044cbebdc2745860a75490">Open in BigQuery UI</a></p>
<p><a href="/img/bigquery-snippets/calculate-median/calculate-median-bigquery-example.png"><img src="/img/bigquery-snippets/calculate-median/calculate-median-bigquery-example.png" alt="BigQuery UI: MEDIAN in BigQuery example" title="BigQuery UI: MEDIAN in BigQuery example" /></a></p>
<h2>Links</h2>
<ul>
<li><a href="https://stackoverflow.com/a/29095240/413531">Answer to &quot;How to calculate median of a numeric sequence in Google BigQuery efficiently?&quot; on Stackoverflow</a></li>
</ul>
<h2>Notes</h2>
<p>There is also the <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#approx_quantiles"><code>APPROX_QUANTILES()</code></a>
function (mentioned <a href="https://stackoverflow.com/a/39843565/413531">here</a>) that <em>can</em> by applied to a <code>GROUP BY</code>. I didn't have a practical use case for approximate functions
yet, though. Thus, I don't know the implications of &quot;not using an exact calculation&quot; and rather mention
this for the sake of completeness. Example:</p>
<pre><code>SELECT
  product_id, 
  APPROX_QUANTILES(quantity, 100)[OFFSET(50)] as approx_median
GROUP BY
  product_id</code></pre>]]></description>
                <pubDate>Sat, 20 Jun 2020 12:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/bigquery-snippets/calculate-median/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/bigquery-snippets/calculate-median/</guid>
            </item>
                    <item>
                <title>BigQuery: Use expression subqueries for querying nested and repeated fields</title>
                <description><![CDATA[<p>BigQuery allows to define <a href="https://cloud.google.com/bigquery/docs/nested-repeated">nested and repeated fields</a>
in a table. Although this is very powerful, it makes it much more complex to retrieve the
data if one is not used to such structures. Especially beginners tend to use an
<a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/arrays#flattening_arrays"><code>UNNEST</code> statement</a>
on the nested fields, followed by a huge
<code>GROUP BY</code> statement on the not-originally-repeated fields. Imho, using
<a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/expression_subqueries?hl=en">expression subqueries</a>
is oftentimes the better approach here.</p>
<h2>Code</h2>
<pre><code>SELECT
  id,
  (SELECT value from t.repeated_fields LIMIT 1)
FROM
  table t  </code></pre>
<p><strong>Caution</strong>: When using expression subqueries, you need to make sure that the result is a single value (scalar or array), otherwise you will
get the error message</p>
<blockquote>
<p>Scalar subquery produced more than one element</p>
</blockquote>
<p>In the example code above this is ensured by enforcing one result via <code>LIMIT 1</code>.</p>
<h2>Working Example</h2>
<script src="https://gist.github.com/paslandau/03c73ee5eef2ce217af82a8f7edcb125.js"><script src="https://gist.github.com/paslandau/03c73ee5eef2ce217af82a8f7edcb125.js"></script></script>
<h2>Run on BigQuery</h2>
<p><a href="https://console.cloud.google.com/bigquery?sq=106862046541:a3ca0564513344a2981ac658365112c1">Open in BigQuery Console</a></p>
<p><a href="/img/bigquery-snippets/expression-subqueries-for-nested-repeated-fields/expression-subquery-example.png"><img src="/img/bigquery-snippets/expression-subqueries-for-nested-repeated-fields/expression-subquery-example.png" alt="BigQuery Console: How to use expression subqueries for nested and repeated fields example" title="BigQuery Console: How to use expression subqueries for nested and repeated fields example" /></a></p>
<h2>Links</h2>
<ul>
<li><a href="https://gist.github.com/paslandau/03c73ee5eef2ce217af82a8f7edcb125">Gist on Github</a></li>
<li><a href="https://console.cloud.google.com/bigquery?sq=106862046541:a3ca0564513344a2981ac658365112c1">Example on BigQuery</a></li>
</ul>
<h2>Use cases</h2>
<p>The most prominent use case is probably the <a href="https://support.google.com/analytics/answer/3437719?hl=en">BigQuery export schema of Google Analytics</a>.
To be honest, I also feel that the schema is not very friendly for newcomers with its ~30 RECORD-type (nested) fields and 300+ columns.</p>
<p>In a nutshell, each row represents one <a href="https://support.google.com/analytics/answer/2731565?hl=en">session</a>.
A session consists of multiple hits. Those hits are also available in the nested and repeated <code>hits</code> field. But wait, there is more...
Each hit can have a number of so called <code>customDimensions</code> (meta data that can be attached to each hit). So the resulting table structue looks something
like this:</p>
<pre><code>- field_1
- field_2
- hits
  - field_1 
  - field_2
  - customDimensions
    - index 
    - value </code></pre>
<p>The following example uses the public <a href="https://support.google.com/analytics/answer/7586738?hl=en">Google Analytics sample dataset for BigQuery</a> and shows
a couple of sample expression subqueries</p>
<pre><code>SELECT 
  fullVisitorId,
  visitStartTime,
  TIMESTAMP_SECONDS(visitStartTime) as started_at,
  TIMESTAMP_SECONDS(visitStartTime + CAST( (SELECT time from t.hits ORDER BY hitNumber DESC LIMIT 1) /1000 AS INT64)) as ended_at,
  (SELECT COUNT(*) from t.hits) as hit_count,
  (SELECT page.hostname || page.pagePath from t.hits WHERE isEntrance = TRUE) as landing_page,
  (
    SELECT  
      (SELECT COUNT(*) from h.customDimensions) 
    FROM 
      t.hits h
    WHERE 
      hitNumber = 1
   ) as customDimension_count_of_first_hit, 
FROM 
  `bigquery-public-data.google_analytics_sample.ga_sessions_20170801` t
ORDER BY
  visitStartTime asc</code></pre>]]></description>
                <pubDate>Fri, 29 May 2020 14:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/bigquery-snippets/expression-subqueries-for-nested-repeated-fields/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/bigquery-snippets/expression-subqueries-for-nested-repeated-fields/</guid>
            </item>
                    <item>
                <title>BigQuery: Use &quot;temporary tables&quot; via WITH (named subqueries)</title>
                <description><![CDATA[<p>In Google BigQuery we can define named subqueries via <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax?hl=en#with_clause"><code>WITH</code> clauses</a>.
Those <code>WITH</code> clauses are a very comfortable way to structure complex queries as it allows to reference those queries like actual tables later on.</p>
<p><strong>Note</strong>: BigQuery also supports <em>actcual</em> temporary tables via <code>CREATE TEMPORARY TABLE</code>. See the official documention on
<a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#temporary_tables">temporary tables</a> for further infos.
This is out of scope for this snippet, though.</p>
<h2>Code</h2>
<pre><code>WITH filtered_data as (
  SELECT 
    id
  FROM
    table
  WHERE
    id BETWEEN 5 and 10
)
SELECT
  *
FROM
  filtered_data  </code></pre>
<h2>Working Example</h2>
<script src="https://gist.github.com/paslandau/662a42456dc9dc77b6cbdb1d6acb8c99.js"><script src="https://gist.github.com/paslandau/662a42456dc9dc77b6cbdb1d6acb8c99.js"></script></script>
<h2>Run on BigQuery</h2>
<p><a href="https://console.cloud.google.com/bigquery?sq=106862046541:96765412c1ea44a8b5a85cb697c3c945">Open in BigQuery Console</a></p>
<p><a href="/img/bigquery-snippets/use-temporary-tables-with-named-subquery/use-temporary-tables-via-with-named-subqueries-example.png"><img src="/img/bigquery-snippets/use-temporary-tables-with-named-subquery/use-temporary-tables-via-with-named-subqueries-example.png" alt="BigQuery Console: How to use temporay tables via WITH named subqueries example" title="BigQuery Console: How to use temporay tables via WITH named subqueries example" /></a></p>
<h2>Links</h2>
<ul>
<li><a href="https://gist.github.com/paslandau/662a42456dc9dc77b6cbdb1d6acb8c99">Gist on Github</a></li>
<li><a href="https://console.cloud.google.com/bigquery?sq=106862046541:96765412c1ea44a8b5a85cb697c3c945">Example on BigQuery</a></li>
<li><a href="https://stackoverflow.com/a/38149549/413531">Answer to &quot;How to create temporary table in Google BigQuery&quot; on Stackoverflow</a></li>
</ul>
<h2>Use cases</h2>
<p>Named subqueries are a great way to structure complex queries and give sub-results a meaningful name.
When working with partitioned tables, I always use temporary tables via WITH to make sure I restrict the query to
scan only a limited number of partitions.</p>
<p>Conceptual example:</p>
<pre><code>DECLARE from_date TIMESTAMP DEFAULT "2018-04-09";
DECLARE to_date TIMESTAMP DEFAULT "2018-04-10";

WITH huge_table_partition as(
  SELECT 
    *
  FROM 
    huge_table
  WHERE
    _PARTITIONTIME BETWEEN from_date AND to_date
)

SELECT 
  *
FROM
  huge_table_partition</code></pre>]]></description>
                <pubDate>Fri, 29 May 2020 13:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/bigquery-snippets/use-temporary-tables-with-named-subquery/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/bigquery-snippets/use-temporary-tables-with-named-subquery/</guid>
            </item>
                    <item>
                <title>BigQuery: Using Variables in BigQuery</title>
                <description><![CDATA[<p>Variables are a good way to keep a query &quot;clean&quot; and separate parameters from code.
In Google BigQuery, we can use variables in standard sql by defining them with a
<a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/scripting#declare"><code>DECLARE</code> statement</a>,
e.g. </p>
<pre><code>DECLARE foo STRING DEFAULT "foo";

#DECLARE &lt;variable&gt; &lt;type&gt; DEFAULT &lt;value&gt;;</code></pre>
<p>with <code>&lt;type&gt;</code> being one of the <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types">BigQuery's built-in standard-sql data types</a></p>
<p>This is equivalent to variables of other SQL databases, e.g.</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/user-variables.html">MySQL variables</a>: 
<pre><code>SET @foo = 'bar';</code></pre></li>
<li><a href="https://www.postgresql.org/docs/9.1/plpgsql-declarations.html">PostgreSQL variables</a>:
<pre><code>foo varchar := 'bar';</code></pre></li>
</ul>
<h2>Code</h2>
<pre><code>DECLARE foo_var STRING DEFAULT "foo";

SELECT foo_var</code></pre>
<h2>Working Example</h2>
<script src="https://gist.github.com/paslandau/0cb51ba9e532a71fff5108f156afd2f5.js"><script src="https://gist.github.com/paslandau/0cb51ba9e532a71fff5108f156afd2f5.js"></script></script>
<h2>Run on BigQuery</h2>
<p><a href="https://console.cloud.google.com/bigquery?sq=106862046541:200d3282989c48b7893b3c3145b46a6d">Open in BigQuery Console</a></p>
<p><a href="/img/bigquery-snippets/use-variables/use-variables-example.png"><img src="/img/bigquery-snippets/use-variables/use-variables-example.png" alt="BigQuery Console: How to declare and use variables example" title="BigQuery Console: How to declare and use variables example" /></a></p>
<h2>Links</h2>
<ul>
<li><a href="https://gist.github.com/paslandau/0cb51ba9e532a71fff5108f156afd2f5">Gist on Github</a></li>
<li><a href="https://console.cloud.google.com/bigquery?sq=106862046541:200d3282989c48b7893b3c3145b46a6d">Example on BigQuery</a></li>
<li><a href="https://stackoverflow.com/a/58227996/413531">Answer to &quot;Setting Big Query variables like mysql&quot; on Stackoverflow</a></li>
</ul>
<h2>Use cases</h2>
<p>Hardcoding variables is generally considered a bad practice as it makes it harder to understand and modify a query.
A frequent use case for me is the definition of date ranges (from and to dates) that are used for querying partitioned tables:</p>
<pre><code>DECLARE from_date DATE DEFAULT DATE("2018-04-09");
DECLARE to_date DATE DEFAULT DATE("2018-04-10");

WITH data as(
  SELECT 
    1 as id,
    DATE("2018-04-08") AS date,
  UNION ALL SELECT 2, DATE("2018-04-09") 
  UNION ALL SELECT 3, DATE("2018-04-10") 
  UNION ALL SELECT 4, DATE("2018-04-11") 
)

SELECT 
    id, 
    date
FROM
    data
WHERE
    date BETWEEN from_date AND to_date</code></pre>]]></description>
                <pubDate>Fri, 29 May 2020 12:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/bigquery-snippets/use-variables/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/bigquery-snippets/use-variables/</guid>
            </item>
                    <item>
                <title>BigQuery: Using multiple cursors / rectangular selection in BigQuery UI</title>
                <description><![CDATA[<p>Multiple keyboard shortcuts usable in the <a href="https://console.cloud.google.com/bigquery">BigQuery UI</a> are listed in the
<a href="https://cloud.google.com/bigquery/docs/bigquery-web-ui?hl=en#keyboard_shortcuts">official documentation</a>, though the one for
using multiple cursors is missing:</p>
<div class="center-div" style="font-size:2em">
    <code>ALT + left-mouse-button-drag</code>
</div>
<p><a href="/img/bigquery-snippets/multiple-cursors-big-query-ui/bigquery-multiple-cursors.gif"><img src="/img/bigquery-snippets/multiple-cursors-big-query-ui/bigquery-multiple-cursors.gif" alt="Using multiple cursors in the BigQuery UI via ATL + left mouse drag" /></a></p>
<h2>Instructions</h2>
<ul>
<li>keep the <code>ALT</code> key pressed first and then click the left mouse button and drag it up or down vertically</li>
<li>the same hotkeys can be used to draw a <strong>rectangular selection</strong> (aka column selection)
<a href="/img/bigquery-snippets/multiple-cursors-big-query-ui/bigquery-rectangular-column-selection.png"><img src="/img/bigquery-snippets/multiple-cursors-big-query-ui/bigquery-rectangular-column-selection.png" alt="Rectangular / column selection in BigQuery" /></a></li>
<li>using <code>ALT + LEFT</code> and <code>ALT + RIGHT</code> will position one (or all) cursors at the beginning respectively end of the line</li>
</ul>
<h2>Use cases</h2>
<p>We often deal with multiple datasets and tables that have the exact same structure, e.g. due to sharding. In those cases it's
often required to modify different parts of the query in the exact same way so that multiple cursors come in handy.</p>]]></description>
                <pubDate>Thu, 19 Dec 2019 18:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/bigquery-snippets/multiple-cursors-big-query-ui/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/bigquery-snippets/multiple-cursors-big-query-ui/</guid>
            </item>
                    <item>
                <title>How to build a Docker development setup for PHP Projects [Tutorial Part 3]</title>
                <description><![CDATA[<div class="panel panel-default">
  <div class="panel-heading">
    <strong>Caution</strong>
  </div>
  <div class="panel-body bg-danger">
    There is a <strong>follow-up version</strong> of this article available that was published 
    in <strong>2022</strong> - please make sure to read that as well:
    <br>
    <a href="/blog/docker-from-scratch-for-php-applications-in-2022/">Docker from scratch for PHP 8.1 Applications in 2022</a>
  </div>
</div>
<p>In the third part of this tutorial series on developing PHP on Docker we'll lay the fundamentals to
build a complete development infrastructure and explain how to &quot;structure&quot; the Docker setup as part
of a PHP project. Structure as in </p>
<ul>
<li>folder structure (&quot;what to put where&quot;)</li>
<li>Dockerfile templates</li>
<li>solving common problems (file permissions, runtime configuration, ...)</li>
</ul>
<p>We will also create a minimal container setup consisting of php-fpm, nginx and a workspace container that we
refactor from the previous parts of this tutorial.</p>
<div class="center-div">
<iframe width="560" height="315" src="https://www.youtube.com/embed/YYI5mTjFDuA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2>Published parts of the Docker PHP Tutorial</h2>
<ul>
<li><a href="/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/">Setting up PHP, PHP-FPM and NGINX for local development on Docker</a>
(2018-07-08)</li>
<li><a href="/blog/setup-phpstorm-with-xdebug-on-docker/">Setting up PhpStorm with Xdebug for local development on Docker</a>
(2018-08-06)</li>
<li><a href="/blog/structuring-the-docker-setup-for-php-projects/">Structuring the Docker setup for PHP Projects</a>
(2019-05-20)</li>
<li><a href="/blog/docker-from-scratch-for-php-applications-in-2022/">Docker from scratch for PHP 8.1 Applications in 2022</a>
(2022-03-21)</li>
<li><a href="/blog/phpstorm-docker-xdebug-3-php-8-1-in-2022/">PhpStorm, Docker and Xdebug 3 on PHP 8.1 in 2022</a>
(2022-03-22)</li>
<li><a href="/blog/run-laravel-9-docker-in-2022/">Run Laravel 9 on Docker in 2022</a>
(2022-03-23)</li>
</ul>
<p>All code samples are publicly available in my
<a href="https://github.com/paslandau/docker-php-tutorial">Docker PHP Tutorial repository on github</a>.
The branch for this tutorial is
<a href="https://github.com/paslandau/docker-php-tutorial/tree/part_3_structuring-the-docker-setup-for-php-projects">part_3_structuring-the-docker-setup-for-php-projects</a>.</p>
<p>If you want to follow along, please subscribe to the <a href="/feed.xml">RSS feed</a> or <a href="#newsletter">via email</a>
to get automatic notifications when the next part comes out :)</p>
<h2>Acknowledgements</h2>
<p>Shout out to <a href="https://www.xing.com/profile/Nils_Meyer7">Nils Meyer</a>
for giving the final &quot;[...] nichts offensichtlich falsch&quot; (&quot;nothing obviously wrong&quot;) :)</p>
<h2>Table of contents</h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#structuring-the-repository">Structuring the repository</a>
<ul>
<li><a href="#the-docker-folder">The .docker folder</a></li>
<li><a href="#shared-folder">The <code>.shared</code> folder</a></li>
<li><a href="#"><code>docker-test.sh</code></a></li>
<li><a href="#env-example-and-docker-compose-yml"><code>.env.example</code> and <code>docker-compose.yml</code></a></li>
<li><a href="#the-makefile">The Makefile</a></li>
</ul></li>
<li><a href="#defining-services-php-fpm-nginx-and-workspace">Defining services: php-fpm, nginx and workspace</a>
<ul>
<li><a href="#php-fpm">php-fpm</a>
<ul>
<li><a href="#modifying-the-pool-configuration">Modifying the pool configuration</a></li>
<li><a href="#custom-entrypoint">Custom ENTRYPOINT</a></li>
</ul></li>
<li><a href="#nginx">nginx</a></li>
<li><a href="#workspace-formerly-php-cli">workspace (formerly php-cli)</a></li>
</ul></li>
<li><a href="#setting-up-docker-compose">Setting up docker-compose</a> 
<ul>
<li><a href="#docker-compose-yml">docker-compose.yml</a></li>
<li><a href="#env-example">.env.example</a></li>
<li><a href="#building-and-running-the-containers">Building and running the containers</a></li>
<li><a href="#testing-if-everything-works">Testing if everything works</a></li>
</ul></li>
<li><a href="#makefile-and-bashrc">Makefile and <code>.bashrc</code></a>
<ul>
<li><a href="#using-make-as-central-entry-point">Using <code>make</code> as central entry point</a></li>
<li><a href="#install-make-on-windows-mingw">Install make on Windows (MinGW)</a></li>
<li><a href="#easy-container-access-via-din-bashrc-helper">Easy container access via <code>din</code> .bashrc helper</a></li>
</ul></li>
<li><a href="#fundamentals-on-building-the-containers">Fundamentals on building the containers</a>
<ul>
<li><a href="#understanding-build-context">Understanding build context</a></li>
<li><a href="#dockerfile-template">Dockerfile template</a></li>
<li><a href="#setting-the-timezone">Setting the timezone</a></li>
<li><a href="#synchronizing-file-and-folder-ownership-on-shared-volumes">Synchronizing file and folder ownership on shared volumes</a></li>
<li><a href="#modifying-configuration-files">Modifying configuration files</a>
<ul>
<li><a href="#providing-additional-config-files">Providing additional config files</a></li>
<li><a href="#changing-non-static-values">Changing non-static values</a></li>
</ul></li>
<li><a href="#installing-php-extensions">Installing php extensions</a></li>
<li><a href="#installing-common-software">Installing common software</a></li>
<li><a href="#cleaning-up">Cleaning up</a></li>
<li><a href="#using-entrypoint-for-pre-run-configuration">Using <code>ENTRYPOINT</code> for pre-run configuration</a>
<ul>
<li><a href="#providing-host-docker-internal-for-linux-host-systems">Providing <code>host.docker.internal</code> for linux host systems</a></li>
</ul></li>
</ul></li>
<li><a href="#wrapping-up">Wrapping up</a></li>
</ul>
<h2><a id="introduction"></a>Introduction</h2>
<p>When I started my current role as Head of Marketing Technology at ABOUT YOU back in 2016, we heavily
relied on <a href="/blog/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/">Vagrant (namely: Homestead) as our development infrastructure</a>.
Though that was much better than
working on our local machines, we've run into a couple of problems along the way (e.g. diverging software,
bloated images, slow starting times, complicated readme for onboarding, upgrading php, ...).</p>
<p>Today, everything that we need for the infrastructure is under source control and committed in the same repository
that we use for our main application. In effect we get <strong>the same infrastructure for every developer</strong> including automatic
updates &quot;for free&quot;. It is extremely easy to tinker around with updates / new tools due to the ephemeral nature of docker
as tear down and rebuild only take one command and a couple of minutes.</p>
<p>To get a feeling for how the process <em>feels</em> like, simply execute the following commands.</p>
<pre><code>git clone https://github.com/paslandau/docker-php-tutorial.git
cd docker-php-tutorial
git checkout part_3_structuring-the-docker-setup-for-php-projects
make docker-clean
make docker-init
make docker-build-from-scratch
make docker-test</code></pre>
<p>You should now have a running docker environment to develop PHP on docker (unless
<a href="#building-and-running-the-containers">something is blocking your port 80/443</a>
or
<a href="#install-make-on-windows-mingw">you don't have make installed</a>
;))</p>
<h2><a id="structuring-the-repository"></a>Structuring the repository</h2>
<p>While playing around with docker I've tried different ways to &quot;structure&quot; files and folders and ended up with the following
concepts:</p>
<ul>
<li>everything related to docker is <strong>placed in a <code>.docker</code> directory on on the same level as the main application</strong></li>
<li>in this directory
<ul>
<li>each service gets its own subdirectory for configuration</li>
<li>is a <strong><code>.shared</code> folder containing scripts and configuration</strong> required by multiple services</li>
<li>is an <strong><code>.env.example</code></strong> file containing variables for the <strong><code>docker-compose.yml</code></strong></li>
<li>is a <strong><code>docker-test.sh</code></strong> file containing high level tests to validate the docker containers</li>
</ul></li>
<li>a <strong>Makefile</strong> with common instructions to control Docker is placed in the repository root</li>
</ul>
<p>The result looks roughly like this:</p>
<pre><code>&lt;project&gt;/
├── .docker/
|   ├── .shared/
|   |   ├── config/
|   |   └── scripts/
|   ├── php-fpm/
|   |   └── Dockerfile
|   ├── ... &lt;additional services&gt;/
|   ├── .env.example
|   ├── docker-compose.yml
|   └── docker-test.sh
├── Makefile
├── index.php
└──  ... &lt;additional app files&gt;/</code></pre>
<h3><a id="the-docker-folder"></a>The .docker folder</h3>
<p>As I mentioned, for me it makes a lot of sense to keep the <strong>infrastructure definition close to the codebase</strong>, because
it is immediately available to every developer. For bigger projects with multiple components there will be a
code-infrastructure-coupling anyways
(e.g. in my experience it is usually not possible to simply switch MySQL for PostgreSQL without any other changes)
and for a library it is a very convenient (although opinionated) way to get started. </p>
<p>I personally find it rather
frustrating when I want to contribute to an open source project but find myself spending a significant amount of time
setting the environment up correctly instead of being able to just work on the code.</p>
<p>Ymmv, though (e.g. because you don't want everybody with write access to your app repo also to be able to change your
infrastructure code). We actually went a different route previously and had a second repository (&quot;<app>-inf&quot;)
that would contain the contents of the <code>.docker</code> folder: </p>
<pre><code>&lt;project-inf&gt;/
├── .shared/
|   ├── config/
|   └── scripts/
├── php-fpm/
|   └── Dockerfile
├── ... &lt;additional services&gt;/
├── .env.example
└──  docker-compose.yml

&lt;project&gt;/
├── index.php
└──  ... &lt;additional app files&gt;/</code></pre>
<p>Worked as well, but we often ran into situations where
the contents of the repo would be stale for some devs, plus it was simply additional overhead with not other benefits
to us at that point. Maybe <a href="https://medium.com/@porteneuve/mastering-git-submodules-34c65e940407">git submodules</a> will
enable us to get the best of both worlds - I'll blog about it once we try ;)</p>
<h3><a id="shared-folder"></a>The <code>.shared</code> folder</h3>
<p>When dealing with multiple services, chances are high that some of those services will be configured similarly, e.g. for</p>
<ul>
<li>installing common software </li>
<li>setting up unix users (with the same ids)</li>
<li>configuration (think php-cli for workers and php-fpm for web requests)</li>
</ul>
<p>To avoid duplication, I place scripts (simple bash files) and config files in the <code>.shared</code> folder and make it available in
the build context for each service. I'll explain the process in more detail under
<a href="#understanding-build-context">providing the correct build context</a>.</p>
<h3><a id=""></a><code>docker-test.sh</code></h3>
<p>Is really just a simple bash script that includes some high level tests to make sure that the containers are
built correctly. See section <a href="#testing-if-everything-works">Testing if everything works</a>.</p>
<h3><a id="env-example-and-docker-compose-yml"></a><code>.env.example</code> and <code>docker-compose.yml</code></h3>
<p><code>docker-compose</code> uses a <a href="https://docs.docker.com/compose/environment-variables/#the-env-file"><code>.env</code> file</a>
for a convenient way to define and
<a href="https://docs.docker.com/compose/compose-file/#variable-substitution"><code>substitute environment variables</code></a>.
Since this <code>.env</code> file is environment specific, it is <strong>NOT</strong>
part of the repository (i.e. ignored via <code>.gitignore</code>). Instead, we provide a <code>.env.example</code> file that contains
the required environment variables including reasonable default values. A new dev would usually run
<code>cp .env.example .env</code> after checking out the repository for the first time.
See section <a href="#env-example">.env.example</a>.</p>
<h3><a id="the-makefile"></a>The Makefile</h3>
<p><code>make</code> and <code>Makefile</code>s are among those things that I've heard about occasionally but never really cared to
understand (mostly because I associated them with C). Boy, did I miss out. I was comparing different strategies
to provide code quality tooling (style checkers, static analyzers, tests, ...) and went from custom bash scripts
over <a href="https://getcomposer.org/doc/articles/scripts.md">composer scripts</a> to finally end up at <code>Makefile</code>s.</p>
<p>The <code>Makefile</code> serves as a central entry point and simplifies the management of the docker containers, e.g. for
(re-)building, starting, stopping, logging in, etc. See section <a href="#makefile-and-bashrc">Makefile and .bashrc</a>.</p>
<h2><a id="defining-services-php-fpm-nginx-and-workspace"></a>Defining services: php-fpm, nginx and workspace</h2>
<p>Let's have a look at a real example and &quot;refactor&quot; the
<a href="#workspace-formerly-php-cli">php-cli</a>,
<a href="#php-fpm">php-fpm</a>
and
<a href="#nginx">nginx</a>
containers from the <a href="/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/">first part of this tutorial series</a>. </p>
<p>This is the folder structure:</p>
<pre><code>&lt;project&gt;/
├── .docker/
|   ├── .shared/
|   |   ├── config/
|   |   |   └── php/ 
|   |   |       └── conf.d/
|   |   |           └── zz-app.ini
|   |   └── scripts/
|   |       └── docker-entrypoint/
|   |           └── resolve-docker-host-ip.sh
|   ├── nginx/
|   |   ├── sites-available/
|   |   |   └── default.conf
|   |   ├── Dockerfile
|   |   └── nginx.conf
|   ├── php-fpm/
|   |   ├── php-fpm.d/
|   |   |   └── pool.conf
|   |   └── Dockerfile
|   ├── workspace/ (formerly php-cli)
|   |   ├── .ssh/
|   |   |   └── insecure_id_rsa
|   |   |   └── insecure_id_rsa.pub
|   |   └── Dockerfile
|   ├── .env.example
|   ├── docker-compose.yml
|   └── docker-test.sh
├── Makefile
└── index.php</code></pre>
<h3><a id="php-fpm"></a>php-fpm</h3>
<p>Click here to <a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects/.docker/php-fpm/Dockerfile">see the full php-fpm Dockerfile</a>.</p>
<p>Since we will be having two PHP containers, we need to place the common .ini settings in the <code>.shared</code> directory.</p>
<pre><code>|   ├── .shared/
|   |   ├── config/
|   |   |   └── php/ 
|   |   |       └── conf.d/
|   |   |           └── zz-app.ini</code></pre>
<p>For now, <code>zz-app.ini</code> will only contain our
<a href="https://www.scalingphpbook.com/blog/2014/02/14/best-zend-opcache-settings.html">opcache setup</a>:</p>
<pre><code>; enable opcache
opcache.enable_cli = 1
opcache.enable = 1
opcache.fast_shutdown = 1
; revalidate everytime (effectively disabled for development)
opcache.validate_timestamps = 0</code></pre>
<p>The pool configuration is only relevant for php-fpm, so it goes in the directory of the service. Btw. I highly
recommend <a href="https://serversforhackers.com/c/lemp-php-fpm-config">this video on PHP-FPM Configuration</a> if your
php-fpm foo isn't already over 9000.</p>
<pre><code>|   ├── php-fpm/
|   |   ├── php-fpm.d/
|   |   |   └── pool.conf</code></pre>
<h4><a id="modifying-the-pool-configuration"></a>Modifying the pool configuration</h4>
<p>We're using the <a href="#changing-non-static-values"><code>modify_config.sh</code> script</a> to set the user and group that owns the php-fpm processes.</p>
<pre><code># php-fpm pool config
COPY ${SERVICE_DIR}/php-fpm.d/* /usr/local/etc/php-fpm.d
RUN /tmp/scripts/modify_config.sh /usr/local/etc/php-fpm.d/zz-default.conf \
    "__APP_USER" \
    "${APP_USER}" \
 &amp;&amp; /tmp/scripts/modify_config.sh /usr/local/etc/php-fpm.d/zz-default.conf \
    "__APP_GROUP" \
    "${APP_GROUP}" \
;</code></pre>
<h4><a id="custom-entrypoint"></a>Custom ENTRYPOINT</h4>
<p>Since php-fpm needs to be debuggable, we need to ensure that the <code>host.docker.internal</code> DNS entry exists,
so we'll use the <a href="#providing-host-docker-internal-for-linux-host-systems">corresponding ENTRYPOINT</a> to do that.</p>
<pre><code># entrypoint
RUN mkdir -p /bin/docker-entrypoint/ \
 &amp;&amp; cp /tmp/scripts/docker-entrypoint/* /bin/docker-entrypoint/ \
 &amp;&amp; chmod +x -R /bin/docker-entrypoint/ \
;

ENTRYPOINT ["/bin/docker-entrypoint/resolve-docker-host-ip.sh","php-fpm"]</code></pre>
<h3><a id="nginx"></a>nginx</h3>
<p>Click here to <a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects/.docker/nginx/Dockerfile">see the full nginx Dockerfile</a>.</p>
<p>The nginx setup is even simpler. There is no shared config, so that everything we need resides in</p>
<pre><code>|   ├── nginx/
|   |   ├── sites-available/
|   |   |   └── default.conf
|   |   ├── Dockerfile
|   |   └── nginx.conf</code></pre>
<p>Please note, that nginx only has the <code>nginx.conf</code> file for configuration (i.e. there is no <code>conf.d</code> directory or so),
so we need to define the <strong>full</strong> config in there. </p>
<pre><code>user __APP_USER __APP_GROUP;
worker_processes 4;
pid /run/nginx.pid;
daemon off;

http {
  # ...

  include /etc/nginx/sites-available/*.conf;

  # ...
}</code></pre>
<p>There are two things to note:</p>
<ul>
<li>user and group are modified dynamically</li>
<li>we specify <code>/etc/nginx/sites-available/</code> as the directory that holds the config files for the individual files via
<code>include /etc/nginx/sites-available/*.conf;</code></li>
</ul>
<p>We need to keep the last point in mind, because we must use the same directory in the Dockerfile:</p>
<pre><code># nginx app config
COPY ${SERVICE_DIR}/sites-available/* /etc/nginx/sites-available/</code></pre>
<p>The site's config file
<a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects/.docker/nginx/sites-available/default.conf"><code>default.conf</code></a>
has a variable (<code>__NGINX_ROOT</code>) for the <code>root</code> directive and we &quot;connect&quot; it with the fpm-container via
<code>fastcgi_pass php-fpm:9000;</code></p>
<pre><code>server {
    # ...
    root __NGINX_ROOT;
    # ...

    location ~ \.php$ {
        # ...
        fastcgi_pass php-fpm:9000;
    }
}</code></pre>
<p><code>php-fpm</code> will resolve to the <code>php-fpm</code> container, because we use php-fpm as the service name in the docker-compose
file, so it will be <a href="https://docs.docker.com/compose/compose-file/#aliases">automatically used as the hostname</a>:</p>
<blockquote>
<p>Other containers on the same network can use either the service name or [an] alias to connect to one of the service’s containers.</p>
</blockquote>
<p>In the Dockerfile, we use</p>
<pre><code>ARG APP_CODE_PATH
RUN /tmp/scripts/modify_config.sh /etc/nginx/sites-available/default.conf \
    "__NGINX_ROOT" \
    "${APP_CODE_PATH}" \
;</code></pre>
<p><code>APP_CODE_PATH</code> will be passed via docker-compose when we build the container and mounted as a shared directory
from the host system. </p>
<h3><a id="workspace-formerly-php-cli"></a>workspace (formerly php-cli)</h3>
<p>Click here to <a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects/.docker/workspace/Dockerfile">see the full workspace Dockerfile</a>.</p>
<p>We will use the former <code>php-cli</code> container and make it our <code>workspace</code> as introduced in part 2 of this tutorial under
<a href="https://www.pascallandau.com/blog/setup-phpstorm-with-xdebug-on-docker/#preparing-the-workspace-container">Preparing the &quot;workspace&quot; container</a>.</p>
<p>This will be the container we use to point our IDE to, e.g. to execute tests. Its Dockerfile looks almost identical
to the one of the <code>php-fpm</code> service, apart from the SSH setup:</p>
<pre><code># set up ssh
RUN apt-get update -yqq &amp;&amp; apt-get install -yqq openssh-server \
 &amp;&amp; mkdir /var/run/sshd \
;

# add default public key to authorized_keys
USER ${APP_USER}
COPY ${SERVICE_DIR}/.ssh/insecure_id_rsa.pub /tmp/insecure_id_rsa.pub
RUN mkdir -p ~/.ssh \
 &amp;&amp; cat /tmp/insecure_id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys \
 &amp;&amp; chown -R ${APP_USER}: ~/.ssh \
 &amp;&amp; chmod 700 ~/.ssh \
 &amp;&amp; chmod 600 ~/.ssh/authorized_keys \
;
USER root</code></pre>
<h2><a id="setting-up-docker-compose"></a>Setting up docker-compose</h2>
<p>In order to orchestrate the build process, we'll use docker-compose.</p>
<h3><a id="docker-compose-yml"></a>docker-compose.yml</h3>
<p>See the full
<a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects/.docker/docker-compose.yml">docker-compose.yml file in the repository</a></p>
<p>Things to note:</p>
<ul>
<li>each service uses <code>context: .</code> so it has access to the <code>.shared</code> folder.
The context is always <a href="https://docs.docker.com/compose/extends/#understanding-multiple-compose-files">relative to the location of the first docker-compose.yml file</a></li>
<li>all arguments that we used in the Dockerfiles are defined in the <code>args:</code>
section via
<pre><code>args:
- APP_CODE_PATH=${APP_CODE_PATH_CONTAINER}
- APP_GROUP=${APP_GROUP}
- APP_GROUP_ID=${APP_GROUP_ID}
- APP_USER=${APP_USER}
- APP_USER_ID=${APP_USER_ID}
- TZ=${TIMEZONE}</code></pre></li>
<li>the codebase is synced from the host in all containers via
<pre><code>volumes:
- ${APP_CODE_PATH_HOST}:${APP_CODE_PATH_CONTAINER}</code></pre></li>
<li>the <code>nginx</code> service exposes ports on the host machine so that we can
access the containers from &quot;outside&quot; via
<pre><code>ports:
- "${NGINX_HOST_HTTP_PORT}:80"
- "${NGINX_HOST_HTTPS_PORT}:443"</code></pre></li>
<li>all services are part of the <code>backend</code> network so they can talk to each
other. The <code>nginx</code> service has an additional alias that allows us to
define an arbitrary host name via
<pre><code>networks:
backend:
  aliases:
    - ${APP_HOST}</code></pre>
<p>I prefer to have a dedicated hostname per project (e.g. <code>docker-php-tutorial.local</code>)
instead of using <code>127.0.0.1</code> or <code>localhost</code> directly</p></li>
</ul>
<h3><a id="env-example"></a>.env.example</h3>
<p>To fill in all the required variables / arguments, we're using a <code>.env.example</code> file with the following content:</p>
<pre><code># Default settings for docker-compose
COMPOSE_PROJECT_NAME=docker-php-tutorial
COMPOSE_FILE=docker-compose.yml
COMPOSE_CONVERT_WINDOWS_PATHS=1

# build
PHP_VERSION=7.3
TIMEZONE=UTC
NETWORKS_DRIVER=bridge

# application
APP_USER=www-data
APP_GROUP=www-data
APP_USER_ID=1000
APP_GROUP_ID=1000
APP_CODE_PATH_HOST=../
APP_CODE_PATH_CONTAINER=/var/www/current

# required so we can reach the nginx server from other containers via that hostname
APP_HOST=docker-php-tutorial.local

# nginx
NGINX_HOST_HTTP_PORT=80
NGINX_HOST_HTTPS_PORT=443

# workspace
WORKSPACE_HOST_SSH_PORT=2222</code></pre>
<p>The <code>COMPOSE_</code> variables in the beginning set some reasonable
<a href="https://docs.docker.com/compose/reference/envvars/#compose_file">defaults for docker-compose</a>.</p>
<h3><a id="building-and-running-the-containers"></a>Building and running the containers</h3>
<p>By now, we should have everything we need set up to get our dockerized PHP development up and running. If
you haven't done it already, now would be a great time to clone
<a href="https://github.com/paslandau/docker-php-tutorial">the repository</a>
and checkout the
<a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects"><code>part_3_structuring-the-docker-setup-for-php-projects</code> branch</a>:</p>
<pre><code>git clone https://github.com/paslandau/docker-php-tutorial.git
cd docker-php-tutorial
git checkout part_3_structuring-the-docker-setup-for-php-projects</code></pre>
<p>Now copy the <code>.env.exmaple</code> to <code>.env</code>. All the default values  should work out of the box - unless you already have something
running on port <code>80</code> or <code>443</code>. In that case you have to change <code>NGINX_HOST_HTTP_PORT / NGINX_HOST_HTTP_PORT</code> to a free port.</p>
<pre><code>cp .env.example .env</code></pre>
<p>We can examine the &quot;final&quot; docker-compose.yml <strong>after</strong> the variable substitution via</p>
<pre><code>docker-compose -f .docker/docker-compose.yml --project-directory .docker config</code></pre>
<pre><code>networks:
  backend:
    driver: bridge
services:
  nginx:
    build:
      args:
        APP_CODE_PATH: /var/www/current
        APP_GROUP: www-data
        APP_GROUP_ID: '1000'
        APP_USER: www-data
        APP_USER_ID: '1000'
        TZ: UTC
      context: D:\codebase\docker-php-tutorial\.docker
      dockerfile: ./nginx/Dockerfile
    image: php-docker-tutorial/nginx
    networks:
      backend:
        aliases:
        - docker-php-tutorial.local
    ports:
    - published: 80
      target: 80
    - published: 443
      target: 443
    volumes:
    - /d/codebase/docker-php-tutorial:/var/www/current:rw
  php-fpm:
// ...</code></pre>
<p>Note, that this command is run from <code>./docker-php-tutorial</code>. If we would run this from <code>./docker-php-tutorial/.docker</code>,
we could simply use <code>docker-compose config</code> - but since we'll define that in a Makefile later anyway, the additional
&quot;verbosity&quot; won't matter ;)</p>
<p>This command is also a great way to check the various paths that are resolved to their absolute form, e.g. </p>
<pre><code>context: D:\codebase\docker-php-tutorial\.docker</code></pre>
<p>and</p>
<pre><code>volumes:
- /d/codebase/docker-php-tutorial:/var/www/current:rw</code></pre>
<p>The actual build is triggered via</p>
<pre><code>docker-compose -f .docker/docker-compose.yml --project-directory .docker build --parallel</code></pre>
<p>Since we have more than one container, it makes sense to build with
<a href="https://docs.docker.com/compose/reference/build/"><code>--parallel</code></a>.</p>
<p>To start the containers, we use</p>
<pre><code>docker-compose -f .docker/docker-compose.yml --project-directory .docker up -d</code></pre>
<p>and should see  </p>
<pre><code>$ docker-compose -f .docker/docker-compose.yml --project-directory .docker up -d
Starting docker-php-tutorial_nginx_1     ... done
Starting docker-php-tutorial_workspace_1 ... done
Starting docker-php-tutorial_php-fpm_1   ... done</code></pre>
<h3><a id="testing-if-everything-works"></a>Testing if everything works</h3>
<p>After rewriting our own docker setup a couple of times, I've come to appreciate a structured way to test if
&quot;everything&quot; works. Everything as in:</p>
<ul>
<li>are all containers running?</li>
<li>does &quot;host.docker.internal&quot; exist?</li>
<li>do we see the correct output when sending a request to nginx/php-fpm?</li>
<li>are all required php extensions installed?</li>
</ul>
<p>This might seem superfluous (after all, we just defined excatly that in the Dockerfiles), but there will come a time
when you (or someone else) need to make changes (new PHP version, new extensions, etc.) and having something that runs
automatically and informs you about obvious flaws is a real time saver. </p>
<p>You can see
<a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects/.docker/docker-test.sh">the full test file in the repository</a>.
Since my bash isn't the best, I try to keep it as simple as possible. The tests can be run via</p>
<pre><code>sh .docker/docker-test.sh</code></pre>
<p>and should yield something like this:</p>
<pre><code>Testing service 'workspace'
=======
Checking if 'workspace' has a running container
OK
Testing PHP version '7.3' on 'workspace' for 'php' and expect to see 'PHP 7.3'
OK
Testing PHP module 'xdebug' on 'workspace' for 'php'
OK
Testing PHP module 'Zend OPcache' on 'workspace' for 'php'
OK
Checking 'host.docker.internal' on 'workspace'
OK

Testing service 'php-fpm'
=======
...</code></pre>
<h2><a id="makefile-and-bashrc"></a>Makefile and <code>.bashrc</code></h2>
<p>In the previous sections I have introduced a couple of commands, e.g. for building and running containers. And to be honest,
I find it kinda challenging to keep them in mind without having to look up the exact options and arguments. I would
usually create a helper function or an alias in my local <code>.bashrc</code> file in a situation like that - but that wouldn't
be available to other members of the team then and it would be very specific to this one project.
Instead we'll provide a <code>Makefile</code> as a central reference point.</p>
<h3><a id="using-make-as-central-entry-point"></a>Using <code>make</code> as central entry point</h3>
<p>Please refer
<a href="https://github.com/paslandau/docker-php-tutorial/blob/part_3_structuring-the-docker-setup-for-php-projects/Makefile">to the repository for the full <code>Makefile</code></a>.</p>
<p>Going into the details of <code>make</code> is a little out of scope for this article,
so I kindly refer to some articles that helped me get started:</p>
<ul>
<li><a href="https://localheinz.com/blog/2018/01/24/makefile-for-lazy-developers/">Makefile for lazy developers</a></li>
<li><a href="https://blog.theodo.fr/2018/05/why-you-need-a-makefile-on-your-project/">Why you Need a Makefile on your Project</a></li>
</ul>
<p>Both are written with a PHP context in mind.
Tip: If you are using PhpStorm, give the <a href="https://plugins.jetbrains.com/plugin/9333-makefile-support">Makefile support plugin</a>
a try. And don't forget the number one rule:
<a href="https://stackoverflow.com/q/14109724">A <code>Makefile</code> requires tabs</a>!</p>
<p>Note: If you are using Windows, <code>make</code> is probably not available. See
<a href="#install-make-on-windows-mingw">Install make on Windows (MinGW)</a> for instructions to set it up.</p>
<p>The <code>Makefile</code> ist located in the root of the application. Since we use a <code>help</code> target that makes the
<a href="https://suva.sh/posts/well-documented-makefiles/"><code>Makefile</code> self-documenting</a>, we can simply run <code>make</code> to
see all the available commands:</p>
<pre><code>$ make

Usage:
  make &lt;target&gt;

[Docker] Build / Infrastructure
  docker-clean                 Remove the .env file for docker
  docker-init                  Make sure the .env file exists for docker
  docker-build-from-scratch    Build all docker images from scratch, without cache etc. Build a specific image by providing the service name via: make docker-build CONTAINER=&lt;service&gt;
  docker-build                 Build all docker images. Build a specific image by providing the service name via: make docker-build CONTAINER=&lt;service&gt;
  docker-up                    Start all docker containers. To only start one container, use CONTAINER=&lt;service&gt;
  docker-down                  Stop all docker containers. To only stop one container, use CONTAINER=&lt;service&gt;
  docker-test                  Run the infrastructure tests for the docker setup</code></pre>
<p>As a new developer, your &quot;onboarding&quot; to get a running infrastructure should now look like this:</p>
<pre><code>make docker-clean
make docker-init
make docker-build-from-scratch
make docker-test</code></pre>
<h3><a id="install-make-on-windows-mingw"></a>Install make on Windows (MinGW)</h3>
<p><code>make</code> doesn't exist on Windows and is also not part of the standard installation of MinGW
(click here <a href="/blog/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/#git-and-git-bash">to learn how to setup MinGW</a>)
Setting is up is straight forward but as with &quot;everything UI&quot; it's easier if you can
actually &quot;see what I'm doing&quot; - so here's a video:</p>
<div class="center-div">
<iframe width="560" height="315" src="https://www.youtube.com/embed/taCJhnBXG_w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<p>The steps are as follows:</p>
<ul>
<li>Set up <code>mingw-get</code>
<ul>
<li>Instructions: <a href="http://www.mingw.org/wiki/getting_started#toc5">http://www.mingw.org/wiki/getting_started#toc5</a></li>
<li>Download: <a href="https://sourceforge.net/projects/mingw/files/Installer/mingw-get-setup.exe/download">https://sourceforge.net/projects/mingw/files/Installer/mingw-get-setup.exe/download</a></li>
<li>Install and <a href="/blog/php7-with-xdebug-2-4-for-phpstorm-on-windows-10/#the-path-variable">add the <code>bin/</code> directory to <code>PATH</code> (shortcut <code>systempropertiesadvanced</code>)</a>.
Notes: 
<ul>
<li>Do not use an installation path that contains spaces!</li>
<li>The installation path can be different from your MinGW location</li>
</ul></li>
</ul></li>
<li>Install <code>mingw32-make</code> via
<pre><code>mingw-get install mingw32-make</code></pre>
<ul>
<li>create the file <code>bin/make</code> with the content
<pre><code>mingw32-make.exe $*</code></pre></li>
<li>Note: Sometimes Windows won't recognize non-.exe files - so instead of <code>bin/make</code> you might need to name the file
<code>bin/make.exe</code> (with the same content)</li>
</ul></li>
<li>Open a new shell and type <code>make</code>. The output should look something like this
<pre><code>$ make
mingw32-make: *** Keine Targets angegeben und keine ¦make¦-Steuerdatei gefunden.  Schluss.</code></pre></li>
</ul>
<h3><a id="easy-container-access-via-din-bashrc-helper"></a>Easy container access via <code>din</code> .bashrc helper</h3>
<p>I've got one last goodie for working with Docker that I use all the time: </p>
<p>Logging into a running container via <a href="https://docs.docker.com/engine/reference/commandline/exec/#run-docker-exec-on-a-running-container"><code>docker exec</code></a>
and the <code>din / dshell</code> helper.</p>
<p><a href="/img/structuring-the-docker-setup-for-php-projects/easy-docker-login-din.gif.png"><img src="/img/structuring-the-docker-setup-for-php-projects/easy-docker-login-din.gif" alt="Log into any running docker container via din helper" /></a></p>
<p>To make this work, put the following code in your <code>.bashrc</code> file</p>
<pre><code>function din() {
  filter=$1

  user=""
  if [[ -n "$2" ]];
  then
    user="--user $2"
  fi

  shell="bash"
  if [[ -n "$3" ]];
  then
    shell=$3
  fi

  prefix=""
  if [[ "$(expr substr $(uname -s) 1 5)" == "MINGW" ]]; then
    prefix="winpty"
  fi
  ${prefix} docker exec -it ${user} $(docker ps --filter name=${filter} -q | head -1) ${shell}
}</code></pre>
<p>The <code>$(docker ps --filter name=${filter} -q | head -1)</code> part will find partial matches on running containers
for the first argument and pass the result to the <code>docker exec</code> command. In effect, we can log into any container
by only providing a minimal matching string on the container name. E.g. to log in the <code>workspace</code> container
I can now simply type <code>din works</code> from <em>anywhere</em> on my system.</p>
<h2><a id="fundamentals-on-building-the-containers"></a>Fundamentals on building the containers</h2>
<p>Since we have now &quot;seen&quot; the end result, let's take a closer look behind the scenes.
I assume that you are already somewhat familiar with <code>Dockerfile</code>s and have used <code>docker-compose</code> to orchestrate multiple
services (if not, check out
<a href="blog/php-php-fpm-and-nginx-on-docker-in-windows-10/#dockerfile">Persisting image changes with a Dockerfile</a> and
<a href="blog/php-php-fpm-and-nginx-on-docker-in-windows-10/#docker-compose">Putting it all together: Meet docker-compose</a>). But
there are some points I would like to cover in a little more detail.</p>
<h3><a id="understanding-build-context"></a>Understanding build context</h3>
<p>There are two essential parts when building a container:</p>
<ul>
<li>the Dockerfile</li>
<li>the build context</li>
</ul>
<p>You can read about the official description in the <a href="http://docs.docker.com/engine/reference/builder/#usage">Dockerfile reference</a>.
You'll usually see something like this:</p>
<pre><code>docker build .</code></pre>
<p>which assumes that you use the current directory as build context and that there is a Dockerfile in the same directory.</p>
<p>But you can also start the build via</p>
<pre><code>docker build .docker -f .docker/nginx/Dockerfile
                 |      |
                 |      └── use the Dockerfile at ".docker/nginx/Dockerfile"
                 |
                 └── use the .docker subdirectory as build context</code></pre>
<p>For me, the gist is this: The build context defines the files and folders (recursively) on your machine that are send
from the <a href="https://docs.docker.com/engine/reference/commandline/cli/">Docker CLI</a> to
the <a href="https://docs.docker.com/engine/reference/commandline/dockerd/">Docker Daemon</a> that executes the build process
of a container so that you can reference those files in the Dockerfile (e.g. via <code>COPY</code>). Take the following structure for example:</p>
<pre><code>&lt;project&gt;/
├── .docker/
    ├── .shared/
    |   └── scripts/
    |       └── ...
    └── nginx/
        ├── nginx.conf
        └── Dockerfile</code></pre>
<p>Assume, that the current working directory is <code>&lt;project&gt;/</code>. If we started a build via</p>
<pre><code>docker build .docker/nginx -f .docker/nginx/Dockerfile</code></pre>
<p>the context would <strong>not</strong> include the <code>.shared</code> folder so we wouldn't be able to <code>COPY</code> the <code>scripts/</code> subfolder.
If we ran</p>
<pre><code>docker build .docker -f .docker/nginx/Dockerfile</code></pre>
<p>however, that would make the <code>.shared</code> folder available. In the Dockerfile itself, I need to know what the build context
is, because I need to adjust the paths accordingly. Concrete example for the folder structure above and build
triggered via <code>docker build .docker -f .docker/nginx/Dockerfile</code>:</p>
<pre><code>FROM:nginx

# build context is .docker ...

# ... so the following COPY refers to .docker/.shared
COPY ./.shared /tmp

# ... so the following COPY refers to .docker/nginx/nginx.conf
COPY ./nginx/nginx.conf /tmp</code></pre>
<p>The build context for all of our containers will be the <code>.docker</code> directory,
so that all build processes have access to the <code>.shared</code> scripts and config.
Yes, that also means that the <code>php-fpm</code> container has access to files that are only relevant to the <code>mysql</code> container (for
instance), but the performance penalty is absolutely neglectable. Plus, as long as we don't actively <code>COPY</code> those irrelevant
files, they won't bloat up our images.</p>
<p>A couple of notes:</p>
<ul>
<li>I used to think that the build context is <em>always</em> tied to the location of the Dockerfile but that's only the default,
it can be any directory</li>
<li>the build context is <strong>actually send</strong> to the build process - i.e. you should avoid unnecessary files / folders as this might
affect performance, especially on big files (iaw: don't use <code>/</code> as context!)</li>
<li>similar to <code>git</code>, Docker knows the concept of a <a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file"><code>.dockerignore</code> file</a>
to exclude files from being included in the build context</li>
</ul>
<h3><a id="dockerfile-template"></a>Dockerfile template</h3>
<p>The Dockerfiles for the containers roughly follow the structure outlined below:</p>
<pre><code>FROM ...

# path to the directory where the Dockerfile lives relative to the build context
ARG SERVICE_DIR="./service"

# get the scripts from the build context and make sure they are executable
COPY .shared/scripts/ /tmp/scripts/
RUN chmod +x -R /tmp/scripts/

# set timezone
ARG TZ=UTC
RUN /tmp/scripts/set_timezone.sh ${TZ}

# add users
ARG APP_USER=www-data
ARG APP_USER_ID=1000
ARG APP_GROUP=$(APP_USER)
ARG APP_GROUP_ID=$(APP_USER_ID)

RUN /tmp/scripts/create_user.sh ${APP_USER} ${APP_GROUP} ${APP_USER_ID} ${APP_GROUP_ID}

# install common software
RUN /tmp/scripts/install_software.sh

# perform any other, container specific build steps
COPY ${SERVICE_DIR}/config/* /etc/service/config
RUN /tmp/scripts/modify_config.sh /etc/service/config/default.conf \
    "__APP_USER" \
    "${APP_USER}" \
;
# [...]

# set default work directory
WORKDIR "..."

# cleanup 
RUN /tmp/scripts/cleanup.sh

# define ENTRYPOINT
ENTRYPOINT [...]
CMD [...]</code></pre>
<p>The comments should suffice to give you an overview - so let's talk about the individual parts in detail.</p>
<h3><a id="setting-the-timezone"></a>Setting the timezone</h3>
<p><strong>Script: <code>set_timezone.sh</code></strong></p>
<p>Let's start with a simple and obvious one: Ensuring that all containers use the same system timezone
(see <a href="https://www.itzgeek.com/how-tos/linux/debian/how-to-change-timezone-in-debian-9-8-ubuntu-16-04-14-04-linuxmint-18.html">here</a>
and <a href="https://unix.stackexchange.com/q/452559">here</a>)</p>
<pre><code>#!/bin/sh

TZ=$1
ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone</code></pre>
<p>The script is then called from the <code>Dockerfile</code> via</p>
<pre><code>ARG TZ=UTC
RUN /tmp/scripts/set_timezone.sh ${TZ}</code></pre>
<h3><a id="synchronizing-file-and-folder-ownership-on-shared-volumes"></a>Synchronizing file and folder ownership on shared volumes</h3>
<p><strong>Script: <code>create_user.sh</code></strong></p>
<p>Docker makes it really easy to share files between containers by using <a href="https://docs.docker.com/storage/volumes/">volumes</a>.
For simplicities sake, you can picture a volume simply as an additional disk that multiple containers have access to.
And since it's PHP we're talking about here, sharing the same application files is a common requirement
(e.g. for <code>php-fpm</code>, <code>nginx</code>, <code>php-workers</code>).</p>
<p>As long as you are only dealing with one container, life is easy: You can simply <code>chown</code> files to the correct user.
But since the containers might have a different user setup, permissions/ownership becomes a problem. Checkout
<a href="https://serversforhackers.com/c/dckr-file-permissions">this video on Docker &amp; File Permissions</a> for a practical
example in a Laravel application.</p>
<p>The first thing for me was understanding that file ownership does not depend on the user <strong>name</strong> but rather on the user <strong>id</strong>.
And you might have guessed it: Two containers might have a user with the same name but with a different id.
The same is true for groups, btw. You can check the id by running <code>id &lt;name&gt;</code>, e.g.</p>
<pre><code>id www-data
uid=33(www-data) gid=33(www-data) groups=33(www-data)</code></pre>
<p><a href="/img/structuring-the-docker-setup-for-php-projects/docker-file-ownership-volume.png"><img src="/img/structuring-the-docker-setup-for-php-projects/docker-file-ownership-volume.png" alt="File ownership with multiple containers using a shared volume" /></a></p>
<p>That's inconvenient but rather easy to solve in most cases, because we have full control over the containers and
can <a href="https://www.cyberciti.biz/faq/linux-change-user-group-uid-gid-for-all-owned-files/">assign ids as we like</a>
(using <code>usermod -u &lt;id&gt; &lt;name&gt;</code>) and thus making sure every container uses the same user names with the same user ids.</p>
<p>Things get complicated when the volume isn't just a Docker volume but a shared folder on the host. This is usually
what we want for development, so that changes on the host are immediately reflected in all the containers.</p>
<p><a href="/img/structuring-the-docker-setup-for-php-projects/docker-file-ownership-host.png"><img src="/img/structuring-the-docker-setup-for-php-projects/docker-file-ownership-host.png" alt="File ownership with multiple containers using a shared volume from the host" /></a></p>
<p>This issue <strong>only affects users with a linux host system</strong>! Docker Desktop (previously known as Docker for Mac / Docker for Win)
has a virtualization layer in between that will effectively erase all ownership settings and make everything shared
from the host available to every user in a container.</p>
<p>We use the following script to ensure a consistent user setup when building a container:</p>
<pre><code>#!/bin/sh

APP_USER=$1
APP_GROUP=$2
APP_USER_ID=$3
APP_GROUP_ID=$4

new_user_id_exists=$(id ${APP_USER_ID} &gt; /dev/null 2&gt;&amp;1; echo $?) 
if [ "$new_user_id_exists" = "0" ]; then
    (&gt;&amp;2 echo "ERROR: APP_USER_ID $APP_USER_ID already exists - Aborting!");
    exit 1;
fi

new_group_id_exists=$(getent group ${APP_GROUP_ID} &gt; /dev/null 2&gt;&amp;1; echo $?) 
if [ "$new_group_id_exists" = "0" ]; then
    (&gt;&amp;2 echo "ERROR: APP_GROUP_ID $APP_GROUP_ID already exists - Aborting!");
    exit 1;
fi

old_user_id=$(id -u ${APP_USER})
old_user_exists=$(id -u ${APP_USER} &gt; /dev/null 2&gt;&amp;1; echo $?) 
old_group_id=$(getent group ${APP_GROUP} | cut -d: -f3)
old_group_exists=$(getent group ${APP_GROUP} &gt; /dev/null 2&gt;&amp;1; echo $?)

if [ "$old_group_id" != "${APP_GROUP_ID}" ]; then
    # create the group
    groupadd -f ${APP_GROUP}
    # and the correct id
    groupmod -g ${APP_GROUP_ID} ${APP_GROUP}
    if [ "$old_group_exists" = "0" ]; then
        # set the permissions of all "old" files and folder to the new group
        find / -group $old_group_id -exec chgrp -h ${APP_GROUP} {} \; || true
    fi 
fi

if [ "$old_user_id" != "${APP_USER_ID}" ]; then
    # create the user if it does not exist
    if [ "$old_user_exists" != "0" ]; then
        useradd ${APP_USER} -g ${APP_GROUP}
    fi

    # make sure the home directory exists with the correct permissions
    mkdir -p /home/${APP_USER} &amp;&amp; chmod 755 /home/${APP_USER} &amp;&amp; chown ${APP_USER}:${APP_GROUP} /home/${APP_USER} 

    # change the user id, set the home directory and make sure the user has a login shell
    usermod -u ${APP_USER_ID} -m -d /home/${APP_USER} ${APP_USER} -s $(which bash)

    if [ "$old_user_exists" = "0" ]; then
        # set the permissions of all "old" files and folder to the new user 
        find / -user $old_user_id -exec chown -h ${APP_USER} {} \; || true
    fi
fi</code></pre>
<p>The script is then called from the <code>Dockerfile</code> via</p>
<pre><code>ARG APP_USER=www-data
ARG APP_USER_ID=1000
ARG APP_GROUP=$(APP_USER)
ARG APP_GROUP_ID=$(APP_USER_ID)

RUN /tmp/scripts/create_user.sh ${APP_USER} ${APP_GROUP} ${APP_USER_ID} ${APP_GROUP_ID}</code></pre>
<p>The default values can be overriden by passing in the corresponding
<a href="https://docs.docker.com/engine/reference/commandline/build/#set-build-time-variables---build-arg">build args</a>. </p>
<p>Linux users should use the user id of the user on their host system - for Docker Desktop users the defaults are fine.</p>
<h3><a id="modifying-configuration-files"></a>Modifying configuration files</h3>
<p>For most services we probably need some custom configuration settings, like</p>
<ul>
<li>setting php.ini values</li>
<li>changing the default user of a service </li>
<li>changing the location of logfiles</li>
</ul>
<p>There are a couple of<br />
<a href="https://dantehranian.wordpress.com/2015/03/25/how-should-i-get-application-configuration-into-my-docker-containers/">common approaches to modify application configuration in docker</a>
and we are currently trying to stick to two rules:</p>
<ol>
<li>provide additional files that override defaults if possible</li>
<li>change non-static values with a simple search and replace via <code>sed</code> during the container build</li>
</ol>
<h4><a id="providing-additional-config-files"></a>Providing additional config files</h4>
<p>Most services allow the specification of additional configuration files that override the default values in
a default config file. This is great because we only need to define the settings that we actually care about
instead of copying a full file with lots of redundant values.</p>
<p>Take the <a href="http://php.net/manual/en/configuration.file.php#configuration.file.scan"><code>php.ini</code> file</a> for example:
It allows to places additional <code>.ini</code> files in a specific directory that override the default values. An easy way
to find this directory is <code>php -i | grep "additional .ini"</code>:</p>
<pre><code>$ php -i | grep "additional .ini"
Scan this dir for additional .ini files =&gt; /usr/local/etc/php/conf.d</code></pre>
<p>So instead of providing a &quot;full&quot; <code>php.ini</code> file, we will use a <code>zz-app.ini</code> file instead, that <strong>only</strong> contains the
.ini settings we actually want to change and place it under <code>/usr/local/etc/php/conf.d</code>. </p>
<p>Why <code>zz-</code>? Because</p>
<blockquote>
<p>[...] Within each directory, PHP will scan all files ending in .ini in alphabetical order.</p>
</blockquote>
<p>so if we want to ensure that our .ini files comes last (overriding all previous settings), we'll give it a
corresponding prefix :)</p>
<p>The full process would look like this:</p>
<ul>
<li>place the file in the <code>.docker</code> folder, e.g. at <code>.docker/.shared/config/php/conf.d/zz-app.ini</code></li>
<li>pass the folder as build context</li>
<li>in the Dockerfile, use <code>COPY .shared/config/php/conf.d/zz-app.ini /usr/local/etc/php/conf.d/zz-app.ini</code></li>
</ul>
<h4><a id="changing-non-static-values"></a>Changing non-static values</h4>
<p><strong>Script: <code>modify_config.sh</code></strong></p>
<p>Some configuration values are subject to local settings and thus should not be hard coded in configuration files.
Take the <code>memory_limit</code> configuration for <code>php-fpm</code> as an example: Maybe someone in the team can only dedicate
a limited amount of memory to docker, so the <code>memory_limit</code> has to be kept lower than usual.</p>
<p>We'll account for that fact by using a variable prefixed by <code>__</code> instead of the real value and replace it with
a dynamic argument in the Dockerfile. Example for the aforementioned <code>zz-app.ini</code>:</p>
<pre><code>memory_limit = __MEMORY_LIMIT</code></pre>
<p>We use the following script <code>modify_config.sh</code> to replace the value:</p>
<pre><code>#!/bin/sh

CONFIG_FILE=$1
VAR_NAME=$2
VAR_VALUE=$3

sed -i -e "s#${VAR_NAME}#${VAR_VALUE}#" "${CONFIG_FILE}"</code></pre>
<p>The script is then called from the <code>Dockerfile</code> via</p>
<pre><code>ARG PHP_FPM_MEMORY_LIMIT=1024M

RUN /tmp/scripts/modify_config.sh \
    "/usr/local/etc/php/conf.d/zz-app.ini" \
    "__MEMORY_LIMIT" \
    "${PHP_FPM_MEMORY_LIMIT}" \
;</code></pre>
<p>where <code>PHP_FPM_MEMORY_LIMIT</code> has a default value of <code>1024M</code> but can be overriden when the actual build is initiated.</p>
<h3><a id="installing-php-extensions"></a>Installing php extensions</h3>
<p><strong>Script: <code>install_php_extensions.sh</code></strong></p>
<p>When php extensions are missing, googling will often point to answers for normal linux systems using <code>apt-get</code> or <code>yum</code>,
e.g. <code>sudo apt-get install php-xdebug</code>. But for the official docker images, the recommended way is using the
<a href="https://github.com/docker-library/docs/blob/master/php/README.md#how-to-install-more-php-extensions">docker-php-ext-configure, docker-php-ext-install, and docker-php-ext-enable helper scripts</a>.
Unfortunately, some extensions have rather complicated dependencies, so that the installation fails.
Fortunately, there is a great project on Github called
<a href="https://github.com/mlocati/docker-php-extension-installer">docker-php-extension-installer</a> that takes care of that for us
and is super easy to use:</p>
<pre><code>FROM php:7.3-cli

ADD https://raw.githubusercontent.com/mlocati/docker-php-extension-installer/master/install-php-extensions /usr/local/bin/

RUN chmod uga+x /usr/local/bin/install-php-extensions &amp;&amp; sync &amp;&amp; install-php-extensions xdebug</code></pre>
<p>The readme also contains an
<a href="https://github.com/mlocati/docker-php-extension-installer#supported-php-extensions">overview of supported extension</a>
per PHP version. To ensure that all of our PHP containers have the same extensions, we provide the following script:</p>
<pre><code>#!/bin/sh

# add wget
apt-get update -yqq &amp;&amp; apt-get -f install -yyq wget

# download helper script
wget -q -O /usr/local/bin/install-php-extensions https://raw.githubusercontent.com/mlocati/docker-php-extension-installer/master/install-php-extensions \
    || (echo "Failed while downloading php extension installer!"; exit 1)

# install all required extensions
chmod uga+x /usr/local/bin/install-php-extensions &amp;&amp; sync &amp;&amp; install-php-extensions \
    xdebug \
    opcache \
;</code></pre>
<p>If you're not sure which extensions are required by your application, give the
<a href="https://github.com/maglnet/ComposerRequireChecker">ComposerRequireChecker</a> a try.</p>
<h3><a id="installing-common-software"></a>Installing common software</h3>
<p><strong>Script: <code>install_software.sh</code></strong></p>
<p>There is a certain set of software that I want to have readily available in every container. Since this a development
setup, I'd prioritize ease of use / debug over performance / image size, so this might seem like a little &quot;too much&quot;.
I think I'm also kinda spoiled by my Homestead past, because it's so damn convenient to have everything right at
your fingertips :)</p>
<p>Anyway, the script is straight forward:</p>
<pre><code>#!/bin/sh

apt-get update -yqq &amp;&amp; apt-get install -yqq \
    curl \
    dnsutils \
    gdb \
    git \
    htop \
    iputils-ping \
    iproute2 \
    ltrace \
    make \
    procps \
    strace \
    sudo \
    sysstat \
    unzip \
    vim \
    wget \
;</code></pre>
<p>Notes:</p>
<ul>
<li>this list should match <strong>your own set of go-to tools</strong>. I'm fairly open to adding new stuff here if it speeds up the
dev workflow. But if you don't require some of the tools, get rid of them.</li>
<li>sorting the software alphabetically is a good practice to avoid unnecessary duplicates. Don't do this by hand, though!
If you're using an IDE / established text editor, chances are high that this is either a build-in functionality or
there's a plugin available. I'm using <a href="https://plugins.jetbrains.com/plugin/5919-lines-sorter">Lines Sorter for PhpStorm</a></li>
</ul>
<h3><a id="cleaning-up"></a>Cleaning up</h3>
<p><strong>Script: <code>cleanup.sh</code></strong></p>
<p>Nice and simple:</p>
<pre><code>#!/bin/sh

apt-get clean
rm -rf /var/lib/apt/lists/* \
       /tmp/* \
       /var/tmp/* \
       /var/log/lastlog \
       /var/log/faillog</code></pre>
<h3><a id="using-entrypoint-for-pre-run-configuration"></a>Using <code>ENTRYPOINT</code> for pre-run configuration</h3>
<p>Docker went back to the unix roots with the
<a href="https://en.wikipedia.org/wiki/Unix_philosophy#Do_One_Thing_and_Do_It_Well">do on thing and do it well philosophy</a> which is
manifested in the <a href="https://medium.freecodecamp.org/docker-entrypoint-cmd-dockerfile-best-practices-abc591c30e21"><code>CMD</code> and <code>ENTRYPOINT</code> instructions</a>.</p>
<p>As I had a hard time understanding those instructions when I started with Docker, here's my take at a layman's terms description:</p>
<ul>
<li>since a container should do one thing, we need to specify that thing. That's what we do with <code>ENTRYPOINT</code>. Concrete examples:
<ul>
<li>a <code>mysql</code> container should probably run the <code>mysqld</code> daemon</li>
<li>a <code>php-fpm</code> container.. well, <code>php-fpm</code></li>
</ul></li>
<li>the <code>CMD</code> is passed as the default argument to the <code>ENTRYPOINT</code></li>
<li>the <code>ENTRYPOINT</code> is executed every time we <em>run</em> a container. Some things can't be done during build but only at runtime
(e.g. find the IP of the host from within a container - see section
<a href="providing-host-docker-internal-for-linux-host-systems">Providing <code>host.docker.internal</code> for linux host systems</a>
) - <code>ENTRYPOINT</code> is a good solution for that problem</li>
<li>technically, we can only override an already existing <code>ENTRYPOINT</code> from the base image. But: We can structure the new
<code>ENTRYPOINT</code> like a <a href="https://en.wikipedia.org/wiki/Decorator_pattern">decorator</a> by adding <code>exec "$@"</code> at the end to
simulate inheritance from the parent image</li>
</ul>
<p>To expand on the last point, consider the default
<a href="https://github.com/docker-library/php/blob/640a30e8ff27b1ad7523a212522472fda84d56ff/7.3/stretch/fpm/docker-php-entrypoint"><code>ENTRYPOINT</code> of the current [2019-02-23; PHP 7.3] <code>php-fpm</code> image</a></p>
<pre><code>#!/bin/sh

set -e

# first arg is `-f` or `--some-option`
if [ "${1#-}" != "$1" ]; then
    set -- php-fpm "$@"
fi

exec "$@"</code></pre>
<p>In the <a href="https://github.com/docker-library/php/blob/640a30e8ff27b1ad7523a212522472fda84d56ff/7.3/stretch/fpm/Dockerfile#L223">corresponding Dockerfile</a>
we find the following instructions:</p>
<pre><code># [...]
ENTRYPOINT ["docker-php-entrypoint"]
# [...]
CMD ["php-fpm"]</code></pre>
<p>That means: When we run the container it will pass the string &quot;php-fpm&quot; to the <code>ENTRYPOINT</code> script <code>docker-php-entrypoint</code>
as argument which will then execute it (due to the <code>exec "$@"</code> instruction at the end):</p>
<pre><code>$ docker run --name test --rm php:fpm
[23-Feb-2019 14:49:20] NOTICE: fpm is running, pid 1
[23-Feb-2019 14:49:20] NOTICE: ready to handle connections
# php-fpm is running
# Hit ctrl + c to close the connection
$ docker stop test</code></pre>
<p>We could now override the default <code>CMD</code> &quot;php-fpm&quot; with something else, e.g. a simple <code>echo "hello"</code>. The <code>ENTRYPOINT</code>
will happily execute it:</p>
<pre><code>$ docker run --name test --rm php:fpm echo "hello"
hello</code></pre>
<p>But now the <code>php-fpm</code> process isn't started any more. How can we echo &quot;hello&quot; but still keep the fpm process running?
By adding our own <code>ENTRYPOINT</code> script:</p>
<pre><code>#!/bin/sh
echo 'hello'

exec "$@"</code></pre>
<p>Full example (using <a href="https://docs.docker.com/engine/reference/commandline/build/#build-with--">stdin to pass the Dockerfile</a>
via <a href="https://stackoverflow.com/q/2953081/413531">Heredoc string</a>)</p>
<pre><code>$ docker build -t my-fpm -&lt;&lt;'EOF'
FROM php:fpm

RUN  touch "/usr/bin/my-entrypoint.sh" \
  &amp;&amp; echo "#!/bin/sh" &gt;&gt; "/usr/bin/my-entrypoint.sh" \
  &amp;&amp; echo "echo 'hello'" &gt;&gt; "/usr/bin/my-entrypoint.sh" \
  &amp;&amp; echo "exec \"\$@\"" &gt;&gt; "/usr/bin/my-entrypoint.sh" \
  &amp;&amp; chmod +x "/usr/bin/my-entrypoint.sh" \
  &amp;&amp; cat "/usr/bin/my-entrypoint.sh" \
;

ENTRYPOINT ["/usr/bin/my-entrypoint.sh", "docker-php-entrypoint"]
CMD ["php-fpm"]
EOF</code></pre>
<p>Note that we added the <code>ENTRYPOINT</code> of the parent image <code>docker-php-entrypoint</code> as argument to our own <code>ENTRYPOINT</code> script
<code>/usr/bin/my-entrypoint.sh</code> so that we don't loose its functionality. And we need to define the <code>CMD</code> instruction explicitly,
because the one from the parent image is <a href="https://stackoverflow.com/a/49031590/413531">automatically removed once we define our own <code>ENTRYPOINT</code></a>.</p>
<p>But: It works: </p>
<pre><code>$ docker run --name test --rm my-fpm
hello
[23-Feb-2019 15:43:25] NOTICE: fpm is running, pid 1
[23-Feb-2019 15:43:25] NOTICE: ready to handle connections
# Hit ctrl + c to close the connection
$ docker stop test</code></pre>
<h4><a id="providing-host-docker-internal-for-linux-host-systems"></a>Providing <code>host.docker.internal</code> for linux host systems</h4>
<p><strong>Script: <code>docker-entrypoint/resolve-docker-host-ip.sh</code></strong></p>
<p>In the previous part of this tutorial series, I explained how to build the
<a href="/blog/setup-phpstorm-with-xdebug-on-docker">Docker container in a way that it plays nice with PhpStorm and Xdebug</a>.
The key parts were SSH access and the magical <code>host.docker.internal</code> DNS entry. This works great for Docker Desktop (Windows and Mac)
but not for Linux. The DNS entry <a href="https://github.com/docker/for-linux/issues/264">doesn't exist there</a>.
Since we rely on that entry
<a href="/blog/setup-phpstorm-with-xdebug-on-docker/#fix-xdebug-on-phpstorm-when-run-from-a-docker-container">to make debugging possible</a>,
we will set it &quot;manually&quot; <a href="https://stackoverflow.com/a/24049165/413531">if the host doesn't exist</a>
with the following script
(inspired by the article <a href="https://dev.to/bufferings/access-host-from-a-docker-container-4099">Access host from a docker container</a>):</p>
<pre><code>#!/bin/sh

set -e

HOST_DOMAIN="host.docker.internal"

# check if the host exists - this will fail on linux
if dig ${HOST_DOMAIN} | grep -q 'NXDOMAIN'
then
  # resolve the host IP
  HOST_IP=$(ip route | awk 'NR==1 {print $3}')
  # and write it to the hosts file
  echo "$HOST_IP\t$HOST_DOMAIN" &gt;&gt; /etc/hosts
fi

exec "$@"</code></pre>
<p>The script is placed at <code>.shared/docker-entrypoint/resolve-docker-host-ip.sh</code> and added as <code>ENTRYPOINT</code> in the Dockerfile via </p>
<pre><code>COPY .shared/scripts/ /tmp/scripts/

RUN mkdir -p /bin/docker-entrypoint/ \
 &amp;&amp; cp /tmp/scripts/docker-entrypoint/* /bin/docker-entrypoint/ \
 &amp;&amp; chmod +x -R /bin/docker-entrypoint/ \
;

ENTRYPOINT ["/bin/docker-entrypoint/resolve-docker-host-ip.sh", ...]</code></pre>
<p>Notes:</p>
<ul>
<li>since this script depends on runtime configuration, we need to run it as an <code>ENTRYPOINT</code></li>
<li>there is no need to explicitly check for the OS type - we simply make sure that the DNS entry exists
and add it if it doesn't</li>
<li>we're using <code>dig</code> (package <code>dnsutils</code>) and <code>ip</code> (package <code>iproute2</code>) which need to be installed
during the build time of the container. Tip: If you need to figure out the package for a specific command,
give <a href="https://command-not-found.com/">https://command-not-found.com/</a> a try. See the
<a href="https://command-not-found.com/dig">entry for <code>dig</code></a> for instance.</li>
<li>this workaround is only required in containers we want to debug via xdebug</li>
</ul>
<h2><a id="wrapping-up"></a>Wrapping up</h2>
<p>Congratulations, you made it! If some things are not completely clear by now, don't hesitate to leave a comment.
Apart from that, you should now have a running docker setup for your local PHP development as well as a nice &quot;flow&quot;
to get started each day.</p>
<p>In the next part of this tutorial, we will add some more containers (php workers, mysql, redis, blackfire) and use
a fresh installation of Laravel to make use of them.</p>
<p>Please subscribe to the <a href="/feed.xml">RSS feed</a> or <a href="#newsletter">via email</a> to get automatic notifications when this next part comes out :)</p>]]></description>
                <pubDate>Mon, 20 May 2019 10:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/blog/structuring-the-docker-setup-for-php-projects/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/blog/structuring-the-docker-setup-for-php-projects/</guid>
            </item>
                    <item>
                <title>How to setup PhpStorm with Xdebug on Docker [Tutorial Part 2]</title>
                <description><![CDATA[<div class="panel panel-default">
  <div class="panel-heading">
    <strong>Caution</strong>
  </div>
  <div class="panel-body bg-danger">
    A <strong>newer version</strong> of this article for PHP 8.1, Xdebug 3 and PhpStorm 2021.3.2
    <br>
    <a href="/blog/phpstorm-docker-xdebug-3-php-8-1-in-2022/">PhpStorm, Docker and Xdebug 3 on PHP 8.1 in 2022</a>
  </div>
</div>
<p>In the second part of this tutorial series on developing PHP on Docker we're taking a good hard look
at PhpStorm, Xdebug and how to run and debug scripts from within PhpStorm on Docker.</p>
<div style="text-align:center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/27KBaI24jKI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</div>
<h2>Published parts of the Docker PHP Tutorial</h2>
<ul>
<li><a href="/blog/php-php-fpm-and-nginx-on-docker-in-windows-10/">Setting up PHP, PHP-FPM and NGINX for local development on Docker</a>
(2018-07-08)</li>
<li><a href="/blog/setup-phpstorm-with-xdebug-on-docker/">Setting up PhpStorm with Xdebug for local development on Docker</a>
(2018-08-06)</li>
<li><a href="/blog/structuring-the-docker-setup-for-php-projects/">Structuring the Docker setup for PHP Projects</a>
(2019-05-20)</li>
<li><a href="/blog/docker-from-scratch-for-php-applications-in-2022/">Docker from scratch for PHP 8.1 Applications in 2022</a>
(2022-03-21)</li>
<li><a href="/blog/phpstorm-docker-xdebug-3-php-8-1-in-2022/">PhpStorm, Docker and Xdebug 3 on PHP 8.1 in 2022</a>
(2022-03-22)</li>
<li><a href="/blog/run-laravel-9-docker-in-2022/">Run Laravel 9 on Docker in 2022</a>
(2022-03-23)</li>
</ul>
<p>All code samples are publicly available in my
<a href="https://github.com/paslandau/docker-php-tutorial">Docker PHP Tutorial repository on github</a>.
The branch for this tutorial is
<a href="https://github.com/paslandau/docker-php-tutorial/tree/part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker">part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker</a>.</p>
<p><strong>Note</strong>: The setup that I am going to use is for demonstration purposes only! I do <strong>not</strong> recommend that you use it
&quot;as is&quot; as your development setup. Some problems that I won't solve here include:</p>
<ul>
<li>everything is owned by root (no dedicated user; that will in particular be problematic for linux users)</li>
<li>SSH login credentials are hard-coded in the container (inherently insecure)</li>
<li><code>host.docker.internal</code> will only exist for Windows and Mac users, NOT for unix users</li>
</ul>
<p>There will be a another part of this series that will deal with all of those (and some more common) problems and
aims at providing a consistent development environment for all developers in a team (regardless of the OS they are using).
Please subscribe to the <a href="http:///feed.xml">RSS feed</a> to get automatic notifications when that part comes out :)</p>
<h2>Table of contents</h2>
<ul>
<li><a href="#setup-the-docker-containers">Setup: The docker containers</a></li>
<li><a href="#run-php-via-built-in-docker-setup">Run PHP via built-in Docker setup</a><ul>
 <li><a href="#enable-docker-to-communicate-on-port%202375">Enable docker to communicate on port 2375</a></li>
 <li><a href="#configure-docker-server-in-phpstorm">Configure Docker Server in PhpStorm</a></li>
 <li><a href="#configure-docker-php-cli-interpreter">Configure Docker PHP CLI Interpreter</a></li>
 <li><a href="#run-debug-a-php-script-on-docker-server">Run/debug a php script on docker</a></li>
</ul></li>
<li><a href="#run-php-on-docker-via-deployment-configuration">Run PHP on Docker via Deployment Configuration</a><ul>
 <li><a href="#preparing-the-workspace-container">Preparing the "workspace" container</a></li>
 <li><a href="#configure-the-deployment-configuration">Configure the Deployment Configuration</a></li>
 <li><a href="#run-debug-a-php-script-on-docker">Run/debug a php script on docker</a></li>
 <li><a href="#fix-xdebug-on-phpstorm-when-run-from-a-docker-container">Fix Xdebug on PhpStorm when run from a Docker container</a></li>
</ul></li>
</ul>
<h2><a id="setup-the-docker-containers"></a>Setup: The docker containers</h2>
<p>We will only need the php-cli container for this part.
Luckily, we already have a good understanding on how to create the container, although we'll need to make some
adjustments to make everything work smoothly with PhpStorm. I'm gonna walk you through all the necessary changes,
but I'd still recommend to clone the corresponding git repository <a href="https://github.com/paslandau/docker-php-tutorial">docker-php-tutorial</a>
(unless you've already done that in part 1), checkout branch <a href="https://github.com/paslandau/docker-php-tutorial/tree/part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker"><code>part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker</code></a> and
build the containers now.</p>
<p>As in part 1, I'm assuming your codebase lives at <code>/c/codesbase</code>:</p>
<pre><code>cd /c/codebase/
git clone https://github.com/paslandau/docker-php-tutorial.git
cd docker-php-tutorial
git checkout part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker
docker-compose build</code></pre>
<p>Further, make sure to open <code>/c/codebase/docker-php-tutorial</code> as a project in PhpStorm.</p>
<p>In general, there are two ways to run PHP from PhpStorm using Docker:</p>
<ol>
<li>via the built-in Docker setup</li>
<li>via Deployment Configuration (treating docker more or less like a VM)</li>
</ol>
<h2><a id="run-php-via-built-in-docker-setup"></a>Run PHP via built-in Docker setup</h2>
<p>This is the &quot;easier&quot; way and should mostly work &quot;out of the box&quot;. When you run a PHP script using this method, PhpStorm will start a
docker container and configure it automatically (path mappings, network setup, ...). Next, the script in question is executed and the container
is stopped afterwards.</p>
<h3><a id="enable-docker-to-communicate-on-port 2375"></a>Enable docker to communicate on port 2375</h3>
<p>Open the Docker Setting in tab &quot;General&quot; and activate the checkbox that says
&quot;Expose daemon on tcp://localhost:2375 without TLS&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-port-tcp-2375.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-port-tcp-2375.PNG" alt="Enable docker to communicate on port 2375" /></a></p>
<h3><a id="configure-docker-server-in-phpstorm"></a>Configure Docker Server in PhpStorm</h3>
<p>In PhpStorm, navigate to <code>File | Settings | Build, Execution, Deployment | Docker</code>. Fill out <code>Name</code> and <code>Engine API URL</code>:</p>
<ul>
<li>Name: Docker</li>
<li>Engine API URL: <code>tcp://localhost:2375</code></li>
</ul>
<p>PhpStorm will automatically validate your settings and show a &quot;Connection successful&quot; info below the path mappings box:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/php-built-in-docker-setup.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/php-built-in-docker-setup.PNG" alt="Configure Docker server in PhpStorm" /></a></p>
<h3><a id="configure-docker-php-cli-interpreter"></a>Configure Docker PHP CLI Interpreter</h3>
<p>Navigate to <code>File | Settings | Languages &amp; Frameworks | PHP</code>. Click on the three dots &quot;...&quot; next to &quot;CLI Interpreter&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter.PNG" alt="Setup CLI Interpreter PhpStorm" /></a></p>
<p>In the newly opened pop up click on the &quot;+&quot; sign on the top left and choose &quot;From Docker,Vagrant,VM,Remote...&quot;</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker.PNG" alt="New CLI Interpreter" /></a></p>
<p>Next, choose &quot;Docker&quot; from the radio buttons and select our previously created Docker server (named &quot;Docker&quot;).
As image, choose <code>docker-php-tutorial_docker-php-cli:latest</code> (which is one of the images used in this tutorial). If you don't see
this image you've probably not yet built the containers. In that case, please checkout the repo and build the containers: </p>
<pre><code>cd /c/codebase/
git clone https://github.com/paslandau/docker-php-tutorial.git
cd docker-php-tutorial
git checkout part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker
docker-compose build</code></pre>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker-php-cli.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker-php-cli.PNG" alt="New CLI Interpreter from Docker server" /></a></p>
<p>PhpStorm will now try to create the container and figure out if it can run PHP. If all goes well, you should see the following screenshot
with information about the PHP and Xdebug versions in the image/container.</p>
<p><em>Note</em>: Sometimes, this does not work immediately. If that's the case for you, try to click the &quot;Refresh&quot; icon next to &quot;PHP executable&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker-configured.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker-configured.PNG" alt="New CLI Interpreter from Docker configured" /></a></p>
<p>After you hit &quot;OK&quot;, you'll be back in the PHP Interpreter screen where our newly configured Docker interpreter should be already selected:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-done.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-done.PNG" alt="New CLI Interpreter from Docker chosen" /></a></p>
<p>Note that PhpStorm has automatically configured the path mappings as <code>-v</code> command line option for the Docker container. After hitting &quot;OK&quot;
one last time, everything is set up.</p>
<h3><a id="run-debug-a-php-script-on-docker-server"></a>Run/debug a php script on docker</h3>
<p>To verify that everything is working, open the file <code>app/hello-world.php</code> in PhpStorm, right click in the editor pane and choose &quot;Run&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-run-php-script.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-run-php-script.PNG" alt="Run PHP script" /></a></p>
<p>PhpStorm will start the configured container and run the script. The output is then visible at the bottom of the IDE:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/built-in-docker-run-php-script-finished.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/built-in-docker-run-php-script-finished.PNG" alt="PHP script output" /></a></p>
<p>Since we're using an image that has Xdebug installed, we can also set a breakpoint and use &quot;Debug&quot; instead of &quot;Run&quot; to trigger a debug session:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script.PNG" alt="Debug PHP script" /></a></p>
<p>PhpStorm should stop on the marked line. </p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script-breakpoint.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script-breakpoint.PNG" alt="Debug PHP script pausing" /></a></p>
<p>When you take a look at the &quot;Console&quot; panel at the bottom of the IDE, you should see something like this:</p>
<pre><code>docker://docker-php-tutorial_docker-php-cli:latest/php -dxdebug.remote_enable=1 -dxdebug.remote_mode=req -dxdebug.remote_port=9000 -dxdebug.remote_host=192.168.10.1 /opt/project/app/hello-world.php</code></pre>
<p>Please keep the <code>-dxdebug.remote_host=192.168.10.1</code> option in mind - this will be &quot;interesting&quot; when we set up a Docker-based PHP Interpreter
via Deployment Configuration ;)</p>
<p>PS: You find the official documentation for the built-in Docker support at
<a href="https://confluence.jetbrains.com/display/PhpStorm/Docker+Support+in+PhpStorm">Docker Support in PhpStorm</a>.</p>
<h2><a id="run-php-on-docker-via-deployment-configuration"></a>Run PHP on Docker via Deployment Configuration</h2>
<p>The previously explained method is nice, but it is lacking flexibility and it's also pretty slow as the container used to run
the script needs to be started each time we want to execute something. Luckily, there is an additional way of running PHP scripts
on Docker in PhpStorm, which is closely related to the Vagrant setup that I explained in
<a href="https://www.pascallandau.com/blog/phpstorm-with-vagrant-using-laravel-homestead-on-windows-10/#configuring-phpstorm-to-use-the-vagrant-box">Configuring PhpStorm to use the vagrant box</a>.</p>
<p>To make this work, we will keep a docker container running all the time and configure PhpStorm to connect to it via SSH. Thus, PhpStorm
effectively treats the docker container as any other remote host.</p>
<h3><a id="preparing-the-workspace-container"></a>Preparing the &quot;workspace&quot; container</h3>
<p>Please make sure to checkout my demo repository and switch to the correct branch first:</p>
<pre><code>cd /c/codebase/
git clone https://github.com/paslandau/docker-php-tutorial.git
cd docker-php-tutorial
git checkout part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker</code></pre>
<p>For now, we only need the <code>php-cli</code> container. In it, we need to setup the xdebug extension (already done and explained in the previous part) and
an SSH server so that we can log in via SSH. Let's take a look a the <code>Dockerfile</code>:</p>
<pre><code>FROM php:7.0-cli

RUN apt-get update -yqq \
 &amp;&amp; apt-get install -yqq \
    # install sshd
    openssh-server \
    # install ping and netcat (for debugging xdebug connectivity)
    iputils-ping netcat \
    # fix ssh start up bug
    # @see https://github.com/ansible/ansible-container/issues/141
 &amp;&amp; mkdir /var/run/sshd \
;

# add default public key to authorized_keys
COPY ./ssh/insecure_id_rsa.pub /root/insecure_id_rsa.pub
RUN mkdir -p /root/.ssh \
 &amp;&amp; cat /root/insecure_id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys \
 &amp;&amp; rm -rf /root/insecure_id_rsa.pub \
;

RUN pecl -q install xdebug-2.6.0 \
;
COPY ./conf.d/xdebug.ini /usr/local/etc/php/conf.d/xdebug.ini

# @see https://docs.docker.com/engine/examples/running_ssh_service/
CMD ["/usr/sbin/sshd", "-D"]
</code></pre>
<p>and the <code>docker-compose.yml</code>:</p>
<pre><code>  docker-php-cli:
    # define the directory where the build should happened,
    # i.e. where the Dockerfile of the service is located
    # all paths are relative to the location of docker-compose.yml
    build: 
      context: ./php-cli
    # make the SSH port available via port mapping
    ports:
      - "2222:22"
    # reserve a tty - otherwise the container shuts down immediately
    # corresponds to the "-i" flag
    tty: true
    # mount the app directory of the host to /var/www in the container
    # corresponds to the "-v" option
    volumes:
      - ./app:/var/www
    # connect to the network
    # corresponds to the "--network" option
    networks:
      - web-network</code></pre>
<p>There are four things to note:</p>
<ol>
<li>installing the server </li>
<li>adding the ssh keys to actually log in</li>
<li>changing the default <code>CMD</code> to keep the SSH daemon running</li>
<li>port- and volume mapping</li>
</ol>
<h4><a id="installing-the-server"></a>Installing the server</h4>
<p>The server installation is straight forward:</p>
<pre><code>apt-get install -yqq openssh-server</code></pre>
<p>the only none-intuitive thing is, that we need to &quot;manually&quot; create the directory <code>/var/run/sshd</code>
( <a href="https://github.com/ansible/ansible-container/issues/141">due to a bug</a> ).</p>
<h4><a id="adding-the-ssh-keys"></a>Adding the ssh keys</h4>
<p>For the ssh keys, I'm choosing the easy route (for now) and use a pre-generated ssh key pair (see <code>php-cli/ssh/*</code>).
The content of the public key is appended to <code>/root/.ssh/authorized_keys</code> so that I can log in to the container as user <code>root</code> using the
corresponding private key from <code>php-cli/ssh/insecure_id_rsa</code>.</p>
<p><strong>Caution</strong>: Of course, this is massively insecure! Those keys are part of the repository, making them available to everybody with access to the repo.
That makes sense for this publicly available tutorial (because everything works &quot;out of the box&quot; for everybody following along) but it is also one
of the reasons you should <strong>not</strong> use that repo as your <strong>actual</strong> development setup.</p>
<p>Again, there will be another part of this tutorial in which I'll present a solution to this problem (using volumes to share my local ssh keys with a
container and an <code>ENTRYPOINT</code> to put them in the right place).</p>
<h4><a id="keep-the-ssh-daemon-running"></a>Keep the SSH daemon running</h4>
<p>For SSH to work, we must start <code>sshd</code> and keep it running in the container. We achieve this by using <code>CMD ["/usr/sbin/sshd", "-D"]</code> in the
Dockerfile, following the official docker example to <a href="https://docs.docker.com/engine/examples/running_ssh_service/">Dockerize an SSH service</a>.</p>
<h4><a id="port-and-volume-mapping"></a>Port- and volume mapping</h4>
<p>Since docker containers do not have deterministic IP addresses, we map port 22 from the container to port 2222 on our host machine and we
further provide a path mapping from our local <code>./app</code> folder to <code>/var/www</code> in the container. Both pieces of information a required when
we configure PhpStorm later on.</p>
<p>Now that everything is in place, let's build and run the container:</p>
<pre><code>cd /c/codebase/docker-php-tutorial
docker-compose up -d docker-php-cli</code></pre>
<p>yielding</p>
<pre><code>Pascal@Landau-Laptop MINGW64 /d/codebase/docker-php-tutorial (part_2_setting-up-phpstorm-with-xdebug-for-local-development-on-docker)
$ docker-compose up -d docker-php-cli
Creating docker-php-tutorial_docker-php-cli_1 ... done</code></pre>
<p><em>Note</em>: One might argue, that it's kinda defeating the purpose of docker, when we now treat it as a VM, installing SSH and neglecting it's
&quot;one process per container&quot; rule. But honestly, I don't care about that when
it comes to my local development setup as my main goal is to have something lightweight, that is easily shareable with my team to have a
consistent infrastructure setup ;)</p>
<h3><a id="configure-the-deployment-configuration"></a>Configure the Deployment Configuration</h3>
<p>In PhpStorm, navigate to <code>File | Settings | Build, Execution, Deployment | Deployment</code>.
In the newly opened pop up click on the &quot;+&quot; sign on the top left and choose &quot;From Docker,Vagrant,VM,Remote...&quot; with:</p>
<ul>
<li>Name: Docker (SSH)</li>
<li>Type: SFTP</li>
</ul>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/new-deployment-configuration.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/new-deployment-configuration.PNG" alt="New SFTP Deployment Configuration" /></a></p>
<p>In the <code>Connection</code> tab, choose the following settings:</p>
<ul>
<li>SFTP host: 127.0.0.1</li>
<li>Port: 2222</li>
<li>User name: root</li>
<li>Auth type: Key pair (OpenSSH or PuTTY)</li>
<li>Private key file: <code>C:\codebase\docker-php-tutorial\php-cli\ssh\insecure_id_rsa</code></li>
</ul>
<p><em>Notes</em>:</p>
<ul>
<li>the &quot;Port&quot; corresponds to the port mapping that we defined in the <code>docker-compose.yml</code> file</li>
<li>the &quot;Private key file&quot; is the &quot;insecure&quot; ssh key that matches the public key we specified in the <code>php-cli/Dockerfile</code></li>
</ul>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-connection.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-connection.PNG" alt="Deployment Configuration: Connection" /></a></p>
<p>Hit the &quot;Test SFT connection...&quot; button to test the settings. You should see</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-connection-test.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-connection-test.PNG" alt="Deployment Configuration: Test Connection" /></a></p>
<p>(there might also appear a fingerprint warning because we're using 127.0.0.1 as host. You can simply ignore that warning).</p>
<p>Now choose the <code>Mappings</code> tab and fill it the fields as follows:</p>
<ul>
<li>Local path: <code>C:\codebase\docker-php-tutorial\app</code></li>
<li>Deployment path on server 'Docker (SSH)': <code>/var/www/</code></li>
</ul>
<p>Those mappings correspond to the volume definition for the <code>docker-php-cli</code> service in <code>docker-compose.yml</code>:</p>
<pre><code>[...]
    # mount the app directory of the host to /var/www in the container
    # corresponds to the "-v" option
    volumes:
      - ./app:/var/www
[...]</code></pre>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-path-mappings.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/deployment-configuration-path-mappings.PNG" alt="Deployment Configuration: Path Mappings" /></a></p>
<p>Next, we need to create a PHP Interpreter based on our newly created Deployment Configuration.
Open settings and navigate to <code>File | Settings | Languages &amp; Frameworks | PHP</code>. Click on the three dots &quot;...&quot; next to &quot;CLI Interpreter&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter.PNG" alt="Setup CLI Interpreter PhpStorm" /></a></p>
<p>In the newly opened pop up click on the &quot;+&quot; sign on the top left and choose &quot;From Docker,Vagrant,VM,Remote...&quot;</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-docker.PNG" alt="New CLI Interpreter" /></a></p>
<p>Choose &quot;Deployment Configuration&quot; from the radio buttons and select the &quot;Docker (SSH)&quot; entry. Please make sure to enter
<code>/usr/local/bin/php</code> as path for the PHP executable (as PhpStorm by default will set this path to <code>/usr/bin/php</code>).</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-deployment-configuration.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-from-deployment-configuration.PNG" alt="Setup Docker (SSH) Interpreter" /></a></p>
<p>Set &quot;Docker (SSH)&quot; as name for the new interpreter and click &quot;OK&quot;. </p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-docker-deployment-configuration.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-docker-deployment-configuration.PNG" alt="Finalize Docker (SSH) Interpreter" /></a></p>
<p>Confirm the new PHP Interpreter to close the settings dialog.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-deployment-configuration-done.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/cli-interpreter-deployment-configuration-done.PNG" alt="Confirm Deployment Configuration Interpreter" /></a></p>
<h3><a id="run-debug-a-php-script-on-docker"></a>Run/debug a php script on docker</h3>
<p>To verify that everything is working, open the file <code>app/hello-world.php</code> in PhpStorm, right click in the editor pane and choose &quot;Run&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-run-php-script.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-run-php-script.PNG" alt="Run PHP script" /></a></p>
<p>PhpStorm will start the configured container and run the script. The output is then visible in at the bottom of the IDE:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-ssh-run-php-script-finished.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-ssh-run-php-script-finished.PNG" alt="PHP script output when run via SFTP" /></a></p>
<p>Since we're using an image that has Xdebug installed, we can also set a breakpoint and use &quot;Debug&quot; instead of &quot;Run&quot; to trigger a debug session:</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/docker-debug-php-script.PNG" alt="Debug PHP script" /></a></p>
<p>Hm weird... Although this worked flawlessly when we used the built-in functionality, it does not when we use the Deployment Configuration and shows
a &quot;Connection with 'Xdebug 2.6.0' not established.&quot; error.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/failing-xdebug-connection.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/failing-xdebug-connection.PNG" alt="Xdebug connection cannot be established error" /></a></p>
<h3><a id="fix-xdebug-on-phpstorm-when-run-from-a-docker-container"></a>Fix Xdebug on PhpStorm when run from a Docker container</h3>
<p>Long story short: There is a bug in the networking setup of Docker for Win that makes PhpStorm use the wrong <code>remote_host</code> when it starts a
debugging session. When you take a look at the &quot;Console&quot; panel at the bottom of the IDE, you should see something like this:</p>
<pre><code>sftp://root@127.0.0.1:2222/usr/local/bin/php -dxdebug.remote_enable=1 -dxdebug.remote_mode=req -dxdebug.remote_port=9000 -dxdebug.remote_host=172.18.0.1 /var/www/hello-world.php</code></pre>
<p>The <code>-dxdebug.remote_host=172.18.0.1</code> option is our suspect here. Luckily, since
<a href="https://docs.docker.com/docker-for-windows/networking/#use-cases-and-workarounds">Docker v18.03</a> there is a &quot;magic&quot; DNS entry called `host.docker.internal
that we can use to reach the host from a container.</p>
<p>So, how can we solve this? PhpStorm enables us to
<a href="https://www.jetbrains.com/help/phpstorm/configuring-xdebug.html#d165872e407">pass custom options to Xdebug</a> when a debugging session is initiated.
Open <code>File | Settings | Languages &amp; Frameworks | PHP</code> and click on the &quot;...&quot; next to &quot;PHP Interpreter&quot; to bring up the interpreters. Choose
&quot;Docker (SSH)&quot; in the left pane and click on the little folder icon on the bottom of the window next to &quot;Configuration options&quot;. In the pop up enter
<code>xdebug.remote_host</code> as key and <code>host.docker.internal</code> as value and hit &quot;OK&quot;.</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/xdebug-options.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/xdebug-options.PNG" alt="Configure Xdebug options" /></a></p>
<p>This results in the configuration setting <code>-dxdebug.remote_host=host.docker.internal</code> that is now appended to the remaining (default) arguments
that PhpStorm uses and will <strong>override</strong> any existing options (including the incorrect <code>xdebug.remote_host</code>).</p>
<p><a href="/img/setup-phpstorm-with-xdebug-on-docker/xdebug-options-configured.PNG"><img src="/img/setup-phpstorm-with-xdebug-on-docker/xdebug-options-configured.PNG" alt="Configured Xdebug options" /></a></p>
<p>Initiating a debug session on <code>app/hello-world.php</code> will now finally stop the execution as expected and the
&quot;Console&quot; panel at the bottom of the IDE, shows</p>
<pre><code>sftp://root@127.0.0.1:2222/usr/local/bin/php -dxdebug.remote_enable=1 -dxdebug.remote_mode=req -dxdebug.remote_port=9000 -dxdebug.remote_host=172.18.0.1 -dxdebug.remote_host=host.docker.internal /var/www/hello-world.php</code></pre>
<p>This setup denotes the end of the second tutorial. In the next part we will take a <strong>much</strong> deeper look into Xdebug to fully understand how it works
(especially in combination with PhpStorm), how to fix common problems and make it work in different scenarios (debugging from the browser, from php workers, etc.).</p>]]></description>
                <pubDate>Mon, 06 Aug 2018 12:00:00 +0000</pubDate>
                <link>https://www.pascallandau.com/blog/setup-phpstorm-with-xdebug-on-docker/?utm_source=blog&amp;utm_medium=rss&amp;utm_campaign=global-feed</link>
                <guid isPermaLink="true">https://www.pascallandau.com/blog/setup-phpstorm-with-xdebug-on-docker/</guid>
            </item>
            </channel>
</rss>
